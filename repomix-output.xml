This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/*.log, tmp/, node_modules/*, package-lock.json, *.lock, *.md, **/*.mtn
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
auth/
  auth_keys.example.json
config/
  config.example.json
routes/
  audio.js
  twitch.js
  v1.js
  web.js
utils/
  api-utils.js
  cache-utils.js
  error-utils.js
  file-utils.js
  index.js
  string-utils.js
views/
  character-details.njk
  character.njk
  dashboard.njk
  gallery.njk
  help.njk
  layout.njk
  login.njk
  settings.njk
  world.njk
.cache_ggshield
.gitignore
ai-logic.js
api-helper.js
audio-processor.js
chat-handler.js
config-helper.js
create-global-logger.js
data-helper.js
error.txt
index.js
logger.js
main.js
mongodb-client.js
oai-requests.js
package.json
prompt-helper.js
response-monitor.js
restart-helper.js
start.bat
template-engine.js
token-helper.js
twitch-eventsub-manager.js
twitch-helper.js
twitch-webhook-tester.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="utils/api-utils.js">
import axios from 'axios';
import https from 'https';
import { logger } from '../create-global-logger.js';

/**
 * Creates an axios instance with consistent defaults
 * @param {object} options - Configuration options
 * @returns {object} - Configured axios instance
 */
export function createApiClient(options = {}) {
  const {
    baseURL = '',
    timeout = 15000,
    headers = {},
    keepAlive = true
  } = options;
  
  // Create https agent with keep-alive
  const httpsAgent = new https.Agent({
    keepAlive,
    rejectUnauthorized: true,
    timeout: timeout
  });
  
  return axios.create({
    baseURL,
    timeout,
    headers: {
      'User-Agent': 'Enspira/1.0',
      'Accept': 'application/json',
      ...headers
    },
    httpsAgent
  });
}

/**
 * Makes API request with automatic retries
 * @param {function} requestFn - Function that returns a promise (e.g., axios call)
 * @param {object} options - Retry options
 * @returns {Promise<any>} - API response
 */
export async function makeRequestWithRetry(requestFn, options = {}) {
  const {
    maxRetries = 3,
    initialDelay = 500,
    maxDelay = 10000,
    factor = 2,
    retryStatusCodes = [408, 429, 500, 502, 503, 504],
    retryErrorCodes = ['ETIMEDOUT', 'ECONNRESET', 'ECONNABORTED', 'EPIPE'],
    logContext = "API"
  } = options;
  
  let lastError;
  let delay = initialDelay;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await requestFn();
    } catch (error) {
      lastError = error;
      
      // Determine if error is retryable
      const statusCode = error.response?.status;
      const isRetryable = 
        retryStatusCodes.includes(statusCode) || 
        retryErrorCodes.includes(error.code);
      
      if (isRetryable && attempt < maxRetries - 1) {
        // Calculate backoff with jitter
        const jitterDelay = Math.min(
          maxDelay, 
          delay * (0.75 + Math.random() * 0.5)
        );
        
        logger.warn(
          logContext,
          `Request failed (${statusCode || error.code}). Retrying in ${Math.round(jitterDelay)}ms. Attempt ${attempt + 1}/${maxRetries}`
        );
        
        // Wait before retry
        await new Promise(resolve => setTimeout(resolve, jitterDelay));
        delay *= factor;
      } else {
        break;
      }
    }
  }
  
  throw lastError;
}

/**
 * Simplified form data submission with proper error handling
 * @param {string} url - Target URL
 * @param {object} formData - Form data to submit
 * @param {object} [options] - Additional options
 * @returns {Promise<object>} - Response data
 */
export async function submitFormData(url, formData, options = {}) {
  const {
    method = 'POST',
    headers = {},
    timeout = 30000,
    maxRetries = 3
  } = options;
  
  const requestFn = () => axios({
    method,
    url,
    data: formData,
    headers: {
      ...headers,
      'Content-Type': 'multipart/form-data'
    },
    timeout,
    maxContentLength: 100 * 1024 * 1024, // 100MB
    maxBodyLength: 100 * 1024 * 1024 // 100MB
  });
  
  return makeRequestWithRetry(requestFn, { maxRetries });
}
</file>

<file path="utils/cache-utils.js">
import { logger } from '../create-global-logger.js';

/**
 * Creates a configurable in-memory cache
 * @param {object} options - Cache configuration
 * @returns {object} - Cache controller
 */
export function createCache(options = {}) {
  const {
    maxSize = 500,
    defaultTtl = 60000, // 1 minute
    name = 'cache',
    logHits = false
  } = options;
  
  const cache = new Map();
  let hitCount = 0;
  let missCount = 0;
  
  /**
   * Checks if key exists and isn't expired
   * @param {string} key - Cache key
   * @returns {boolean} - Whether key exists and is valid
   */
  function has(key) {
    if (!cache.has(key)) {
      return false;
    }
    
    const { expiry } = cache.get(key);
    if (Date.now() > expiry) {
      cache.delete(key);
      return false;
    }
    
    return true;
  }
  
  /**
   * Gets value from cache
   * @param {string} key - Cache key
   * @returns {any} - Cached value or null if missing/expired
   */
  function get(key) {
    if (!has(key)) {
      missCount++;
      return null;
    }
    
    hitCount++;
    if (logHits) {
      logger.log('Cache', `${name} cache hit for: ${key}`);
    }
    
    return cache.get(key).data;
  }
  
  /**
   * Stores value in cache
   * @param {string} key - Cache key
   * @param {any} value - Value to store
   * @param {number} [ttl] - Custom TTL in ms
   */
  function set(key, value, ttl = defaultTtl) {
    // Evict oldest entry if at capacity
    if (cache.size >= maxSize) {
      let oldest = null;
      let oldestTime = Infinity;
      
      for (const [existingKey, entry] of cache.entries()) {
        if (entry.expiry < oldestTime) {
          oldestTime = entry.expiry;
          oldest = existingKey;
        }
      }
      
      if (oldest) {
        cache.delete(oldest);
      }
    }
    
    cache.set(key, {
      data: value,
      expiry: Date.now() + ttl,
      created: Date.now()
    });
  }
  
  /**
   * Gets a value or generates it if missing
   * @param {string} key - Cache key
   * @param {function} fetchFn - Function to generate value
   * @param {object} [options] - Additional options
   * @returns {Promise<any>} - Retrieved or generated value
   */
  async function getOrSet(key, fetchFn, options = {}) {
    const { ttl = defaultTtl, forceFresh = false } = options;
    
    // Return cached value if valid and not forcing refresh
    if (!forceFresh && has(key)) {
      return get(key);
    }
    
    try {
      // Generate new value
      const freshValue = await fetchFn();
      
      // Only cache if value exists
      if (freshValue !== undefined && freshValue !== null) {
        set(key, freshValue, ttl);
      }
      
      return freshValue;
    } catch (error) {
      logger.error('Cache', `Error generating value for key '${key}': ${error.message}`);
      throw error;
    }
  }
  
  /**
   * Deletes a key from cache
   * @param {string} key - Key to delete
   * @returns {boolean} - Whether deletion was successful
   */
  function del(key) {
    return cache.delete(key);
  }
  
  /**
   * Clears all or matching entries
   * @param {string} [pattern] - Optional pattern to match keys
   * @returns {number} - Number of entries cleared
   */
  function clear(pattern = null) {
    if (!pattern) {
      const size = cache.size;
      cache.clear();
      return size;
    }
    
    let count = 0;
    for (const key of cache.keys()) {
      if (key.includes(pattern)) {
        cache.delete(key);
        count++;
      }
    }
    
    return count;
  }
  
  /**
   * Gets cache statistics
   * @returns {object} - Cache statistics
   */
  function stats() {
    return {
      size: cache.size,
      maxSize,
      hits: hitCount,
      misses: missCount,
      hitRate: hitCount + missCount > 0 
        ? hitCount / (hitCount + missCount) 
        : 0
    };
  }
  
  return {
    get,
    set,
    has,
    del,
    clear,
    getOrSet,
    stats
  };
}

/**
 * Creates a disk cache with filesystem persistence
 * @param {object} options - Cache configuration
 * @returns {object} - Disk cache controller
 */
export function createDiskCache(options = {}) {
  // Implementation details would go here
  // This would use fs-extra to persist cache entries to disk
  // with similar interface to in-memory cache
}
</file>

<file path="utils/error-utils.js">
import { logger } from '../create-global-logger.js';

/**
 * Standard error structure for consistent error handling
 */
export class ApplicationError extends Error {
  constructor(message, options = {}) {
    super(message);
    
    const {
      code = 'INTERNAL_ERROR',
      statusCode = 500,
      context = 'Application',
      details = null,
      cause = null,
      logLevel = 'error'
    } = options;
    
    this.name = this.constructor.name;
    this.code = code;
    this.statusCode = statusCode;
    this.context = context;
    this.details = details;
    this.cause = cause;
    this.timestamp = new Date();
    
    // Log automatically on creation
    logger[logLevel](context, message);
    
    // Capture stack trace
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  
  /**
   * Creates a formatted response object
   * @returns {object} - Response error object
   */
  toResponse() {
    return {
      error: {
        code: this.code,
        message: this.message,
        details: this.details,
        timestamp: this.timestamp.toISOString()
      }
    };
  }
}

/**
 * Executes function with standard error handling
 * @param {function} fn - Function to execute
 * @param {object} [options] - Error handling options
 * @returns {Promise<any>} - Function result or error
 */
export async function withErrorHandling(fn, options = {}) {
  const {
    context = 'Application',
    defaultValue = null,
    rethrow = false,
    errorFormatter = null,
    logError = true,
    captureAll = false
  } = options;
  
  try {
    return await fn();
  } catch (error) {
    if (logError) {
      if (error instanceof ApplicationError) {
        // Already logged during creation
      } else {
        logger.error(context, `${error.message}`);
      }
    }
    
    if (rethrow) {
      // Format error if requested
      if (errorFormatter && typeof errorFormatter === 'function') {
        throw errorFormatter(error);
      }
      
      // Convert to ApplicationError if not already
      if (!(error instanceof ApplicationError) && captureAll) {
        throw new ApplicationError(error.message, {
          context,
          cause: error,
          details: {
            originalError: {
              name: error.name,
              stack: error.stack
            }
          }
        });
      }
      
      throw error;
    }
    
    return defaultValue;
  }
}

/**
 * Creates an error handler for specific contexts
 * @param {string} context - Error context name
 * @returns {function} - Configured error handler
 */
export function createErrorHandler(context) {
  return async (fn, options = {}) => {
    return withErrorHandling(fn, {
      context,
      ...options
    });
  };
}
</file>

<file path="utils/file-utils.js">
import fs from 'fs-extra';
import path from 'path';
import { logger } from '../create-global-logger.js';

// Cache for template files
const templateCache = new Map();

/**
 * Reads a template file with caching
 * @param {string} filePath - Path to template file
 * @returns {Promise<string>} - Template content
 */
export async function getTemplate(filePath) {
  if (templateCache.has(filePath)) {
    return templateCache.get(filePath);
  }
  
  try {
    const content = await fs.readFile(filePath, "utf-8");
    templateCache.set(filePath, content);
    return content;
  } catch (error) {
    logger.error("Files", `Error reading template file ${filePath}: ${error.message}`);
    throw error;
  }
}

/**
 * Reads multiple files in parallel and returns contents organized by file name
 * @param {string} basePath - Base directory path
 * @param {string[]} fileNames - Array of file names to read
 * @param {string} [extension='.txt'] - File extension
 * @returns {Promise<object>} - Object with fileNames as keys and content as values
 */
export async function readMultipleFiles(basePath, fileNames, extension = '.txt') {
  const fileContents = {};
  
  await Promise.all(
    fileNames.map(async (fileName) => {
      const filePath = path.join(basePath, `${fileName}${extension}`);
      try {
        fileContents[fileName] = await fs.readFile(filePath, "utf-8");
      } catch (error) {
        logger.log("Files", `Error reading file ${filePath}: ${error.message}`);
        fileContents[fileName] = ""; // Default empty string for missing files
      }
    })
  );
  
  return fileContents;
}

/**
 * Safely writes JSON data to a file with proper error handling
 * @param {string} filePath - Path to write the file
 * @param {object} data - Data to write
 * @param {object} [options] - Options for writing
 * @returns {Promise<boolean>} - Success indicator
 */
export async function safeWriteJSON(filePath, data, options = {}) {
  try {
    // Ensure directory exists
    await fs.ensureDir(path.dirname(filePath));
    
    // Write with custom options or defaults
    await fs.writeJSON(filePath, data, {
      spaces: 2,
      EOL: '\n',
      ...options
    });
    
    return true;
  } catch (error) {
    logger.error("Files", `Error writing JSON to ${filePath}: ${error.message}`);
    return false;
  }
}
</file>

<file path="utils/index.js">
// Barrel file to easily export all utilities
export * from './file-utils.js';
export * from './api-utils.js';
export * from './cache-utils.js';
export * from './string-utils.js';
export * from './error-utils.js';

// Import commonly used utilities for quick access
import { getTemplate, readMultipleFiles, safeWriteJSON } from './file-utils.js';
import { makeRequestWithRetry, createApiClient } from './api-utils.js';
import { createCache } from './cache-utils.js';
import { replacePlaceholders, transformTtsText } from './string-utils.js';
import { withErrorHandling, ApplicationError } from './error-utils.js';

// Export common combinations
export const utils = {
  file: {
    getTemplate,
    readMultipleFiles,
    safeWriteJSON
  },
  api: {
    makeRequestWithRetry,
    createApiClient
  },
  cache: {
    createCache
  },
  string: {
    replacePlaceholders,
    transformTtsText
  },
  error: {
    withErrorHandling,
    ApplicationError
  }
};

export default utils;
</file>

<file path="utils/string-utils.js">
/**
 * Replaces placeholders in template strings
 * @param {string} template - Template string with placeholders
 * @param {object} replacements - Map of placeholders to values
 * @returns {string} - Processed string
 */
export function replacePlaceholders(template, replacements) {
    if (!template) return '';
    
    let result = template;
    for (const [placeholder, value] of Object.entries(replacements)) {
      // Skip undefined values
      if (value === undefined) continue;
      
      // Convert null to empty string
      const replacement = value === null ? '' : value;
      
      // Use global regex for all occurrences
      result = result.replace(
        new RegExp(escapeRegExp(placeholder), 'g'), 
        replacement
      );
    }
    
    return result;
  }
  
  /**
   * Escapes special characters in string for regex
   * @param {string} string - String to escape
   * @returns {string} - Escaped string
   */
  export function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }
  
  /**
   * Transforms TTS text by handling acronyms and special formats
   * @param {string} input - Input string
   * @param {object} [options] - Transformation options
   * @returns {object} - Transformed string and statistics
   */
  export function transformTtsText(input, options = {}) {
    const {
      acronymExceptions = ["GOATs", "LOL", "LMAO"],
      separateWithDots = true
    } = options;
    
    const acronymRegex = /\b([A-Z]{2,})(?!\w)/g;
    const jsRegex = /\.js\b/gi;
    
    let acronymCount = 0;
    let jsCount = 0;
    
    let transformed = input.replace(acronymRegex, (match) => {
      if (acronymExceptions.includes(match)) {
        return match;
      }
      
      acronymCount++;
      
      if (separateWithDots) {
        let result = match.slice(0, -1).split("").join(".") + "." + match.slice(-1);
        if (match.endsWith("S") && match.length > 2) {
          const base = match.slice(0, -1).split("").join(".");
          result = `${base}'s`;
        }
        return result;
      } else {
        // Alternate transformation: spell out with spaces
        return match.split("").join(" ");
      }
    });
    
    transformed = transformed.replace(jsRegex, (match) => {
      jsCount++;
      return ".J.S";
    });
    
    return { 
      text: transformed, 
      stats: {
        acronymCount,
        jsCount
      }
    };
  }
  
  /**
   * Formats a string for fixed character limit
   * @param {string} input - Input string
   * @param {number} maxLength - Maximum length
   * @returns {string} - Truncated string
   */
  export function truncateWithEllipsis(input, maxLength) {
    if (!input || input.length <= maxLength) {
      return input;
    }
    
    // Find a good breaking point
    const breakPoint = input.lastIndexOf(' ', maxLength - 3);
    if (breakPoint > maxLength * 0.7) {
      return input.substring(0, breakPoint) + '...';
    }
    
    // If no good breaking point, just truncate
    return input.substring(0, maxLength - 3) + '...';
  }
</file>

<file path="views/help.njk">
{% extends "layout.njk" %}

{% block title %}Help & Documentation{% endblock %}

{% block content %}
<div class="card">
  <div class="card-header">
    <h1>Help & Documentation</h1>
  </div>
  
  <p>Welcome to Enspira's Help page! This guide explains how to use template variables in your character, world info, and scenario settings. Simply insert these variables in your templates, and they will be automatically replaced with your data.</p>
  
  <div class="card" style="margin-top: 20px; background-color: rgba(88, 166, 255, 0.1); border-color: var(--accent);">
    <h2 style="margin-top: 0;">Quick Reference</h2>
    <p>Commonly used variables:</p>
    <div class="scope-list" style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 10px;">
      <code class="scope">&#123;&#123;user&#125;&#125;</code>
      <code class="scope">&#123;&#123;char&#125;&#125;</code>
      <code class="scope">&#123;&#123;socials&#125;&#125;</code>
      <code class="scope">&#123;&#123;socials.twitter&#125;&#125;</code>
      <code class="scope">&#123;&#123;datetime&#125;&#125;</code>
      <code class="scope">&#123;&#123;current_game&#125;&#125;</code>
      <code class="scope">&#123;&#123;current_views&#125;&#125;</code>
    </div>
  </div>
  
  <h2 class="section-title">Template Variables</h2>
  
  <div class="card">
    <h3 class="card-subtitle">Character Card & World Information Variables</h3>
    <ul class="variable-list">
      <li class="variable-item">
        <code class="variable-name">&#123;&#123;user&#125;&#125;</code>
        <span class="variable-desc">Your name as recognized by the assistant – typically your streaming username</span>
      </li>
      <li class="variable-item">
        <code class="variable-name">&#123;&#123;char&#125;&#125;</code>
        <span class="variable-desc">The name of your AI assistant or character</span>
      </li>
      <li class="variable-item">
        <code class="variable-name">&#123;&#123;socials&#125;&#125;</code>
        <span class="variable-desc">A pre-formatted list of all your linked social media accounts</span>
      </li>
      <li class="variable-item">
        <code class="variable-name">&#123;&#123;socials.xxx&#125;&#125;</code>
        <span class="variable-desc">A specific social media account where xxx is one of:</span>
        <div class="platform-list">
          <span class="platform">tiktok</span>
          <span class="platform">youtube</span>
          <span class="platform">twitch</span>
          <span class="platform">twitter</span>
          <span class="platform">kick</span>
        </div>
      </li>
      <li class="variable-item">
        <code class="variable-name">&#123;&#123;datetime&#125;&#125;</code>
        <span class="variable-desc">The current date and time</span>
      </li>
    </ul>
  </div>
  
  <div class="card">
    <h3 class="card-subtitle">Scenario Variables</h3>
    <ul class="variable-list">
      <li class="variable-item">
        <code class="variable-name">&#123;&#123;current_game&#125;&#125;</code>
        <span class="variable-desc">The game you are currently playing, as retrieved from Twitch</span>
      </li>
      <li class="variable-item">
        <code class="variable-name">&#123;&#123;current_views&#125;&#125;</code>
        <span class="variable-desc">The current viewer count of your Twitch channel</span>
      </li>
      <li class="variable-item">
        <code class="variable-name">&#123;&#123;current_follows&#125;&#125;</code>
        <span class="variable-desc">Your current follower count from Twitch</span>
      </li>
      <li class="variable-item">
        <span class="variable-desc">Also available: <code class="inline-code">&#123;&#123;user&#125;&#125;</code>, <code class="inline-code">&#123;&#123;char&#125;&#125;</code>, <code class="inline-code">&#123;&#123;socials&#125;&#125;</code>, <code class="inline-code">&#123;&#123;socials.xxx&#125;&#125;</code>, and <code class="inline-code">&#123;&#123;datetime&#125;&#125;</code></span>
      </li>
    </ul>
  </div>
  
  <h2 class="section-title">How to Use Template Variables</h2>
  
  <div class="card">
    <p>When editing your character, world, or scenario, simply place these variables within your content. For example, to display your name, include <code class="inline-code">&#123;&#123;user&#125;&#125;</code> where appropriate.</p>
    
    <h4 class="example-heading">Example Template:</h4>
    <pre class="code-example">Hello, my name is &#123;&#123;char&#125;&#125; and I'm &#123;&#123;user&#125;&#125;'s AI assistant!
You can follow &#123;&#123;user&#125;&#125; on Twitter at @&#123;&#123;socials.twitter&#125;&#125;

The current game being played is &#123;&#123;current_game&#125;&#125;
There are &#123;&#123;current_views&#125;&#125; viewers watching right now!</pre>
  </div>
  
  <h2 class="section-title">Tips for Effective Templates</h2>
  
  <div class="card">
    <ul class="tips-list">
      <li class="tip-item">Always use the exact variable names as shown above (including curly braces)</li>
      <li class="tip-item">For social media handles, replace <code class="inline-code">xxx</code> in <code class="inline-code">&#123;&#123;socials.xxx&#125;&#125;</code> with a valid platform name</li>
      <li class="tip-item">Combine static text with variables to craft personalized messages</li>
      <li class="tip-item">Preview your changes to see how the data populates</li>
      <li class="tip-item">Be aware that some variables (like <code class="inline-code">&#123;&#123;current_game&#125;&#125;</code>) will only display data when your stream is active</li>
    </ul>
  </div>
  
  <div class="card" style="margin-top: 20px; background-color: rgba(86, 211, 100, 0.1); border-color: var(--success);">
    <p style="margin: 0;">This guide is designed to help you create dynamic, data-driven character and world settings for your stream. If you have questions, check our <a href="https://github.com/prolix-oc/Enspira" target="_blank">GitHub repository</a> or reach out to the community.</p>
  </div>
</div>
{% endblock %}

{% block extraStyles %}
<style>
  .section-title {
    margin-top: 30px;
    border-bottom: 1px solid var(--border);
    padding-bottom: 10px;
  }
  
  .card-subtitle {
    margin-top: 0;
    color: var(--accent);
  }
  
  .variable-list {
    list-style-type: none;
    padding-left: 0;
  }
  
  .variable-item {
    margin-bottom: 12px;
    padding-left: 20px;
    position: relative;
  }
  
  .variable-item::before {
    content: '›';
    position: absolute;
    left: 0;
    top: 2px;
    color: var(--accent);
  }
  
  .variable-name {
    background: var(--input-bg);
    padding: 2px 6px;
    border-radius: 4px;
    font-weight: bold;
    font-family: monospace;
  }
  
  .variable-desc {
    margin-left: 5px;
  }
  
  .platform-list {
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
    margin-top: 5px;
    margin-left: 20px;
  }
  
  .platform {
    background: rgba(100, 65, 164, 0.2);
    color: #d2b8ff;
    padding: 3px 8px;
    border-radius: 4px;
    font-size: 0.9em;
  }
  
  .inline-code {
    background: var(--input-bg);
    padding: 2px 6px;
    border-radius: 4px;
    font-family: monospace;
  }
  
  .code-example {
    background-color: var(--input-bg);
    padding: 15px;
    border-radius: 8px;
    overflow-x: auto;
    white-space: pre-wrap;
    margin-top: 10px;
  }
  
  .example-heading {
    margin-top: 20px;
    color: var(--accent);
  }
  
  .tips-list {
    list-style-type: none;
    padding-left: 0;
  }
  
  .tip-item {
    margin-bottom: 12px;
    padding-left: 25px;
    position: relative;
  }
  
  .tip-item::before {
    content: '✓';
    position: absolute;
    left: 0;
    top: 2px;
    color: var(--success);
    font-weight: bold;
  }
  
  .scope {
    background-color: var(--button-secondary-bg);
    padding: 4px 10px;
    border-radius: 4px;
    font-family: monospace;
  }
  
  .scope-list {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }
</style>
{% endblock %}
</file>

<file path="views/login.njk">
{% extends "layout.njk" %}

{% block title %}Login{% endblock %}

{% block content %}
<div class="card login-card">
  <div class="card-header">
    <h1>Welcome to Enspira</h1>
  </div>
  
  {% if error %}
  <div class="alert alert-error">{{ error }}</div>
  {% endif %}
  
  <form action="/api/v1/auth/login" method="POST">
    <div class="form-group">
      <label for="user_id">User ID</label>
      <input type="text" id="user_id" name="user_id" required>
    </div>
    
    <div class="form-group">
      <label for="password">Password</label>
      <input type="password" id="password" name="password" required>
    </div>
    
    <button type="submit" class="btn btn-primary">Login</button>
  </form>
</div>
{% endblock %}

{% block extraStyles %}
<style>
  .login-card {
    max-width: 500px;
    margin: 40px auto;
  }
</style>
{% endblock %}
</file>

<file path="views/settings.njk">
{% extends "layout.njk" %}

{% block title %}User Settings{% endblock %}

{% block content %}
<div class="card">
  <div class="card-header">
    <h1>User Settings</h1>
  </div>
  
  <p>Customize your account settings and preferences for Enspira.</p>
  
  {% if success %}
  <div class="alert alert-success">
    {{ success }}
  </div>
  {% endif %}
  
  {% if error %}
  <div class="alert alert-error">
    {{ error }}
  </div>
  {% endif %}
  
  <div class="tabs">
    <div class="tab active" data-target="profile-tab">Profile</div>
    <div class="tab" data-target="socials-tab">Social Media</div>
    <div class="tab" data-target="security-tab">Security</div>
    <div class="tab" data-target="preferences-tab">Preferences</div>
  </div>
  
  <!-- Profile Settings -->
  <div id="profile-tab" class="tab-content active">
    <form action="/api/v1/settings/profile" method="POST" data-async>
      <div class="form-group">
        <label for="display_name">Display Name</label>
        <input type="text" id="display_name" name="display_name" value="{{ user.display_name }}" required>
        <p>The name displayed in the Enspira interface.</p>
      </div>
      
      <div class="form-group">
        <label for="user_name">Character Reference Name</label>
        <input type="text" id="user_name" name="user_name" value="{{ user.user_name }}" required>
        <p>The name your AI assistant will use to refer to you.</p>
      </div>
      
      <div class="form-group">
        <label for="email">Email Address</label>
        <input type="email" id="email" name="email" value="{{ user.email }}">
        <p>Your email address for notifications and account recovery.</p>
      </div>
      
      <div class="form-group">
        <label for="timeZone">Time Zone</label>
        <select id="timeZone" name="timeZone">
          <option value="">Select Time Zone</option>
          {% for tz in timeZones %}
            <option value="{{ tz.value }}" {% if user.timeZone == tz.value %}selected{% endif %}>{{ tz.label }}</option>
          {% endfor %}
        </select>
        <p>Your local time zone for scheduling and events.</p>
      </div>
      
      <button type="submit" class="btn btn-primary">Save Profile</button>
    </form>
  </div>
  
  <!-- Social Media Settings -->
  <div id="socials-tab" class="tab-content">
    <form action="/api/v1/settings/socials" method="POST" data-async>
      <div class="form-group">
        <label for="twitter">X (Twitter)</label>
        <input type="text" id="twitter" name="socials[twitter]" value="{{ user.socials.twitter }}">
        <p>Your X/Twitter username (without @).</p>
      </div>
      
      <div class="form-group">
        <label for="tiktok">TikTok</label>
        <input type="text" id="tiktok" name="socials[tiktok]" value="{{ user.socials.tiktok }}">
        <p>Your TikTok username.</p>
      </div>
      
      <div class="form-group">
        <label for="youtube">YouTube</label>
        <input type="text" id="youtube" name="socials[youtube]" value="{{ user.socials.youtube }}">
        <p>Your YouTube channel name or ID.</p>
      </div>
      
      <div class="form-group">
        <label for="instagram">Instagram</label>
        <input type="text" id="instagram" name="socials[instagram]" value="{{ user.socials.instagram }}">
        <p>Your Instagram username.</p>
      </div>
      
      <div class="form-group">
        <label for="twitch">Twitch</label>
        <input type="text" id="twitch" name="socials[twitch]" value="{{ user.socials.twitch }}">
        <p>Your Twitch username.</p>
      </div>
      
      <div class="form-group">
        <label for="kick">Kick</label>
        <input type="text" id="kick" name="socials[kick]" value="{{ user.socials.kick }}">
        <p>Your Kick username.</p>
      </div>
      
      <button type="submit" class="btn btn-primary">Save Social Media</button>
    </form>
  </div>
  
  <!-- Security Settings -->
  <div id="security-tab" class="tab-content">
    <form action="/api/v1/settings/password" method="POST" data-async>
      <div class="form-group">
        <label for="current_password">Current Password</label>
        <input type="password" id="current_password" name="current_password" required>
        <p>Your current password for verification.</p>
      </div>
      
      <div class="form-group">
        <label for="new_password">New Password</label>
        <input type="password" id="new_password" name="new_password" required>
        <p>Your new password. Use a strong, unique password.</p>
      </div>
      
      <div class="form-group">
        <label for="confirm_password">Confirm New Password</label>
        <input type="password" id="confirm_password" name="confirm_password" required>
        <p>Re-enter your new password to confirm.</p>
      </div>
      
      <button type="submit" class="btn btn-primary">Change Password</button>
    </form>
  </div>
  
  <!-- Preferences Settings -->
  <div id="preferences-tab" class="tab-content">
    <form action="/api/v1/settings/preferences" method="POST" data-async>
      <div class="form-group">
        <label for="store_all_chat">Store All Chat Messages</label>
        <select id="store_all_chat" name="store_all_chat">
          <option value="true" {% if user.store_all_chat %}selected{% endif %}>Enabled</option>
          <option value="false" {% if not user.store_all_chat %}selected{% endif %}>Disabled</option>
        </select>
        <p>When enabled, all chat messages will be stored for context, not just messages directed at your assistant.</p>
      </div>
      
      <div class="form-group">
        <label for="tts_enabled">Text-to-Speech</label>
        <select id="tts_enabled" name="tts_enabled">
          <option value="true" {% if user.tts_enabled %}selected{% endif %}>Enabled</option>
          <option value="false" {% if not user.tts_enabled %}selected{% endif %}>Disabled</option>
        </select>
        <p>Enable or disable text-to-speech for your assistant.</p>
      </div>
      
      <div class="form-group">
        <label for="ttsEqPref">TTS Voice Quality Preset</label>
        <select id="ttsEqPref" name="ttsEqPref">
          <option value="clarity" {% if user.ttsEqPref == 'clarity' %}selected{% endif %}>Clarity</option>
          <option value="warm" {% if user.ttsEqPref == 'warm' %}selected{% endif %}>Warm</option>
          <option value="bright" {% if user.ttsEqPref == 'bright' %}selected{% endif %}>Bright</option>
          <option value="broadcast" {% if user.ttsEqPref == 'broadcast' %}selected{% endif %}>Broadcast</option>
        </select>
        <p>Choose a preset for your assistant's voice quality.</p>
      </div>
      
      <div class="form-group">
        <label for="ttsUpsamplePref">TTS Audio Upsampling</label>
        <select id="ttsUpsamplePref" name="ttsUpsamplePref">
          <option value="true" {% if user.ttsUpsamplePref %}selected{% endif %}>Enabled</option>
          <option value="false" {% if not user.ttsUpsamplePref %}selected{% endif %}>Disabled</option>
        </select>
        <p>Enable or disable audio upsampling for better voice quality (uses more CPU).</p>
      </div>
      
      <button type="submit" class="btn btn-primary">Save Preferences</button>
    </form>
  </div>
</div>
{% endblock %}

{% block extraStyles %}
<style>
  .form-group {
    margin-bottom: 24px;
  }
  
  .form-group label {
    display: block;
    font-weight: 600;
    margin-bottom: 8px;
  }
  
  .form-group p {
    margin-top: 4px;
    font-size: 0.9em;
    color: var(--secondary-text);
  }
  
  .form-group input,
  .form-group select {
    width: 100%;
    max-width: 500px;
  }
  
  .tabs {
    margin-bottom: 20px;
  }
</style>
{% endblock %}
</file>

<file path="views/world.njk">
{% extends "layout.njk" %}

{% block title %}World Editor{% endblock %}

{% block content %}
<div class="card">
  <div class="card-header">
    <h1>World Editor</h1>
  </div>
  
  <p>Define the context and environment for your AI assistant. These settings help create the world in which your assistant exists and operates.</p>
  
  <div class="tabs">
    <div class="tab active" data-target="world-info-tab">World Information</div>
    <div class="tab" data-target="player-info-tab">Player Information</div>
    <div class="tab" data-target="scenario-tab">Scenario</div>
    <div class="tab" data-target="bot-config-tab">Bot Configuration</div>
  </div>
  
  <div id="world-info-tab" class="tab-content active">
    <form action="/api/v1/world/info" method="POST" data-async>
      <div class="form-group">
        <label for="world_info">World Information</label>
        <textarea id="world_info" name="world_info" rows="15" required>{{ worldInfo }}</textarea>
        <p>Describe the setting, background, lore, and context where your assistant exists. This could include fictional elements, time period, relevant history, or any other details that help establish the world.</p>
      </div>
      
      <div class="form-group">
        <label for="weather_enabled">Enable Weather</label>
        <select id="weather_enabled" name="weather_enabled">
          <option value="true" {% if character.weather %}selected{% endif %}>Enabled</option>
          <option value="false" {% if not character.weather %}selected{% endif %}>Disabled</option>
        </select>
        <p>When enabled, your assistant will have access to real-time weather information based on your location.</p>
      </div>
      
      <button type="submit" class="btn btn-primary">Save World Information</button>
    </form>
  </div>
  
  <div id="player-info-tab" class="tab-content">
    <form action="/api/v1/world/player" method="POST" data-async>
      <div class="form-group">
        <label for="player_info">Player Information</label>
        <textarea id="player_info" name="player_info" rows="15" required>{{ playerInfo }}</textarea>
        <p>Information about you (the streamer) that the assistant should know. This could include your preferences, streaming style, topics to focus on or avoid, personal details you're comfortable sharing, etc.</p>
      </div>
      
      <button type="submit" class="btn btn-primary">Save Player Information</button>
    </form>
  </div>
  
  <div id="scenario-tab" class="tab-content">
    <form action="/api/v1/world/scenario" method="POST" data-async>
      <div class="form-group">
        <label for="scenario">Scenario</label>
        <textarea id="scenario" name="scenario" rows="15" required>{{ scenario }}</textarea>
        <p>Describe the specific situation or context in which the assistant is participating. This could be the premise of your stream, the assistant's role, or the ongoing narrative.</p>
      </div>
      
      <button type="submit" class="btn btn-primary">Save Scenario</button>
    </form>
  </div>
  
  <div id="bot-config-tab" class="tab-content">
    <form action="/api/v1/world/bot-config" method="POST" data-async>
      <div class="form-group">
        <label for="commands_list">Chat Commands</label>
        <textarea id="commands_list" name="commands_list" rows="5">{{ commandsList }}</textarea>
        <p>List of chat commands your bot should recognize but not respond to (one per line, e.g., !discord, !socials).</p>
      </div>
      
      <div class="form-group">
        <label for="aux_bots">Auxiliary Bots</label>
        <textarea id="aux_bots" name="aux_bots" rows="5">{{ auxBots }}</textarea>
        <p>List of other bot usernames in your chat that your assistant should ignore (one per line, e.g., Nightbot, StreamElements).</p>
      </div>
      
      <button type="submit" class="btn btn-primary">Save Bot Configuration</button>
    </form>
  </div>
</div>
{% endblock %}

{% block extraScripts %}
<script>
  // Auto-resize textareas as content grows
  document.addEventListener('DOMContentLoaded', () => {
    const textareas = document.querySelectorAll('textarea');
    textareas.forEach(textarea => {
      const adjustHeight = () => {
        textarea.style.height = 'auto';
        textarea.style.height = (textarea.scrollHeight) + 'px';
      };
      
      // Initial adjustment
      adjustHeight();
      
      // Adjust on input
      textarea.addEventListener('input', adjustHeight);
      
      // Adjust when tab is shown
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
          setTimeout(adjustHeight, 10);
        });
      });
    });
  });
</script>
{% endblock %}
</file>

<file path=".cache_ggshield">
{"last_found_secrets": [{"name": "X-API-Key Secret - commit://11c6c9bf712f664abba77430c40c05dfbef277bf/api-helper.js", "match": "cdffb8af31330a4950b3ed169ccb734b93d10f4980bffddc814bf4598f1e4359"}]}
</file>

<file path="chat-handler.js">
// chat-handler.js
import { respondToChat, respondToEvent } from './ai-logic.js';
import { containsCharacterName, containsAuxBotName } from './prompt-helper.js';
import { isCommandMatch } from './twitch-helper.js';
import { logger } from './create-global-logger.js';
import { returnAuthObject } from './api-helper.js';
import { addChatMessageAsVector } from './ai-logic.js';
import { sendChatMessage } from './twitch-eventsub-manager.js';

/**
 * Central handler for all chat messages from any source (API or EventSub)
 * @param {object} chatData - Normalized chat message data
 * @param {string} userId - The system user ID
 * @param {boolean} autoRespond - Whether to automatically send Twitch chat responses
 * @returns {Promise<object>} - Processing result with response if applicable
 */
export async function handleChatMessage(chatData, userId, autoRespond = false) {
  try {
    const user = await returnAuthObject(userId);
    if (!user) {
      logger.error("Chat", `User ${userId} not found`);
      return { success: false, error: "User not found" };
    }

    // Extract message details
    const { message, user: chatUser, firstMessage = false } = chatData;
    
    // Format date for context
    const formattedDate = new Date().toLocaleString();
    
    // Check for conditions that lead to ignoring the message
    const fromBot = await containsAuxBotName(chatUser, userId);
    if (fromBot) {
      logger.log("Chat", `Ignoring message from bot: ${chatUser}`);
      return { success: true, ignored: true, reason: "bot_user" };
    }
    
    const isCommand = await isCommandMatch(message, userId);
    if (isCommand) {
      logger.log("Chat", `Ignoring command message: ${message}`);
      return { success: true, ignored: true, reason: "command" };
    }
    
    // Check if message mentions the character
    const mentionsChar = await containsCharacterName(message, userId);
    
    // Process the message based on conditions
    if (mentionsChar) {
      // Regular mention - process through chat system
      logger.log("Chat", `Processing mention from ${chatUser}: ${message}`);
      
      // Create message data for AI processing
      const messageData = { message, user: chatUser };
      
      // Get AI response
      const aiResponse = await respondToChat(messageData, userId);
      
      if (!aiResponse.success) {
        logger.error("Chat", `Error getting AI response: ${aiResponse.error}`);
        return { 
          success: false, 
          error: aiResponse.error || "Failed to generate response" 
        };
      }
      
      // Create summary for vector storage
      const summaryString = `On ${formattedDate} ${chatUser} said in ${user.user_name || user.twitch_name}'s Twitch chat: "${message}". You responded by saying: ${aiResponse.text}`;
      
      // Store in vector memory (don't await to avoid blocking)
      addChatMessageAsVector(
        summaryString,
        message,
        chatUser,
        formattedDate,
        aiResponse.text,
        userId
      ).catch(err => logger.error("Chat", `Error storing chat vector: ${err.message}`));
      
      // Send to Twitch chat if autoRespond is enabled
      let chatResponse = null;
      if (autoRespond && user.twitch_tokens?.bot?.access_token) {
        chatResponse = await sendChatMessage(aiResponse.text, userId);
      }
      
      return {
        success: true,
        processed: true,
        response: aiResponse.text,
        thoughtProcess: aiResponse.thoughtProcess,
        chatResponse,
        summaryString
      };
    } else if (firstMessage) {
      // First-time chatter - handle as an event
      logger.log("Chat", `Processing first-time chatter event from ${chatUser}`);
      
      // Create event data object
      const eventData = {
        eventType: 'chat',
        user: chatUser,
        message: message,
        firstMessage: true
      };
      
      // Process through event system
      const eventResponse = await respondToEvent(eventData, userId);
      
      if (!eventResponse || !eventResponse.response) {
        logger.error("Chat", `Error getting event response for first-time chatter`);
        return { 
          success: false, 
          error: "Failed to generate first-time chatter response" 
        };
      }
      
      // Create summary for vector storage
      const summaryString = `On ${formattedDate} ${chatUser} sent their first message in ${user.user_name || user.twitch_name}'s Twitch chat: "${message}". You responded by saying: ${eventResponse.response}`;
      
      // Store in vector memory
      addChatMessageAsVector(
        summaryString,
        message,
        chatUser,
        formattedDate,
        eventResponse.response,
        userId
      ).catch(err => logger.error("Chat", `Error storing first-time chat vector: ${err.message}`));
      
      // Send to Twitch chat if autoRespond is enabled
      let chatResponse = null;
      if (autoRespond && user.twitch_tokens?.bot?.access_token) {
        chatResponse = await sendChatMessage(eventResponse.response, userId);
      }
      
      return {
        success: true,
        processed: true,
        firstTimeChatter: true,
        response: eventResponse.response,
        thoughtProcess: eventResponse.thoughtProcess,
        chatResponse,
        summaryString
      };
    } else {
      // Regular message - just store for context
      const summaryString = `On ${formattedDate} ${chatUser} said in ${user.user_name || user.twitch_name}'s Twitch chat: "${message}"`;
      
      // Store in vector memory if enabled in user settings
      if (user.store_all_chat) {
        addChatMessageAsVector(
          summaryString,
          message,
          chatUser,
          formattedDate,
          "", // No response
          userId
        ).catch(err => logger.error("Chat", `Error storing regular chat: ${err.message}`));
      }
      
      return {
        success: true,
        processed: false,
        requiresResponse: false,
        summaryString
      };
    }
  } catch (error) {
    logger.error("Chat", `Error in chat handler: ${error.message}`);
    return { success: false, error: error.message };
  }
}

/**
 * Normalizes chat messages from various sources into a standard format
 * @param {object} messageData - Raw message from EventSub or API
 * @returns {object} - Standardized chat object
 */
export function normalizeMessageFormat(messageData) {
  // From EventSub webhook
  if (messageData.chatter && messageData.message && messageData.message.text) {
    return {
      user: messageData.chatter.user_name,
      userId: messageData.chatter.user_id,
      message: messageData.message.text,
      firstMessage: messageData.message.is_first || false,
      badges: messageData.chatter.badges?.map(badge => badge.set_id) || [],
      emotes: messageData.message.fragments
        ?.filter(f => f.type === 'emote')
        .map(e => ({ id: e.id, code: e.text })) || [],
      emoteCount: messageData.message.fragments?.filter(f => f.type === 'emote').length || 0,
      color: messageData.chatter.color,
      source: 'eventsub'
    };
  }
  
  // From API
  return {
    user: messageData.user,
    userId: messageData.userId || null,
    message: messageData.message,
    firstMessage: messageData.firstMessage || false,
    badges: messageData.badges || [],
    emotes: messageData.emotes || [],
    emoteCount: messageData.emoteCount || 0,
    color: messageData.color || null,
    source: 'api'
  };
}
</file>

<file path="error.txt">
{"code":"EADDRINUSE","errno":-98,"syscall":"listen","address":"::","port":3002}
</file>

<file path="response-monitor.js">
// response-monitor.js
import { logger } from './create-global-logger.js';
import fs from 'fs-extra';
import path from 'path';

// Simple in-memory stats
const responseStats = {
  totalRequests: 0,
  largeResponses: 0,  // Responses over 50KB
  hugeResponses: 0,   // Responses over 500KB
  emptyResponses: 0,  // Empty or failed responses
  lastReset: Date.now(),
  largeResponseTimestamps: [], // Track when large responses occurred
  responseSizes: []  // Store recent response sizes for analysis
};

// Keep only the most recent 100 response sizes
const MAX_HISTORY = 100;

/**
 * Records statistics about a response
 * @param {string} responseType - The type of response (e.g., 'chat', 'event', 'voice')
 * @param {any} responseBody - The response body
 * @param {string} userId - The user ID
 * @param {boolean} success - Whether the request was successful
 */
export function recordResponseStats(responseType, responseBody, userId, success = true) {
  responseStats.totalRequests++;
  
  // Handle empty or failed responses
  if (!success || !responseBody || responseBody.error) {
    responseStats.emptyResponses++;
    logger.log("Monitor", `Empty/failed ${responseType} response recorded for user ${userId}`);
    return;
  }
  
  // Calculate response size
  let responseSize = 0;
  if (typeof responseBody === 'string') {
    responseSize = responseBody.length;
  } else if (responseBody.response && typeof responseBody.response === 'string') {
    responseSize = responseBody.response.length;
  } else {
    responseSize = JSON.stringify(responseBody).length;
  }
  
  // Record the size
  responseStats.responseSizes.push({
    timestamp: Date.now(),
    size: responseSize,
    type: responseType,
    userId
  });
  
  // Trim history if needed
  if (responseStats.responseSizes.length > MAX_HISTORY) {
    responseStats.responseSizes.shift();
  }
  
  // Track large responses
  if (responseSize > 50000) { // 50KB
    responseStats.largeResponses++;
    responseStats.largeResponseTimestamps.push(Date.now());
    
    // Only keep the last 20 timestamps
    if (responseStats.largeResponseTimestamps.length > 20) {
      responseStats.largeResponseTimestamps.shift();
    }
    
    logger.log("Monitor", `Large ${responseType} response (${(responseSize/1024).toFixed(2)}KB) recorded for user ${userId}`);
    
    // Check for response burst (more than 5 large responses in 5 minutes)
    const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
    const recentLargeResponses = responseStats.largeResponseTimestamps.filter(
      timestamp => timestamp > fiveMinutesAgo
    );
    
    if (recentLargeResponses.length > 5) {
      logger.log("Monitor", `WARNING: Burst of large responses detected (${recentLargeResponses.length} in 5 minutes)`);
    }
  }
  
  // Track huge responses
  if (responseSize > 500000) { // 500KB
    responseStats.hugeResponses++;
    logger.log("Monitor", `ALERT: Huge ${responseType} response (${(responseSize/1024).toFixed(2)}KB) for user ${userId}`);
    
    // If you want to save examples of huge responses for analysis
    try {
      const logsDir = path.join(process.cwd(), 'logs', 'huge_responses');
      fs.ensureDirSync(logsDir);
      const filePath = path.join(logsDir, `huge_response_${Date.now()}_${responseType}_${userId}.json`);
      fs.writeJSONSync(filePath, {
        type: responseType,
        userId,
        timestamp: new Date().toISOString(),
        size: responseSize,
        sample: typeof responseBody === 'string' 
          ? responseBody.substring(0, 10000) 
          : JSON.stringify(responseBody).substring(0, 10000)
      }, { spaces: 2 });
    } catch (err) {
      logger.log("Monitor", `Error saving huge response sample: ${err.message}`);
    }
  }
}

/**
 * Gets current response statistics
 * @returns {Object} The current response statistics
 */
export function getResponseStats() {
  // Calculate some additional metrics
  const uptime = Math.floor((Date.now() - responseStats.lastReset) / 1000);
  
  // Calculate percentiles if we have data
  let p50 = 0, p95 = 0, p99 = 0;
  if (responseStats.responseSizes.length > 0) {
    // Sort by size
    const sortedSizes = [...responseStats.responseSizes]
      .map(item => item.size)
      .sort((a, b) => a - b);
    
    const getPercentile = (arr, p) => {
      const index = Math.floor(arr.length * p / 100);
      return arr[index];
    };
    
    p50 = getPercentile(sortedSizes, 50);
    p95 = getPercentile(sortedSizes, 95);
    p99 = getPercentile(sortedSizes, 99);
  }
  
  return {
    ...responseStats,
    uptime,
    emptyResponseRate: responseStats.totalRequests 
      ? (responseStats.emptyResponses / responseStats.totalRequests * 100).toFixed(2)
      : 0,
    largeResponseRate: responseStats.totalRequests 
      ? (responseStats.largeResponses / responseStats.totalRequests * 100).toFixed(2)
      : 0,
    responseSizePercentiles: {
      p50: (p50 / 1024).toFixed(2) + ' KB',
      p95: (p95 / 1024).toFixed(2) + ' KB',
      p99: (p99 / 1024).toFixed(2) + ' KB'
    }
  };
}

/**
 * Resets the response statistics
 */
export function resetResponseStats() {
  Object.assign(responseStats, {
    totalRequests: 0,
    largeResponses: 0,
    hugeResponses: 0,
    emptyResponses: 0,
    lastReset: Date.now(),
    largeResponseTimestamps: [],
    responseSizes: []
  });
  
  logger.log("Monitor", "Response statistics have been reset");
}

/**
 * Adds the response monitoring middleware to a Fastify instance
 * @param {FastifyInstance} fastify - The Fastify instance to add the middleware to
 */
export function addResponseMonitoring(fastify) {
  // Add response hook
  fastify.addHook('onResponse', (request, reply, done) => {
    try {
      // Get the route
      const route = request.routeOptions?.url || request.url;
      
      // Only monitor actual API endpoints
      if (route.includes('/v1/') && ['POST', 'PUT'].includes(request.method)) {
        const responseTime = reply.getResponseTime();
        const userId = reply.request.headers?.authorization 
          ? reply.request.headers.authorization.split(' ')[1]
          : 'unknown';
        
        // Record response code
        if (reply.statusCode >= 400) {
          recordResponseStats(
            route.split('/').pop(), 
            { error: `HTTP ${reply.statusCode}` }, 
            userId, 
            false
          );
        }
        
        // Log slow responses
        if (responseTime > 5000) {
          logger.log("Monitor", `Slow response detected: ${responseTime.toFixed(0)}ms for ${route}`);
        }
      }
    } catch (err) {
      // Don't let monitoring errors affect the application
      logger.log("Monitor", `Error in response monitoring: ${err.message}`);
    }
    
    done();
  });
  
  // Add status endpoint
  fastify.get('/admin/response-stats', async (request, reply) => {
    // Optional basic auth for this endpoint
    const auth = request.headers.authorization;
    const validAuth = 'Basic ' + Buffer.from('admin:admin123').toString('base64');
    
    if (auth !== validAuth) {
      reply.status(401).send({ error: 'Unauthorized' });
      return;
    }
    
    reply.send(getResponseStats());
  });
  
  // Add reset endpoint
  fastify.post('/admin/response-stats/reset', async (request, reply) => {
    // Optional basic auth for this endpoint
    const auth = request.headers.authorization;
    const validAuth = 'Basic ' + Buffer.from('admin:admin123').toString('base64');
    
    if (auth !== validAuth) {
      reply.status(401).send({ error: 'Unauthorized' });
      return;
    }
    
    resetResponseStats();
    reply.send({ success: true, message: 'Response statistics have been reset' });
  });
  
  // Log initial setup
  logger.log("Monitor", "Response monitoring has been enabled");
}
</file>

<file path="twitch-webhook-tester.js">
// twitch-webhook-tester.js
import axios from 'axios';
import crypto from 'crypto';
import { retrieveConfigValue } from './config-helper.js';
import { returnAuthObject } from './api-helper.js';
import { logger } from './create-global-logger.js';

/**
 * Utility to test Twitch EventSub webhooks by sending mock notifications
 * to your local webhook endpoint
 */
class TwitchWebhookTester {
  constructor() {
    this.messageId = crypto.randomUUID();
    this.timestamp = new Date().toISOString();
  }

  /**
   * Initialize the tester with user-specific data
   * @param {string} userId - The user ID to test with
   * @returns {Promise<boolean>} - Whether initialization succeeded
   */
  async initialize(userId) {
    try {
      // Get the user's data
      this.user = await returnAuthObject(userId);
      if (!this.user) {
        logger.error("Twitch Tester", `User ${userId} not found`);
        return false;
      }

      // Check if user has Twitch integration
      if (!this.user.twitch_tokens?.streamer?.twitch_user_id) {
        logger.error("Twitch Tester", `User ${userId} has no Twitch ID configured`);
        return false;
      }

      // Get webhook secret
      this.webhookSecret = this.user.twitch_tokens.streamer.webhook_secret;
      if (!this.webhookSecret) {
        logger.error("Twitch Tester", `No webhook secret found for user ${userId}`);
        return false;
      }

      // Get the local webhook URL
      const serverEndpoint = await retrieveConfigValue("server.endpoints.internal");
      const serverPort = await retrieveConfigValue("server.port");
      this.webhookUrl = `http://${serverEndpoint}:${serverPort}/api/v1/twitch/eventsub/${userId}`;

      this.twitchUserId = this.user.twitch_tokens.streamer.twitch_user_id;
      this.twitchUserName = this.user.twitch_tokens.streamer.twitch_display_name || this.user.twitch_name;
      
      logger.log("Twitch Tester", `Initialized for user ${userId} (${this.twitchUserName})`);
      return true;
    } catch (error) {
      logger.error("Twitch Tester", `Initialization error: ${error.message}`);
      return false;
    }
  }

  /**
   * Sign a message with the webhook secret using HMAC SHA-256
   * @param {string} messageId - The message ID
   * @param {string} timestamp - The timestamp
   * @param {string} payload - The JSON payload as a string
   * @returns {string} - The signature
   */
  signMessage(messageId, timestamp, payload) {
    const hmacMessage = messageId + timestamp + payload;
    const signature = crypto.createHmac('sha256', this.webhookSecret)
      .update(hmacMessage)
      .digest('hex');
    return `sha256=${signature}`;
  }

  /**
   * Send a test notification to the webhook endpoint
   * @param {object} payload - The notification payload
   * @param {string} type - The notification type
   * @returns {Promise<object>} - The response
   */
  async sendNotification(payload, type = 'notification') {
    try {
      // Convert payload to string
      const stringPayload = JSON.stringify(payload);
      
      // Sign the message
      const signature = this.signMessage(this.messageId, this.timestamp, stringPayload);
      
      // Set up headers like Twitch would
      const headers = {
        'Content-Type': 'application/json',
        'Twitch-Eventsub-Message-Id': this.messageId,
        'Twitch-Eventsub-Message-Timestamp': this.timestamp,
        'Twitch-Eventsub-Message-Signature': signature,
        'Twitch-Eventsub-Message-Type': type,
        'Twitch-Eventsub-Subscription-Version': '1'
      };
      
      logger.log("Twitch Tester", `Sending ${payload.subscription.type} test notification to ${this.webhookUrl}`);
      
      // Send the request
      const response = await axios.post(this.webhookUrl, payload, { headers });
      
      return {
        success: true,
        status: response.status,
        statusText: response.statusText,
        data: response.data,
        messageSent: payload
      };
    } catch (error) {
      logger.error("Twitch Tester", `Error sending notification: ${error.message}`);
      return {
        success: false,
        error: error.message,
        status: error.response?.status,
        statusText: error.response?.statusText,
        data: error.response?.data,
        messageSent: payload
      };
    }
  }

  /**
   * Test a follow event
   * @param {object} options - Additional options
   * @returns {Promise<object>} - The response
   */
  async testFollow(options = {}) {
    const followerName = options.followerName || 'TestFollower';
    const followerId = options.followerId || '987654321';
    
    const payload = {
      subscription: {
        id: crypto.randomUUID(),
        type: 'channel.follow',
        version: '2',
        status: 'enabled',
        cost: 1,
        condition: {
          broadcaster_user_id: this.twitchUserId,
          moderator_user_id: this.twitchUserId
        },
        transport: {
          method: 'webhook',
          callback: 'https://example.com/webhook'
        },
        created_at: new Date().toISOString()
      },
      event: {
        user_id: followerId,
        user_name: followerName,
        user_login: followerName.toLowerCase(),
        broadcaster_user_id: this.twitchUserId,
        broadcaster_user_name: this.twitchUserName,
        broadcaster_user_login: this.twitchUserName.toLowerCase(),
        followed_at: new Date().toISOString()
      }
    };
    
    return this.sendNotification(payload);
  }

  /**
   * Test a chat message event
   * @param {object} options - Additional options
   * @returns {Promise<object>} - The response
   */
  async testChatMessage(options = {}) {
    const chatterName = options.chatterName || 'TestChatter';
    const chatterId = options.chatterId || '123456789';
    const message = options.message || `Hello @${this.twitchUserName}, this is a test message!`;
    const isFirstMessage = options.isFirstMessage || false;
    
    const payload = {
      subscription: {
        id: crypto.randomUUID(),
        type: 'channel.chat.message',
        version: '1',
        status: 'enabled',
        cost: 1,
        condition: {
          broadcaster_user_id: this.twitchUserId,
          user_id: chatterId
        },
        transport: {
          method: 'webhook',
          callback: 'https://example.com/webhook'
        },
        created_at: new Date().toISOString()
      },
      event: {
        broadcaster_user_id: this.twitchUserId,
        broadcaster_user_login: this.twitchUserName.toLowerCase(),
        broadcaster_user_name: this.twitchUserName,
        chatter: {
          user_id: chatterId,
          user_login: chatterName.toLowerCase(),
          user_name: chatterName,
          color: "#FF0000",
          badges: []
        },
        message: {
          text: message,
          fragments: [
            {
              type: "text",
              text: message,
              cheermote: null
            }
          ],
          is_first: isFirstMessage
        },
        sent_at: new Date().toISOString()
      }
    };
    
    return this.sendNotification(payload);
  }

  /**
   * Test a subscription event
   * @param {object} options - Additional options
   * @returns {Promise<object>} - The response
   */
  async testSubscription(options = {}) {
    const subscriberName = options.subscriberName || 'TestSubscriber';
    const subscriberId = options.subscriberId || '123456789';
    const tier = options.tier || '1000';
    const isGift = options.isGift || false;
    
    const payload = {
      subscription: {
        id: crypto.randomUUID(),
        type: 'channel.subscribe',
        version: '1',
        status: 'enabled',
        cost: 1,
        condition: {
          broadcaster_user_id: this.twitchUserId
        },
        transport: {
          method: 'webhook',
          callback: 'https://example.com/webhook'
        },
        created_at: new Date().toISOString()
      },
      event: {
        user_id: subscriberId,
        user_login: subscriberName.toLowerCase(),
        user_name: subscriberName,
        broadcaster_user_id: this.twitchUserId,
        broadcaster_user_login: this.twitchUserName.toLowerCase(),
        broadcaster_user_name: this.twitchUserName,
        tier: tier,
        is_gift: isGift
      }
    };
    
    return this.sendNotification(payload);
  }

  /**
   * Test a stream online event
   * @param {object} options - Additional options
   * @returns {Promise<object>} - The response
   */
  async testStreamOnline(options = {}) {
    const streamType = options.streamType || 'live';
    
    const payload = {
      subscription: {
        id: crypto.randomUUID(),
        type: 'stream.online',
        version: '1',
        status: 'enabled',
        cost: 1,
        condition: {
          broadcaster_user_id: this.twitchUserId
        },
        transport: {
          method: 'webhook',
          callback: 'https://example.com/webhook'
        },
        created_at: new Date().toISOString()
      },
      event: {
        id: crypto.randomUUID(),
        broadcaster_user_id: this.twitchUserId,
        broadcaster_user_login: this.twitchUserName.toLowerCase(),
        broadcaster_user_name: this.twitchUserName,
        type: streamType,
        started_at: new Date().toISOString()
      }
    };
    
    return this.sendNotification(payload);
  }

  /**
   * Test a channel update event
   * @param {object} options - Additional options
   * @returns {Promise<object>} - The response
   */
  async testChannelUpdate(options = {}) {
    const title = options.title || 'Test Stream Title';
    const categoryName = options.categoryName || 'Just Chatting';
    const categoryId = options.categoryId || '509658';
    
    const payload = {
      subscription: {
        id: crypto.randomUUID(),
        type: 'channel.update',
        version: '1',
        status: 'enabled',
        cost: 1,
        condition: {
          broadcaster_user_id: this.twitchUserId
        },
        transport: {
          method: 'webhook',
          callback: 'https://example.com/webhook'
        },
        created_at: new Date().toISOString()
      },
      event: {
        broadcaster_user_id: this.twitchUserId,
        broadcaster_user_login: this.twitchUserName.toLowerCase(),
        broadcaster_user_name: this.twitchUserName,
        title: title,
        language: 'en',
        category_id: categoryId,
        category_name: categoryName,
        is_mature: false
      }
    };
    
    return this.sendNotification(payload);
  }

  /**
   * Test a raid event
   * @param {object} options - Additional options
   * @returns {Promise<object>} - The response
   */
  async testRaid(options = {}) {
    const raiderName = options.raiderName || 'TestRaider';
    const raiderId = options.raiderId || '987654321';
    const viewers = options.viewers || 42;
    
    const payload = {
      subscription: {
        id: crypto.randomUUID(),
        type: 'channel.raid',
        version: '1',
        status: 'enabled',
        cost: 1,
        condition: {
          to_broadcaster_user_id: this.twitchUserId
        },
        transport: {
          method: 'webhook',
          callback: 'https://example.com/webhook'
        },
        created_at: new Date().toISOString()
      },
      event: {
        from_broadcaster_user_id: raiderId,
        from_broadcaster_user_login: raiderName.toLowerCase(),
        from_broadcaster_user_name: raiderName,
        to_broadcaster_user_id: this.twitchUserId,
        to_broadcaster_user_login: this.twitchUserName.toLowerCase(),
        to_broadcaster_user_name: this.twitchUserName,
        viewers: viewers
      }
    };
    
    return this.sendNotification(payload);
  }
}

/**
 * Command-line interface to test Twitch webhooks
 */
async function runCLI() {
  // Parse command line arguments
  const args = process.argv.slice(2);
  
  // Show help if no args or help requested
  if (args.length === 0 || args.includes('--help') || args.includes('-h')) {
    console.log(`
Twitch EventSub Webhook Tester
==============================

Usage: node twitch-webhook-tester.js <command> <userId> [options]

Commands:
  follow        Test a channel.follow event
  chat          Test a channel.chat.message event
  sub           Test a channel.subscribe event
  online        Test a stream.online event
  update        Test a channel.update event
  raid          Test a channel.raid event

Options:
  --help, -h    Show this help message
  --firstmsg    For chat messages, mark as first message from user
  --message     Custom message for chat events
  --name        Custom name for the event source (follower, subscriber, etc.)
  --viewers     Number of viewers for raid events
  --title       Stream title for channel update events
  --game        Game/category name for channel update events

Example:
  node twitch-webhook-tester.js chat my_user_id --message "Hello @streamer!" --name "TestUser"
  node twitch-webhook-tester.js follow my_user_id --name "NewFollower123"
  node twitch-webhook-tester.js raid my_user_id --name "RaidingChannel" --viewers 100
    `);
    return;
  }

  // Extract command and userId
  const [command, userId] = args;
  
  // Parse options
  const options = {};
  for (let i = 2; i < args.length; i += 2) {
    if (args[i].startsWith('--')) {
      const key = args[i].substring(2);
      const value = args[i + 1];
      
      // Handle boolean flags (no value)
      if (!value || value.startsWith('--')) {
        options[key] = true;
        i -= 1; // Adjust index since we didn't consume a value
      } else {
        options[key] = value;
      }
    }
  }
  
  // Map some options to expected property names
  if (options.name) {
    if (command === 'follow') options.followerName = options.name;
    if (command === 'chat') options.chatterName = options.name;
    if (command === 'sub') options.subscriberName = options.name;
    if (command === 'raid') options.raiderName = options.name;
  }
  
  if (options.game) options.categoryName = options.game;
  if (options.firstmsg) options.isFirstMessage = true;
  
  // Initialize tester
  const tester = new TwitchWebhookTester();
  const initSuccess = await tester.initialize(userId);
  
  if (!initSuccess) {
    console.log('Failed to initialize webhook tester. Check logs for details.');
    return;
  }
  
  // Execute the specified command
  let result;
  switch (command) {
    case 'follow':
      result = await tester.testFollow(options);
      break;
    case 'chat':
      result = await tester.testChatMessage(options);
      break;
    case 'sub':
      result = await tester.testSubscription(options);
      break;
    case 'online':
      result = await tester.testStreamOnline(options);
      break;
    case 'update':
      result = await tester.testChannelUpdate(options);
      break;
    case 'raid':
      result = await tester.testRaid(options);
      break;
    default:
      console.log(`Unknown command: ${command}`);
      return;
  }
  
  if (result.success) {
    console.log(`✅ Successfully sent ${command} test event`);
    console.log(`Status: ${result.status} ${result.statusText}`);
  } else {
    console.log(`❌ Failed to send ${command} test event`);
    console.log(`Error: ${result.error}`);
    if (result.status) {
      console.log(`Status: ${result.status} ${result.statusText}`);
    }
  }
}

// If this file is run directly, execute the CLI
if (import.meta.url === import.meta.resolve('./twitch-webhook-tester.js')) {
  runCLI();
}

export default TwitchWebhookTester;
</file>

<file path="routes/audio.js">
// routes/audio.js
import path from 'path';
import fastifyStatic from '@fastify/static';
import fs from 'fs/promises';

export async function audioRoutes(fastify, options = {}) {
  const {
    outputDir = 'final',
    addContentDisposition = false
  } = options;

  // Resolve the absolute path to the output directory
  const audioFilesPath = path.resolve(process.cwd(), outputDir);
  
  console.log('Audio files directory:', audioFilesPath);
  
  // Simple test route to verify the plugin is working
  fastify.get('/test', async () => {
    return { status: 'Audio routes working' };
  });
  
  // Direct file serving
  fastify.get('/:filename', async (request, reply) => {
    const { filename } = request.params;
    
    // Prevent path traversal
    if (filename.includes('..') || filename.includes('/') || filename.includes('\\')) {
      return reply.code(400).send({ error: 'Invalid filename' });
    }
    
    const filePath = path.join(audioFilesPath, filename);
    
    try {
      // Verify file exists
      await fs.access(filePath);
      
      // Set headers manually
      reply.header('Content-Type', 'audio/wav');
      
      if (addContentDisposition) {
        reply.header('Content-Disposition', `attachment; filename="${filename}"`);
      }
      
      // Read and send file directly
      const fileContent = await fs.readFile(filePath);
      return reply.send(fileContent);
    } catch (error) {
      console.error('Error serving file:', error);
      return reply.code(error.code === 'ENOENT' ? 404 : 500)
        .send({ error: error.code === 'ENOENT' ? 'File not found' : 'Error serving file' });
    }
  });
  
  // Register static file plugin as a separate handler
  await fastify.register(fastifyStatic, {
    root: audioFilesPath,
    prefix: '/static',
    decorateReply: false,
    setHeaders: (res) => {
      res.setHeader('Content-Type', 'audio/wav');
      if (addContentDisposition) {
        const filePath = req.url;
        const fileName = path.basename(filePath);
        res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
      }
    }
  });
  
  // Add a delete route
  fastify.delete('/:filename', async (request, reply) => {
    const { filename } = request.params;
    
    // Prevent path traversal
    if (filename.includes('..') || filename.includes('/') || filename.includes('\\')) {
      return reply.code(400).send({ error: 'Invalid filename' });
    }
    
    const filePath = path.join(audioFilesPath, filename);
    
    try {
      await fs.unlink(filePath);
      return { success: true, message: `File ${filename} deleted` };
    } catch (error) {
      if (error.code === 'ENOENT') {
        return reply.code(404).send({ error: 'File not found' });
      }
      return reply.code(500).send({ error: 'Failed to delete file' });
    }
  });
}
</file>

<file path="views/character-details.njk">
{% extends "layout.njk" %}

{% block title %}{{ character.name }}{% endblock %}

{% block content %}
<div class="card character-header">
  <div class="character-avatar-large">
    <img src="{{ character.image }}" alt="{{ character.name }} Avatar" class="fade-in-image">
  </div>
  <div class="character-meta">
    <h1>{{ character.name }}</h1>
    <p class="author">by: {{ character.author }}</p>
    <p class="summary">{{ character.summary }}</p>
    <form action="/api/v1/gallery/{{ character.id }}/use" method="POST" data-async>
      <button type="submit" class="btn btn-primary btn-use-char">Use This Character</button>
    </form>
  </div>
</div>

<div class="card">
  <h2>Personality</h2>
  <div class="character-content-public">
    {% if character.personality.publicFmt %}
      {{ character.personality.publicFmt }}
    {% else %}
      <pre class="character-content">{{ character.personality }}</pre>
    {% endif %}
  </div>
</div>

<div class="card">
  <h2>Description</h2>
  <div class="character-content-public">
    {% if character.char_description.publicFmt %}
      {{ character.char_description.publicFmt }}
    {% else %}
      <pre class="character-content">{{ character.char_description }}</pre>
    {% endif %}
  </div>
</div>
{% endblock %}

{% block extraStyles %}
<style>
  .character-header {
    display: flex;
    gap: 30px;
    align-items: flex-start; /* Align items to the top */
  }

  .character-avatar-large {
    flex-shrink: 0;
    width: 200px;
    height: 200px;
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid var(--border);
    background-color: var(--background);
  }

  .character-avatar-large img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: top center; /* Align to top */
    display: block;
    opacity: 0; /* Start invisible */
    transition: opacity 0.5s ease-in-out;
  }
  
  .character-avatar-large img.loaded {
    opacity: 1; /* Fade in when loaded */
  }

  .character-meta {
    flex-grow: 1;
  }

  .character-meta h1 {
    margin-top: 0;
    margin-bottom: 5px;
  }

  .character-meta .author {
    color: var(--secondary-text);
    font-style: italic;
    margin-bottom: 15px;
  }

  .character-meta .summary {
    color: var(--primary-text);
    margin-bottom: 20px;
    font-size: 1.05em;
  }

  .character-content {
    background-color: var(--input-bg);
    padding: 15px;
    border-radius: 6px;
    white-space: pre-wrap; /* Allows wrapping */
    word-wrap: break-word; /* Ensures long words break */
    font-family: monospace;
    border: 1px solid var(--border);
  }
  
  .character-content-public {
    background-color: var(--input-bg);
    padding: 15px;
    border-radius: 6px;
    border: 1px solid var(--border);
    line-height: 1.5;
  }

  .btn-use-char {
    margin-top: 10px; /* Add some space above the button */
  }

  @media (max-width: 600px) {
    .character-header {
      flex-direction: column;
      align-items: center;
      text-align: center;
    }

    .character-avatar-large {
      width: 150px;
      height: 150px;
      margin-bottom: 15px;
    }
  }
</style>
{% endblock %}

{% block extraScripts %}
<script>
  // Add fade-in functionality for images
  document.addEventListener('DOMContentLoaded', () => {
    const images = document.querySelectorAll('.fade-in-image');
    
    images.forEach(img => {
      // For images that are already loaded from cache
      if (img.complete) {
        img.classList.add('loaded');
      } else {
        // For images that need to be loaded
        img.addEventListener('load', () => {
          img.classList.add('loaded');
        });
        
        // Fallback in case image fails to load
        img.addEventListener('error', () => {
          img.classList.add('loaded');
        });
      }
    });
  });
</script>
{% endblock %}
</file>

<file path="views/gallery.njk">
{% extends "layout.njk" %}

{% block title %}Character Gallery{% endblock %}

{% block content %}
<div class="card">
  <div class="card-header">
    <h1>Character Gallery</h1>
  </div>
  <p>Choose a pre-defined character preset for your AI assistant. Click on a character to see more details and apply the preset.</p>
</div>

{% if presets %}
<div class="gallery-grid">
  {% for preset in presets %}
  <a href="/web/gallery/{{ preset.id }}" class="card preset-card">
    <div class="preset-image">
      <img src="{{ preset.image }}" alt="{{ preset.name }} Avatar" loading="lazy" class="fade-in-image">
    </div>
    <div class="preset-info">
      <h3 class="preset-name">{{ preset.name }}</h3>
      <p class="preset-author">by: {{ preset.author }}</p>
    </div>
  </a>
  {% endfor %}
</div>
{% else %}
<div class="card">
  <p>No character presets found. Please check the 'presets' directory.</p>
</div>
{% endif %}
{% endblock %}

{% block extraStyles %}
<style>
  .gallery-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
    gap: 20px;
    margin-top: 20px;
  }

  .preset-card {
    text-decoration: none;
    color: var(--primary-text);
    transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    display: flex;
    flex-direction: column;
    overflow: hidden; /* Ensure image corners are rounded */
    padding: 0; /* Remove default card padding */
  }

  .preset-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
    text-decoration: none;
    color: var(--accent-hover);
  }

  .preset-image {
    width: 100%;
    aspect-ratio: 1 / 1; /* Square aspect ratio for images */
    background-color: var(--background); /* Fallback color */
    overflow: hidden;
    position: relative;
  }

  .preset-image img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: top center; /* Align to top */
    display: block;
    border-bottom: 1px solid var(--border);
    opacity: 0; /* Start with invisible image */
    transition: opacity 0.4s ease-in-out;
  }

  .preset-image img.loaded {
    opacity: 1; /* Fade in when loaded class is added */
  }

  .preset-info {
    padding: 15px;
    text-align: center;
  }

  .preset-name {
    margin: 0 0 5px 0;
    font-size: 1.1em;
  }

  .preset-author {
    font-size: 0.9em;
    color: var(--secondary-text);
    margin: 0;
  }
</style>
{% endblock %}

{% block extraScripts %}
<script>
  // Add onload event handlers to all fade-in images
  document.addEventListener('DOMContentLoaded', () => {
    const images = document.querySelectorAll('.fade-in-image');
    
    images.forEach(img => {
      // For images that are already loaded from cache
      if (img.complete) {
        img.classList.add('loaded');
      } else {
        // For images that need to be loaded
        img.addEventListener('load', () => {
          img.classList.add('loaded');
        });
        
        // Fallback in case image fails to load
        img.addEventListener('error', () => {
          img.classList.add('loaded');
          // Optionally set a placeholder or error image
          // img.src = '/api/placeholder/200/200';
        });
      }
    });
  });
</script>
{% endblock %}
</file>

<file path="restart-helper.js">
// restart-helper.js
// This script is used to restart the main application
// It's executed as a detached child process when the restart command is issued

import { spawn } from 'child_process';
import { setTimeout } from 'timers/promises';

// Wait for the parent process to exit
await setTimeout(1000);

// Start the application again
const app = spawn('node', ['main.js'], {
  detached: true,
  stdio: 'inherit'
});

// Detach from the child process so it can run independently
app.unref();

// Exit this helper
process.exit(0);
</file>

<file path="start.bat">
@echo off
node main.js
</file>

<file path="template-engine.js">
// template-engine.js
import path from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import fs from 'fs-extra';
import { logger } from './create-global-logger.js';
import nunjucks from 'nunjucks';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export async function setupTemplating(fastify) {
  // Ensure templates directory exists
  const templatesDir = path.join(process.cwd(), 'views');
  await fs.ensureDir(templatesDir);
  
  // Move templates from pages to views if needed
  const pagesDir = path.join(process.cwd(), 'pages');
  if (await fs.pathExists(pagesDir)) {
    const pageFiles = await fs.readdir(pagesDir);
    for (const file of pageFiles) {
      const sourcePath = path.join(pagesDir, file);
      const destPath = path.join(templatesDir, file);
      
      // Skip if destination already exists
      if (!(await fs.pathExists(destPath))) {
        await fs.copy(sourcePath, destPath);
        logger.log("Templates", `Copied template: ${file}`);
      }
    }
  }
  
  // Create Nunjucks environment directly
  const njkEnv = nunjucks.configure(templatesDir, {
    autoescape: true,
    throwOnUndefined: false,
    trimBlocks: true,
    lstripBlocks: true
  });
  
  // Add template helpers/filters
  njkEnv.addFilter('json', (obj) => JSON.stringify(obj, null, 2));
  njkEnv.addFilter('dateFormat', async (date, format = 'MMMM Do YYYY, h:mm a') => {
    if (!date) return '';
    const moment = (await import('moment')).default;
    return moment(date).format(format);
  });
  njkEnv.addFilter('startsWithMarkdown', (text) => {
    if (!text) return false;
    const trimmedText = text.trim();
    // Check for common markdown patterns
    return /^(#|\*|\-|\d+\.|>|\[|\`|\!\[)/.test(trimmedText);
  });
  
  // Basic markdown renderer for simple cases
  njkEnv.addFilter('renderMarkdown', (text) => {
    if (!text) return '';
    
    let html = text;
    
    // Headers
    html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>');
    html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>');
    html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>');
    
    // Lists
    html = html.replace(/^\- (.*$)/gm, '<li>$1</li>');
    html = html.replace(/^(\d+)\. (.*$)/gm, '<li>$2</li>');
    
    // Wrap list items in ul/ol
    html = html.replace(/(<li>.*<\/li>)\s+(?!<li>)/gs, '<ul>$1</ul>');
    
    // Bold and italics
    html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
    
    // Paragraphs (non-list, non-header text)
    html = html.replace(/^(?!<h|<ul|<li|<ol)(.*$)/gm, '<p>$1</p>');
    
    return html;
  });
  
  // Add direct view rendering to Fastify
  fastify.decorate('renderView', (template, data = {}) => {
    return njkEnv.render(template, { 
      ...data, 
      appName: 'Enspira',
      year: new Date().getFullYear()
    });
  });
  
  // Add direct view rendering to reply object
  fastify.decorateReply('view', function(template, data = {}) {
    const html = njkEnv.render(template, { 
      ...data, 
      appName: 'Enspira',
      year: new Date().getFullYear()
    });
    return this.type('text/html').send(html);
  });
  
  logger.log("System", "Template engine configured successfully");
  return fastify;
}
</file>

<file path="views/dashboard.njk">
{% extends "layout.njk" %}
{% block title %}
  Dashboard
{% endblock title %}
{% block content %}
  <!-- Welcome Card -->
  <div class="card">
    <div class="card-header">
      <h1>Welcome to Enspira, {{ user.display_name }}</h1>
    </div>
    <p>Manage your Enspira Co-Star for your Twitch channel.</p>
    <!-- AI Assistant Settings -->
    <div class="two-column">
      <div class="card">
        <h2>Character Settings</h2>
        <p>Customize your AI assistant's personality, appearance, and behavior.</p>
        <a href="/web/character" class="btn btn-primary">Edit Character</a>
      </div>
      <div class="card">
        <h2>World Settings</h2>
        <p>Set up the environment and context for your AI assistant.</p>
        <a href="/web/world" class="btn btn-primary">Edit World</a>
      </div>
    </div>
  </div>
  <!-- Stream Status Card -->
  <div class="card stream-card">
    <div class="stream-status-indicator {% if streamStatus.online %}online{% else %}offline{% endif %}">
      <span class="status-indicator"></span>
      <span>{% if streamStatus.online %}Live{% else %}Offline{% endif %}</span>
    </div>
    
    <h2>Stream Status</h2>
    
    {% if streamStatus.online %}
      <div class="stream-content">
        {% if streamStatus.thumbnail %}
          <div class="stream-thumbnail">
            <img src="{{ streamStatus.thumbnail }}" alt="Stream Thumbnail" class="fade-in-image">
          </div>
        {% endif %}
        <div class="stream-details">
          <h3 class="stream-title">{{ streamStatus.title }}</h3>
          <div class="stream-game">
            <span>Playing:</span> {{ streamStatus.game }}
          </div>
          <div class="stream-time">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="10"></circle>
              <polyline points="12 6 12 12 16 14"></polyline>
            </svg>
            <span>{{ streamStatus.duration }}</span>
          </div>
          <div class="stream-metrics">
            <div class="metric">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                <circle cx="9" cy="7" r="4"></circle>
                <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
              </svg>
              <span>{{ streamStatus.viewers }} viewers</span>
            </div>
            <div class="metric">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
              </svg>
              <span>{{ followerCount }} followers</span>
            </div>
          </div>
        </div>
      </div>
    {% else %}
      <div class="stream-info offline">
        <div class="offline-details">
          <div class="metric">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
            </svg>
            <span>{{ followerCount }} followers</span>
          </div>
          {% if lastGame and lastGame != 'None' %}
            <div class="last-game">
              <span>Last played:</span> {{ lastGame }}
            </div>
            {% if user.current_game.thumbnail_url %}
              <div class="offline-thumbnail">
                <img src="{{ user.current_game.thumbnail_url }}" alt="Last Stream Thumbnail" class="fade-in-image">
              </div>
            {% endif %}
          {% endif %}
        </div>
      </div>
    {% endif %}
  </div>
  <!-- Twitch Integration Card -->
  <div class="card">
    <h2>Twitch Integration</h2>
    <p>Connect your Twitch streamer and bot accounts.</p>
    <div class="two-column">
      <div>
        <h3>Streamer Account</h3>
        {% if streamerConnected %}
          <p class="alert alert-success">Connected as: {{ streamerName }}</p>
        {% else %}
          <p class="alert alert-error">Not connected</p>
        {% endif %}
        <!-- Direct link to connect streamer account -->
        <a href="/api/v1/auth/twitch/connect?type=streamer" class="btn btn-secondary">
          {% if streamerConnected %}
            Reconnect Streamer Account
          {% else %}
            Connect Streamer Account
          {% endif %}
        </a>
      </div>
      <div>
        <h3>Bot Account</h3>
        {% if botConnected %}
          <p class="alert alert-success">Connected as: {{ botName }}</p>
        {% else %}
          <p class="alert alert-error">Not connected</p>
        {% endif %}
        <!-- Direct link to connect bot account -->
        <a href="/api/v1/auth/twitch/connect?type=bot" class="btn btn-secondary">
          {% if botConnected %}
            Reconnect Bot Account
          {% else %}
            Connect Bot Account
          {% endif %}
        </a>
      </div>
    </div>
  </div>
  <!-- Quick Stats Card -->
  <div class="card">
    <h2>Quick Stats</h2>
    <div class="two-column">
      <div>
        <h3>Chat Messages</h3>
        <p>{{ stats.chatMessages }} messages processed</p>
      </div>
    </div>
  </div>
  <!-- Help Card -->
  <div class="card">
    <div class="card-header">
      <h1>Resources, Tips and Tricks</h1>
    </div>
    <p>Find more help to enhance your AI co-star's character here.</p>
    <!-- AI Assistant Settings -->
    <div class="four-column">
      <div class="card">
        <h2>Want to read up?</h2>
        <p>Check out our source code over at Github!</p>
        <a href="https://github.com/prolix-oc/Refyne" class="btn btn-primary">GitHub</a>
      </div>
      <div class="card">
        <h2>Want more ideas?</h2>
        <p>Join the Discord community for tips.</p>
        <a href="https://discord.com/invite/pMnZ7DaUK3" class="btn btn-primary">Join Up</a>
      </div>
      <div class="card">
        <h2>Visual learner?</h2>
        <p>Drop by my YouTube for videos soon!</p>
        <a href="https://youtube.com/@prolix_gg" class="btn btn-primary">Tune In</a>
      </div>
      <div class="card">
        <h2>Still Confused?</h2>
        <p>Check out our dedicated help section.</p>
        <a href="/web/help" class="btn btn-primary">Get Help</a>
      </div>
    </div>
  </div>
  
{% endblock content %}
{% block extraStyles %}
  <style>
  .stream-card {
    position: relative;
    padding-top: 30px;
  }

  .stream-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
  }

  .stream-status-indicator {
    position: absolute;
    top: 15px;
    right: 15px;
    display: flex;
    align-items: center;
    font-weight: bold;
    padding: 5px 10px;
    border-radius: 16px;
    background-color: rgba(40, 40, 40, 0.6);
    z-index: 1;
  }

  .stream-status-indicator.online {
    color: #56d364;
  }

  .stream-status-indicator.offline {
    color: #f85149;
  }

  .status-indicator {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-right: 6px;
  }

  .stream-status-indicator.online .status-indicator {
    background-color: #56d364;
    box-shadow: 0 0 0 2px rgba(86, 211, 100, 0.3);
    animation: pulse 2s infinite;
  }

  .stream-status-indicator.offline .status-indicator {
    background-color: #f85149;
  }

  .stream-content {
    display: flex;
    gap: 15px;
  }

  .stream-thumbnail {
    width: 320px;
    height: 180px;
    overflow: hidden;
    border-radius: 4px;
    flex-shrink: 0;
  }

  .stream-thumbnail img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
    opacity: 0;
    transition: opacity 0.4s ease-in;
  }

  .stream-thumbnail img.loaded {
    opacity: 1;
  }

  .stream-details {
    flex: 1;
  }

  .stream-title {
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 18px;
  }

  .stream-game {
    margin-bottom: 15px;
    color: var(--accent);
  }

  .stream-time {
    display: flex;
    align-items: center;
    color: var(--secondary-text);
    margin-bottom: 15px;
  }

  .stream-time svg {
    margin-right: 5px;
  }

  .stream-metrics {
    display: flex;
    gap: 20px;
  }

  .metric {
    display: flex;
    align-items: center;
  }

  .metric svg {
    margin-right: 5px;
    color: var(--accent);
  }

  .offline-details {
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .last-game {
    color: var(--secondary-text);
  }

  .offline-thumbnail {
    margin-top: 15px;
    width: 100%;
    max-width: 320px;
    height: auto;
    aspect-ratio: 16/9;
    overflow: hidden;
    border-radius: 4px;
  }

  .offline-thumbnail img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    opacity: 0;
    transition: opacity 0.4s ease-in;
  }

  .offline-thumbnail img.loaded {
    opacity: 1;
  }

  @keyframes pulse {
    0% {
      box-shadow: 0 0 0 0 rgba(86, 211, 100, 0.7);
    }
    70% {
      box-shadow: 0 0 0 5px rgba(86, 211, 100, 0);
    }
    100% {
      box-shadow: 0 0 0 0 rgba(86, 211, 100, 0);
    }
  }

  @media (max-width: 768px) {
    .stream-card-header {
      flex-direction: column;
      align-items: flex-start;
    }
    
    .stream-status-indicator {
      top: 50px; /* Position below the title on mobile */
      right: 15px;
    }

    .stream-content {
      flex-direction: column;
    }

    .stream-thumbnail {
      width: 100%;
      height: auto;
      aspect-ratio: 16/9;
    }
  }
  </style>
{% endblock extraStyles %}
{% block extraScripts %}
  <script>
  document.addEventListener('DOMContentLoaded', () => {
    const images = document.querySelectorAll('.fade-in-image');
    
    images.forEach(img => {
      // For images that are already loaded from cache
      if (img.complete) {
        img.classList.add('loaded');
      } else {
        // For images that need to be loaded
        img.addEventListener('load', () => {
          img.classList.add('loaded');
        });
        
        // Fallback in case image fails to load
        img.addEventListener('error', () => {
          img.classList.add('loaded');
        });
      }
    });
  });
  </script>
{% endblock extraScripts %}
</file>

<file path="views/layout.njk">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{% block title %}{{ pageTitle }}{% endblock %} - Enspira</title>
    <style>
      :root {
        --background: #0d1117;
        --card-bg: #161b22;
        --primary-text: #e6edf3;
        --secondary-text: #8b949e;
        --accent: #58a6ff;
        --accent-hover: #79c0ff;
        --error: #f85149;
        --success: #56d364;
        --border: #30363d;
        --input-bg: #0d1117;
        --button-bg: #238636;
        --button-hover: #2ea043;
        --button-secondary-bg: #21262d;
        --button-secondary-hover: #30363d;
        --nav-bg: #161b22;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        background-color: var(--background);
        color: var(--primary-text);
        line-height: 1.6;
        overflow-x: hidden;
      }

      .container {
        width: 100%;
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 20px;
      }

      header {
        background-color: var(--nav-bg);
        border-bottom: 1px solid var(--border);
        padding: 15px 0;
        position: sticky;
        top: 0;
        z-index: 100;
      }

      .header-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .logo {
        font-size: 24px;
        font-weight: bold;
        color: var(--primary-text);
        text-decoration: none;
        display: flex;
        align-items: center;
      }

      .logo svg {
        margin-right: 10px;
      }

      nav ul {
        display: flex;
        list-style: none;
        gap: 20px;
        align-items: center;
      }

      nav a {
        color: var(--primary-text);
        text-decoration: none;
        font-weight: 500;
        padding: 8px 12px;
        border-radius: 6px;
        transition:
          background-color 0.2s,
          color 0.2s;
        display: flex;
        align-items: center;
        height: 100%;
      }

      nav a:hover {
        background-color: var(--button-secondary-hover);
        text-decoration: none;
        color: var(--primary-text);
      }

      nav a.active {
        background-color: var(--button-secondary-bg);
      }

      main {
        padding: 40px 0;
        min-height: calc(100vh - 140px);
      }

      .card {
        background-color: var(--card-bg);
        border-radius: 10px;
        border: 1px solid var(--border);
        padding: 20px;
        margin-bottom: 20px;
      }

      .card-header {
        margin-bottom: 20px;
        padding-bottom: 10px;
        border-bottom: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      h1 {
        font-size: 24px;
        font-weight: 600;
        margin-bottom: 20px;
      }

      h2 {
        font-size: 20px;
        font-weight: 600;
        margin-bottom: 15px;
      }

      h3 {
        font-size: 16px;
        font-weight: 600;
        margin-bottom: 10px;
      }

      p {
        margin-bottom: 15px;
        color: var(--secondary-text);
      }

      a {
        color: var(--accent);
        text-decoration: none;
      }

      a:hover {
        color: var(--accent-hover);
        text-decoration: underline;
      }

      .btn {
        display: inline-block;
        padding: 8px 16px;
        font-size: 14px;
        font-weight: 500;
        border-radius: 6px;
        transition: background-color 0.2s;
        border: none;
        cursor: pointer;
        text-align: center;
      }

      .btn-primary {
        background-color: var(--button-bg);
        color: white;
      }

      .btn-primary:hover {
        background-color: var(--button-hover);
        text-decoration: none;
      }

      .btn-secondary {
        background-color: var(--button-secondary-bg);
        color: var(--primary-text);
      }

      .btn-secondary:hover {
        background-color: var(--button-secondary-hover);
        text-decoration: none;
      }

      .form-group {
        margin-bottom: 20px;
      }

      label {
        display: block;
        margin-bottom: 8px;
        font-weight: 500;
      }

      input[type="text"],
      input[type="password"],
      input[type="email"],
      textarea,
      select {
        width: 100%;
        padding: 10px 12px;
        border-radius: 6px;
        border: 1px solid var(--border);
        background-color: var(--input-bg);
        color: var(--primary-text);
        font-size: 14px;
        transition: border-color 0.2s;
      }

      textarea {
        min-height: 150px;
        resize: vertical;
      }

      input:focus,
      textarea:focus,
      select:focus {
        outline: none;
        border-color: var(--accent);
      }

      .alert {
        padding: 12px 16px;
        border-radius: 6px;
        margin-bottom: 20px;
      }

      .alert-success {
        background-color: rgba(86, 211, 100, 0.1);
        border: 1px solid var(--success);
        color: var(--success);
      }

      .alert-error {
        background-color: rgba(248, 81, 73, 0.1);
        border: 1px solid var(--error);
        color: var(--error);
      }

      footer {
        padding: 20px 0;
        border-top: 1px solid var(--border);
        font-size: 14px;
        color: var(--secondary-text);
      }

      .footer-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .tabs {
        display: flex;
        border-bottom: 1px solid var(--border);
        margin-bottom: 20px;
      }

      .tab {
        padding: 10px 20px;
        cursor: pointer;
        border-bottom: 2px solid transparent;
      }

      .tab.active {
        border-bottom-color: var(--accent);
        color: var(--accent);
      }

      .tab-content {
        display: none;
      }

      .tab-content.active {
        display: block;
      }

      .two-column {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
      }

      .three-column {
        display: grid;
        grid-template-columns: repeat(3, minmax(280px, 1fr));
        grid-gap: 20px;
      }

      @media (max-width: 768px) {
        .two-column {
          grid-template-columns: 1fr;
        }
        .three-column {
          grid-template-columns: 1fr;
        }
        nav ul {
          gap: 10px;
        }
      }

      .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: var(--accent);
        animation: spin 1s ease-in-out infinite;
      }
      .four-column {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 20px;
      }

@media (max-width: 1200px) {
  .four-column {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 600px) {
  .four-column {
    grid-template-columns: 1fr;
  }
}
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* Fix for nested cards in dashboard */
      .card .card {
        margin-bottom: 0;
      }
      
      /* Fix for two-column inside cards */
      .card > .two-column > .card {
        height: 100%;
        display: flex;
        flex-direction: column;
      }
      
      .card > .two-column > .card p {
        flex-grow: 1;
      }
    </style>
    {% block extraStyles %}{% endblock %}
  </head>
  <body>
    <header>
      <div class="container header-content">
        <a href="/web/dashboard" class="logo">
          <svg
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path d="M12 2L2 7L12 12L22 7L12 2Z" fill="#58a6ff" />
            <path
              d="M2 17L12 22L22 17"
              stroke="#58a6ff"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
            <path
              d="M2 12L12 17L22 12"
              stroke="#58a6ff"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
          <span>Enspira</span>
        </a>
        <nav>
          <ul>
            <li>
              <a href="/web/dashboard" class="{% if dashboardActive %}active{% endif %}">Dashboard</a>
            </li>
            <li>
              <a href="/web/character" class="{% if characterActive %}active{% endif %}">Character</a>
            </li>
            <li>
              <a href="/web/world" class="{% if worldActive %}active{% endif %}">World</a>
            </li>
            <li>
              <a href="/web/help" class="{% if helpActive %}active{% endif %}">Help</a>
            </li>
            <li>
              <a href="/web/gallery" class="{% if galleryActive %}active{% endif %}">Gallery</a>
            </li>
            <li>
              <a href="/web/settings" class="{% if settingsActive %}active{% endif %}">Settings</a>
            </li>
            <li>
              <a href="/web/auth/logout" class="btn btn-secondary">Logout</a>
            </li>
          </ul>
        </nav>
      </div>
    </header>

    <main>
      <div class="container">
        {% block content %}{% endblock %}
      </div>
    </main>

    <footer>
      <div class="container footer-content">
        <div>Enspira &copy; {{ year }}</div>
        <div>
          <a href="https://github.com/prolix-oc/Enspira" target="_blank">GitHub</a>
        </div>
      </div>
    </footer>

    <script>
      // Common JavaScript functions
      document.addEventListener("DOMContentLoaded", () => {
        // Tab handling
        const tabGroups = document.querySelectorAll(".tabs");
        tabGroups.forEach((tabGroup) => {
          const tabs = tabGroup.querySelectorAll(".tab");
          const tabContents = document.querySelectorAll(".tab-content");

          tabs.forEach((tab) => {
            tab.addEventListener("click", () => {
              // Remove active class from all tabs in this group
              tabGroup.querySelectorAll(".tab").forEach((t) => t.classList.remove("active"));

              // Add active class to clicked tab
              tab.classList.add("active");

              // Show corresponding tab content
              const target = tab.getAttribute("data-target");
              document.querySelectorAll(".tab-content").forEach((content) => {
                if (content.id === target) {
                  content.classList.add("active");
                } else {
                  content.classList.remove("active");
                }
              });
            });
          });
        });

        // Form submission handling
        const forms = document.querySelectorAll("form[data-async]");
        forms.forEach((form) => {
          form.addEventListener("submit", async (e) => {
            e.preventDefault();

            const formData = new FormData(form);
            const submitBtn = form.querySelector('button[type="submit"]');
            
            // If no submit button found, just proceed
            if (!submitBtn) {
              processForm();
              return;
            }
            
            const originalBtnText = submitBtn.textContent;

            // Show loading state
            submitBtn.disabled = true;
            submitBtn.innerHTML = '<span class="loading"></span> Processing...';

            // Process the form
            processForm();

            // Function to process the form submission
            async function processForm() {
              try {
                const response = await fetch(form.action, {
                  method: form.method || "POST",
                  body: formData,
                  headers: {
                    Accept: "application/json",
                  },
                });

                const result = await response.json();

                if (response.ok) {
                  // Show success message
                  const existingAlert = form.querySelector('.alert');
                  if (existingAlert) {
                    existingAlert.remove();
                  }
                  
                  const alertEl = document.createElement("div");
                  alertEl.className = "alert alert-success";
                  alertEl.textContent = result.message || "Changes saved successfully!";
                  form.prepend(alertEl);

                  // Remove alert after 3 seconds
                  setTimeout(() => alertEl.remove(), 3000);

                  // If there's a redirect URL, navigate there
                  if (result.redirect) {
                    window.location.href = result.redirect;
                  }
                } else {
                  // Show error message
                  const existingAlert = form.querySelector('.alert');
                  if (existingAlert) {
                    existingAlert.remove();
                  }
                  
                  const alertEl = document.createElement("div");
                  alertEl.className = "alert alert-error";
                  alertEl.textContent = result.error || "An error occurred. Please try again.";
                  form.prepend(alertEl);
                }
              } catch (error) {
                console.error("Error:", error);
                
                const existingAlert = form.querySelector('.alert');
                if (existingAlert) {
                  existingAlert.remove();
                }
                
                const alertEl = document.createElement("div");
                alertEl.className = "alert alert-error";
                alertEl.textContent = "An unexpected error occurred. Please try again.";
                form.prepend(alertEl);
              } finally {
                // Restore button state if it exists
                if (submitBtn) {
                  submitBtn.disabled = false;
                  submitBtn.textContent = originalBtnText;
                }
              }
            }
          });
        });

        // Image loading for fade-in images
        const fadeImages = document.querySelectorAll('.fade-in-image');
        if (fadeImages.length > 0) {
          fadeImages.forEach(img => {
            if (img.complete) {
              img.classList.add('loaded');
            } else {
              img.addEventListener('load', () => img.classList.add('loaded'));
              img.addEventListener('error', () => img.classList.add('loaded'));
            }
          });
        }
      });
    </script>

    {% block extraScripts %}{% endblock %}
  </body>
</html>
</file>

<file path="create-global-logger.js">
import { getLogger } from './logger.js';

// Export the shared logger instance so it can be imported by other modules
export const logger = getLogger();

// Define a function to ensure the global logger is set up
export function ensureGlobalLogger() {
  if (!global.logger && global._sharedObjects && global._sharedObjects.logger) {
    global.logger = global._sharedObjects.logger;
  }
  
  return global.logger || logger;
}

// Ensure the global logger is available
ensureGlobalLogger();

// For modules that need direct console access, provide a console wrapper
export const logConsole = Object.fromEntries(
  ['log', 'info', 'warn', 'error', 'debug'].map(level => [
    level, 
    (message) => logger[level](level === 'log' || level === 'error' ? "Console" : null, message)
  ])
);
</file>

<file path="mongodb-client.js">
// mongodb-client.js - New module for MongoDB operations
import mongoose from "mongoose";
import fs from "fs-extra";
import { retrieveConfigValue } from "./config-helper.js";
import { logger } from "./create-global-logger.js";

// Cache with TTL
const userCache = new Map();
const dirtyFlags = new Map();
let connectionEstablished = false;
let connectionRetries = 0;
const MAX_RETRIES = 5;

// Define user schema with essential fields
const userSchema = new mongoose.Schema(
  {
    // Required unique identifier
    user_id: { type: String, required: true, unique: true, index: true },

    // Authentication fields
    api_token: { type: String, index: true },
    webPasswordHash: String,
    webPasswordSalt: String,
    webPasswordIterations: { type: Number, default: 20480 },

    // User information
    email: String,
    user_name: String, // Used for system references
    display_name: String,

    // Twitch integration
    twitch_name: String,
    bot_name: String,
    bot_twitch: String,

    // Token and integration data
    twitch_tokens: {
      streamer: {
        access_token: String,
        refresh_token: String,
        expires_at: Number,
        twitch_user_id: String,
        twitch_login: String,
        twitch_display_name: String,
        webhook_secret: String,
        subscriptions: Array,
        scopes: Array,
      },
      bot: {
        access_token: String,
        refresh_token: String,
        expires_at: Number,
        twitch_user_id: String,
        twitch_login: String,
        twitch_display_name: String,
        scopes: Array,
      },
    },

    // User preferences
    socials: {
      twitter: String,
      tiktok: String,
      youtube: String,
      instagram: String,
      twitch: String,
      kick: String,
    },

    // Stream and chat settings
    weather: { type: Boolean, default: false },
    store_all_chat: { type: Boolean, default: true },
    commands_list: { type: Array, default: [] },
    aux_bots: { type: Array, default: [] },

    // TTS settings
    tts_enabled: { type: Boolean, default: false },
    ttsEqPref: { type: String, default: "clarity" },
    ttsUpsamplePref: { type: Boolean, default: false },
    speaker_file: String,
    fishTTSVoice: String,

    // Fun facts settings
    funFacts: { type: Boolean, default: false },
    funFactsInterval: { type: Number, default: 30 },

    // Tracking fields
    lastIp: String,
    latitude: String,
    longitude: String,
    timeZone: String,

    // Stream status tracking
    current_game: Object,
    current_viewers: { type: Number, default: 0 },
    current_followers: { type: Number, default: 0 },
    stream_status: mongoose.Schema.Types.Mixed,

    // Feature flags
    global_strikes: { type: Boolean, default: false },
    global_bans: { type: Boolean, default: false },
    allow_beta_features: { type: Boolean, default: false },
    is_local: { type: Boolean, default: false },
    max_chats: { type: Number, default: 25 },
  },
  {
    strict: false, // Allow additional fields beyond schema
    timestamps: true, // Add createdAt and updatedAt automatically
    minimize: false, // Store empty objects
  }
);

const chatMessageSchema = new mongoose.Schema(
  {
    user_id: { type: String, required: true, index: true },
    username: { type: String, required: true },
    message: { type: String, required: true },
    message_id: { type: String, required: true, unique: true },
    timestamp: { type: Date, default: Date.now, index: true },
    ai_response: String,
    embedding_id: String, // Reference to Milvus if message has embedding
    is_important: { type: Boolean, default: false },
    metadata: mongoose.Schema.Types.Mixed,
  },
  {
    strict: false,
    timestamps: true,
  }
);

chatMessageSchema.index({ user_id: 1, timestamp: -1 });
chatMessageSchema.index({ username: 1, user_id: 1 });
chatMessageSchema.index({ message: "text", ai_response: "text" });

// Create indexes for performance
userSchema.index({ "twitch_tokens.streamer.twitch_user_id": 1 });
userSchema.index({ "twitch_tokens.bot.twitch_user_id": 1 });
userSchema.index({ user_id: 1 });

const User = mongoose.model("User", userSchema, "user_data");
const ChatMessage = mongoose.model(
  "ChatMessage",
  chatMessageSchema,
  "chat_messages"
);

// Connect to MongoDB
export async function connectToMongoDB() {
  try {
    if (connectionEstablished) return true;

    const mongoUri = await retrieveConfigValue("mongoDb.endpoint");
    const mongoUser = await retrieveConfigValue("mongoDb.user");
    const mongoPass = await retrieveConfigValue("mongoDb.password");
    const mongoDb =
      (await retrieveConfigValue("mongoDb.database")) || "enspira";

    // Build connection string with authentication if credentials exist
    let connectionString = mongoUri;
    if (mongoUser && mongoPass) {
      // Transform URI to include auth if not already formatted that way
      if (mongoUri.indexOf("@") === -1) {
        // Assuming mongoUri is in format: mongodb://host:port
        const uriParts = mongoUri.split("//");
        connectionString = `${uriParts[0]}//${mongoUser}:${encodeURIComponent(mongoPass)}@${uriParts[1]}`;
      }
    }

    // Add database name if not in the connection string
    if (connectionString.split("/").length <= 3) {
      connectionString = `${connectionString}/${mongoDb}`;
    }

    await mongoose.connect(connectionString, {
      serverSelectionTimeoutMS: 5000,
      connectTimeoutMS: 10000,
      socketTimeoutMS: 45000,
      maxPoolSize: 10,
    });

    connectionEstablished = true;
    logger.log("MongoDB", `Connected to MongoDB at ${mongoUri} successfully`);

    // Run migration if needed
    await migrateFromFileIfNeeded();

    // Set up cache cleanup interval
    setInterval(cleanupCache, 60000); // Check every minute

    return true;
  } catch (error) {
    logger.error("MongoDB", `Failed to connect to MongoDB: ${error.message}`);
    return false;
  }
}

function handleDisconnect() {
  if (connectionEstablished) {
    connectionEstablished = false;
    logger.error(
      "MongoDB",
      "Disconnected from database. Attempting to reconnect..."
    );

    // Attempt reconnection after a delay
    setTimeout(() => {
      connectToMongoDB().catch((err) => {
        logger.error("MongoDB", `Reconnection failed: ${err.message}`);
      });
    }, 5000);
  }
}

function handleConnectionError(err) {
  logger.error("MongoDB", `MongoDB connection error: ${err.message}`);

  if (connectionEstablished) {
    connectionEstablished = false;
    // Attempt reconnection will happen via the 'disconnected' event
  }
}

// Migrate data from auth_keys.json if collection is empty
async function migrateFromFileIfNeeded() {
  try {
    const count = await User.countDocuments({});
    if (count === 0) {
      logger.log("MongoDB", "Collection is empty, migrating from file...");

      const authFilePath = await retrieveConfigValue("server.authFilePath");
      if (fs.existsSync(authFilePath)) {
        const fileData = await fs.readJSON(authFilePath);

        if (Array.isArray(fileData) && fileData.length > 0) {
          // Transform the data before inserting
          const transformedData = fileData.map((user) => {
            // Create a clean copy of the user object
            const transformedUser = { ...user };

            // Fix stream_status if it exists but isn't in the right format
            if (
              transformedUser.stream_status &&
              typeof transformedUser.stream_status !== "object"
            ) {
              transformedUser.stream_status = {
                online: false,
                updated_at: new Date().toISOString(),
              };
            } else if (transformedUser.stream_status) {
              // Ensure it has the expected structure
              transformedUser.stream_status = {
                online: transformedUser.stream_status.online || false,
                started_at: transformedUser.stream_status.started_at || null,
                type: transformedUser.stream_status.type || null,
                title: transformedUser.stream_status.title || null,
                viewer_count: transformedUser.stream_status.viewer_count || 0,
                updated_at:
                  transformedUser.stream_status.updated_at ||
                  new Date().toISOString(),
              };
            }

            return transformedUser;
          });

          // Insert transformed data
          await User.insertMany(transformedData, { validateBeforeSave: false });
          logger.log(
            "MongoDB",
            `Migrated ${transformedData.length} users from file to MongoDB`
          );

          // Create backup of original file
          const backupPath = `${authFilePath}.bak.${Date.now()}`;
          await fs.copy(authFilePath, backupPath);
          logger.log(
            "MongoDB",
            `Created backup of original auth file at ${backupPath}`
          );
        }
      }
    }
  } catch (error) {
    logger.error("MongoDB", `Migration error: ${error.message}`);
  }
}

async function withCaching(key, fetchFn, options = {}) {
  const { ttl = 60000, forceFresh = false } = options;
  
  // Check cache first unless forceFresh is true
  if (!forceFresh && userCache.has(key)) {
    const cachedData = userCache.get(key);
    if (Date.now() < cachedData.expiry) {
      return cachedData.data;
    }
    userCache.delete(key);
  }
  
  // Try DB connection if needed
  if (!connectionEstablished) {
    const connected = await connectToMongoDB();
    if (!connected) {
      logger.error("MongoDB", `Cannot fetch data: Database not connected`);
      return null;
    }
  }
  
  // Fetch from database
  try {
    const data = await fetchFn();
    
    if (data) {
      // Cache for specified time
      userCache.set(key, {
        data,
        expiry: Date.now() + ttl,
        lastModified: Date.now()
      });
    }
    
    return data;
  } catch (error) {
    logger.error("MongoDB", `Error fetching data for ${key}: ${error.message}`);
    return null;
  }
}

// Get user by ID with caching
export async function getUserById(userId) {
  try {
    return withCaching(userId, 
      () => User.findOne({ user_id: userId }).lean()
    );
  } catch (error) {
    logger.error("MongoDB", `Error fetching user ${userId}: ${error.message}`);
    return null;
  }
}

// Get all users
export async function getAllUsers() {
  try {
    if (!connectionEstablished) {
      // Try to connect if not already connected
      const connected = await connectToMongoDB();
      if (!connected) {
        logger.error("MongoDB", "Cannot get all users: Database not connected");
        return [];
      }
    }

    return await User.find({}).lean();
  } catch (error) {
    logger.error("MongoDB", `Error fetching all users: ${error.message}`);
    return [];
  }
}

// Update user data with path support
export async function updateUserData(userId, path, value) {
  try {
    if (!connectionEstablished) {
      // Try to connect if not already connected
      const connected = await connectToMongoDB();
      if (!connected) {
        logger.error(
          "MongoDB",
          `Cannot update user ${userId}: Database not connected`
        );
        return false;
      }
    }

    // Get the user from cache or DB
    let user = userCache.has(userId)
      ? userCache.get(userId).data
      : await getUserById(userId);

    if (!user) {
      logger.error("MongoDB", `Cannot update: User ${userId} not found`);
      return false;
    }

    // If path is empty, replace the entire object
    if (!path) {
      const result = await User.replaceOne({ user_id: userId }, value);

      if (result.modifiedCount > 0 || result.upsertedCount > 0) {
        // Update cache
        userCache.set(userId, {
          data: value,
          expiry: Date.now() + 60000,
          lastModified: Date.now(),
        });

        return true;
      }
      return false;
    }

    // Handle nested path updates
    const pathParts = path.split(".");
    let current = user;

    // Navigate to containing object
    for (let i = 0; i < pathParts.length - 1; i++) {
      const part = pathParts[i];

      if (current[part] === undefined) {
        current[part] = {};
      }

      current = current[part];
    }

    // Update the value
    const lastPart = pathParts[pathParts.length - 1];
    current[lastPart] = value;

    // Mark as dirty and update cache
    dirtyFlags.set(userId, true);
    userCache.set(userId, {
      data: user,
      expiry: Date.now() + 60000,
      lastModified: Date.now(),
    });

    // Write through for immediate persistence
    const updatePath = path ? { [`${path}`]: value } : user;
    await User.updateOne(
      { user_id: userId },
      { $set: updatePath },
      { upsert: true }
    );

    return true;
  } catch (error) {
    logger.error("MongoDB", `Error updating user ${userId}: ${error.message}`);
    return false;
  }
}

// Ensure path exists in user object
export async function ensureUserPath(userId, path) {
  try {
    if (!connectionEstablished) {
      // Try to connect if not already connected
      const connected = await connectToMongoDB();
      if (!connected) {
        logger.error(
          "MongoDB",
          `Cannot ensure path for user ${userId}: Database not connected`
        );
        return false;
      }
    }

    // Get the user
    let user = userCache.has(userId)
      ? userCache.get(userId).data
      : await getUserById(userId);

    if (!user) {
      logger.error("MongoDB", `Cannot ensure path: User ${userId} not found`);
      return false;
    }

    // Split the path into parts
    const pathParts = path.split(".");
    let current = user;
    let updateNeeded = false;

    // Create path objects as needed
    for (let i = 0; i < pathParts.length; i++) {
      const part = pathParts[i];

      if (!current[part]) {
        current[part] = {};
        updateNeeded = true;
      }

      current = current[part];
    }

    // Only update DB if we made changes
    if (updateNeeded) {
      // Update cache
      userCache.set(userId, {
        data: user,
        expiry: Date.now() + 60000,
        lastModified: Date.now(),
      });

      // Prepare update for database - we need to construct a $set operation for the path
      const setOperation = { $set: {} };
      setOperation.$set[path] = {};

      // Update database
      await User.updateOne({ user_id: userId }, setOperation, { upsert: true });
    }

    return true;
  } catch (error) {
    logger.error(
      "MongoDB",
      `Error ensuring path for user ${userId}: ${error.message}`
    );
    return false;
  }
}

// Clean up cache and flush changes
async function cleanupCache() {
  const now = Date.now();
  const promises = [];

  for (const [userId, cacheEntry] of userCache.entries()) {
    // Check if expired
    if (now >= cacheEntry.expiry) {
      // If dirty, save before removing
      if (dirtyFlags.get(userId)) {
        promises.push(
          User.replaceOne({ user_id: userId }, cacheEntry.data, {
            upsert: true,
          })
            .then(() => {
              logger.log(
                "MongoDB",
                `Flushed changes for user ${userId} before cache expiry`
              );
              dirtyFlags.delete(userId);
            })
            .catch((error) => {
              logger.error(
                "MongoDB",
                `Error flushing changes for user ${userId}: ${error.message}`
              );
            })
        );
      }

      // Remove from cache after promise is added
      userCache.delete(userId);
    }
  }

  // Wait for all save operations to complete
  if (promises.length > 0) {
    await Promise.allSettled(promises);
  }
}

export async function createUser(userData) {
  try {
    if (!connectionEstablished) {
      // Try to connect if not already connected
      const connected = await connectToMongoDB();
      if (!connected) {
        logger.error("MongoDB", "Cannot create user: Database not connected");
        return null;
      }
    }

    // Ensure user_id exists
    if (!userData.user_id) {
      logger.error("MongoDB", "Cannot create user: Missing user_id field");
      return null;
    }

    // Check if user already exists
    const existingUser = await User.findOne({ user_id: userData.user_id });
    if (existingUser) {
      logger.error(
        "MongoDB",
        `User with ID ${userData.user_id} already exists`
      );
      return null;
    }

    // Create new user
    const newUser = new User(userData);
    const savedUser = await newUser.save();

    // Add to cache
    userCache.set(userData.user_id, {
      data: savedUser.toObject(),
      expiry: Date.now() + 60000,
      lastModified: Date.now(),
    });

    logger.log("MongoDB", `Created new user with ID ${userData.user_id}`);
    return savedUser.toObject();
  } catch (error) {
    logger.error("MongoDB", `Error creating user: ${error.message}`);
    return null;
  }
}

// Flush all pending changes
export async function flushAllChanges() {
  if (!connectionEstablished) {
    logger.error("MongoDB", "Cannot flush changes: Database not connected");
    return false;
  }

  const promises = [];

  for (const [userId, cacheEntry] of userCache.entries()) {
    if (dirtyFlags.get(userId)) {
      promises.push(
        User.replaceOne({ user_id: userId }, cacheEntry.data, { upsert: true })
          .then(() => {
            logger.log("MongoDB", `Flushed changes for user ${userId}`);
            dirtyFlags.delete(userId);
          })
          .catch((error) => {
            logger.error(
              "MongoDB",
              `Error flushing changes for user ${userId}: ${error.message}`
            );
          })
      );
    }
  }

  // Wait for all save operations to complete
  if (promises.length > 0) {
    try {
      await Promise.allSettled(promises);
      return true;
    } catch (error) {
      logger.error(
        "MongoDB",
        `Error during flush operations: ${error.message}`
      );
      return false;
    }
  }

  return true;
}

export async function storeChatMessage(
  userId,
  messageData,
  generateEmbedding = false
) {
  try {
    const messageId = crypto.randomBytes(16).toString("hex");

    // Check if this is an important message that needs semantic search
    const isImportant =
      generateEmbedding ||
      messageData.firstMessage ||
      messageData.mentionsCharacter;

    // Create the message document
    const chatMessage = new ChatMessage({
      user_id: userId,
      username: messageData.username,
      message: messageData.message,
      message_id: messageId,
      timestamp: new Date(),
      ai_response: messageData.aiResponse || null,
      is_important: isImportant,
      metadata: {
        firstMessage: messageData.firstMessage || false,
        mentionsCharacter: messageData.mentionsCharacter || false,
        emoteCount: messageData.emoteCount || 0,
      },
    });

    // Save to MongoDB first
    await chatMessage.save();

    // If important, also store in Milvus for semantic search
    if (isImportant) {
      try {
        // Create the summary text for embedding
        const formattedDate = new Date().toLocaleString();
        const summaryString = `On ${formattedDate}, ${messageData.username} said in ${userId}'s Twitch chat: "${messageData.message}". ${messageData.aiResponse ? `You responded by saying: ${messageData.aiResponse}` : ""}`;

        // Store in Milvus
        const embeddingId = await storeInMilvus(
          userId,
          summaryString,
          messageData
        );

        // Update MongoDB with reference to Milvus entry
        if (embeddingId) {
          await ChatMessage.updateOne(
            { message_id: messageId },
            { $set: { embedding_id: embeddingId } }
          );
        }
      } catch (milvusError) {
        logger.error(
          "Milvus",
          `Error storing embedding: ${milvusError.message}`
        );
        // Continue anyway - we still have the message in MongoDB
      }
    }

    return { success: true, message_id: messageId };
  } catch (error) {
    logger.error("MongoDB", `Error storing chat message: ${error.message}`);
    return { success: false, error: error.message };
  }
}

// Chat count - Get total number of messages without retrieving documents
export async function getChatCount(userId) {
  try {
    const numChats = await ChatMessage.countDocuments({ user_id: userId });
    logger.log("Mongo", `Getting ${numChats} for ${userId}`)
  } catch (error) {
    logger.error("MongoDB", `Error counting chats: ${error.message}`);
    return 0;
  }
}

// Get recent chats with pagination
export async function getRecentChats(userId, limit = 25, skip = 0) {
  try {
    const messages = await ChatMessage.find({ user_id: userId })
      .sort({ timestamp: -1 })
      .skip(skip)
      .limit(limit)
      .lean();

    // Format for compatibility with existing code
    return messages.map((msg) => ({
      username: msg.username,
      raw_msg: msg.message,
      text_content: `${msg.username} sent the following message: ${msg.message}`,
      ai_message: msg.ai_response || "",
      time_stamp: new Date(msg.timestamp).getTime(),
    }));
  } catch (error) {
    logger.error("MongoDB", `Error fetching recent chats: ${error.message}`);
    return [];
  }
}

// Find relevant chat context (our hybrid implementation)
export async function findRelevantChatContext(
  userId,
  message,
  username,
  limit = 10,
  options = {}
) {
  const { useVectors = true, simpleTextSearch = true } = options;

  try {
    // Start with MongoDB text search (fast)
    let relevantMessages = [];

    if (simpleTextSearch) {
      // Use MongoDB text search for keyword matching
      relevantMessages = await ChatMessage.find(
        {
          user_id: userId,
          $text: { $search: message },
        },
        {
          score: { $meta: "textScore" },
        }
      )
        .sort({ score: { $meta: "textScore" } })
        .limit(limit)
        .lean();

      // Format for compatibility with existing code
      relevantMessages = relevantMessages.map((msg) => ({
        username: msg.username,
        raw_msg: msg.message,
        text_content: `${msg.username} sent the following message: ${msg.message}`,
        ai_message: msg.ai_response || "",
        time_stamp: new Date(msg.timestamp).getTime(),
      }));
    }

    // If we didn't find enough with text search and vectors are enabled, try Milvus
    if (useVectors && relevantMessages.length < Math.ceil(limit / 2)) {
      try {
        // Import the vector search function
        const { findRelevantChats } = await import("./ai-logic.js");

        // Use Milvus for semantic search
        const milvusResults = await findRelevantChats(
          message,
          username,
          userId,
          limit
        );

        // If we got Milvus results, either use them exclusively or merge
        if (milvusResults && milvusResults.length > 0) {
          if (relevantMessages.length === 0) {
            // Just use Milvus results if MongoDB found nothing
            return milvusResults;
          } else {
            // Merge results, prioritizing Milvus for semantic richness
            // Use a Map to deduplicate by filtering on raw_msg
            const messageMap = new Map();

            // Add Milvus results first (priority)
            milvusResults.forEach((msg) => {
              messageMap.set(msg.raw_msg, msg);
            });

            // Add MongoDB results if not already present
            relevantMessages.forEach((msg) => {
              if (!messageMap.has(msg.raw_msg)) {
                messageMap.set(msg.raw_msg, msg);
              }
            });

            // Convert back to array and limit to requested size
            return Array.from(messageMap.values()).slice(0, limit);
          }
        }
      } catch (milvusError) {
        logger.error("Chat", `Milvus search error: ${milvusError.message}`);
        // Continue with MongoDB results if Milvus fails
      }
    }

    return relevantMessages;
  } catch (error) {
    logger.error("Chat", `Error finding relevant context: ${error.message}`);
    return [];
  }
}

export async function checkDatabaseHealth() {
  try {
    if (!connectionEstablished) {
      // Try connecting
      const connected = await connectToMongoDB();
      if (!connected) {
        return { connected: false, error: "Failed to connect to database" };
      }
    }

    // Run a simple query to test connection
    await User.findOne({}).select("user_id").lean();

    return {
      connected: true,
      pendingWrites: dirtyFlags.size,
      cachedUsers: userCache.size,
      status:
        mongoose.connection.readyState === 1 ? "connected" : "disconnected",
    };
  } catch (error) {
    return {
      connected: false,
      error: error.message,
      status: mongoose.connection.readyState,
    };
  }
}

// Disconnect from MongoDB
export async function disconnect() {
  try {
    // Flush any pending changes
    await flushAllChanges();

    // Clear intervals
    clearInterval(cleanupCache);

    // Disconnect
    await mongoose.disconnect();
    connectionEstablished = false;
    logger.log("MongoDB", "Disconnected from MongoDB");
    return true;
  } catch (error) {
    logger.error(
      "MongoDB",
      `Error disconnecting from MongoDB: ${error.message}`
    );
    return false;
  }
}

process.on("SIGTERM", async () => {
  logger.log("MongoDB", "SIGTERM received, flushing changes and disconnecting");
  await flushAllChanges();
  await mongoose.disconnect();
});

process.on("SIGINT", async () => {
  logger.log("MongoDB", "SIGINT received, flushing changes and disconnecting");
  await flushAllChanges();
  await mongoose.disconnect();
});
</file>

<file path="views/character.njk">
{% extends "layout.njk" %}
{% block title %}Character Editor{% endblock %}
{% block content %}
  <div class="card">
    <div class="card-header">
      <h1>Character Editor</h1>
    </div>
    <p>
      Customize your AI assistant's personality, description, and behavior. These settings help define how your assistant interacts with your Twitch chat.
    </p>
    <div class="tabs">
      <div class="tab active" data-target="personality-tab">Personality</div>
      <div class="tab" data-target="description-tab">Description</div>
      <div class="tab" data-target="example-messages-tab">Example Messages</div>
      <div class="tab" data-target="features-tab">Features</div>
    </div>
    <div id="personality-tab" class="tab-content active">
      <form action="/api/v1/character/personality" method="POST" data-async>
        <div class="form-group">
          <label for="bot_name">Character Name</label>
          <input type="text"
                 id="bot_name"
                 name="bot_name"
                 value="{{ character.bot_name }}"
                 required>
          <p>This is the name your AI assistant will use.</p>
        </div>
        <div class="form-group">
          <label for="personality">Personality</label>
          <textarea id="personality" name="personality" rows="12" required>{{ characterPersonality }}</textarea>
          <p>Describe your assistant's personality traits, mannerisms, speaking style, interests, and attitudes.</p>
        </div>
        <button type="submit" class="btn btn-primary">Save Personality</button>
      </form>
    </div>
    <div id="description-tab" class="tab-content">
      <form action="/api/v1/character/description" method="POST" data-async>
        <div class="form-group">
          <label for="description">Physical Description</label>
          <textarea id="description" name="description" rows="12" required>{{ characterDescription }}</textarea>
          <p>Describe your assistant's appearance, physical attributes, clothing, and other visual aspects.</p>
        </div>
        <button type="submit" class="btn btn-primary">Save Description</button>
      </form>
    </div>
    <div id="example-messages-tab" class="tab-content">
      <form action="/api/v1/character/examples" method="POST" data-async>
        <div class="form-group">
          <label for="examples">Example Interactions</label>
          <textarea id="examples" name="examples" rows="15" required>{{ characterExamples }}</textarea>
          <p>
            Provide examples of how your assistant would respond to different situations. This helps establish the assistant's tone and style. Format as:
          </p>
          <pre style="background-color: var(--input-bg); padding: 10px; margin-top: 5px; border-radius: 6px;">
{{ character.bot_name }}: [Example response]

{{ character.bot_name }}: [Another response]</pre>
        </div>
        <button type="submit" class="btn btn-primary">Save Examples</button>
      </form>
    </div>
  </div>
  <div id="features-tab" class="tab-content">
    <form action="/api/v1/character/features" method="POST" data-async>
      <div class="form-group">
        <label for="funFacts">Fun Facts</label>
        <select id="funFacts" name="funFacts">
          <option value="true" {% if character.funFacts %}selected{% endif %}>Enabled</option>
          <option value="false" {% if not character.funFacts %}selected{% endif %}>Disabled</option>
        </select>
        <p>Enable your AI assistant to occasionally share interesting fun facts in chat.</p>
      </div>
      <div class="form-group">
        <label for="funFactsInterval">Fun Facts Interval (minutes)</label>
        <input type="number"
               id="funFactsInterval"
               name="funFactsInterval"
               value="{{ character.funFactsInterval or '30' }}"
               min="5"
               max="240">
        <p>How often should your assistant share fun facts? (5-240 minutes)</p>
      </div>
      <div class="form-group">
        <label for="tts_enabled">Text-to-Speech</label>
        <select id="tts_enabled" name="tts_enabled">
          <option value="true" {% if character.tts_enabled %}selected{% endif %}>Enabled</option>
          <option value="false" {% if not character.tts_enabled %}selected{% endif %}>Disabled</option>
        </select>
        <p>Enable your AI assistant to use text-to-speech for voice responses.</p>
      </div>
      <div class="form-group">
        <label for="ttsEqPref">Voice Quality Preset</label>
        <select id="ttsEqPref"
                name="ttsEqPref"
                {% if not character.tts_enabled %}disabled{% endif %}>
          <option value="clarity"
                  {% if character.ttsEqPref == 'clarity' %}selected{% endif %}>Clarity</option>
          <option value="warm"
                  {% if character.ttsEqPref == 'warm' %}selected{% endif %}>Warm</option>
          <option value="bright"
                  {% if character.ttsEqPref == 'bright' %}selected{% endif %}>Bright</option>
          <option value="broadcast"
                  {% if character.ttsEqPref == 'broadcast' %}selected{% endif %}>Broadcast</option>
        </select>
        <p>Choose a preset for your assistant's voice quality.</p>
      </div>
      <div class="form-group">
        <label for="ttsUpsamplePref">Audio Upsampling</label>
        <select id="ttsUpsamplePref"
                name="ttsUpsamplePref"
                {% if not character.tts_enabled %}disabled{% endif %}>
          <option value="true" {% if character.ttsUpsamplePref %}selected{% endif %}>Enabled</option>
          <option value="false"
                  {% if not character.ttsUpsamplePref %}selected{% endif %}>Disabled</option>
        </select>
        <p>Enable audio upsampling for better voice quality (uses more CPU).</p>
      </div>
      <button type="submit" class="btn btn-primary">Save Features</button>
    </form>
    <div class="card" style="margin-top: 20px;">
      <h3>Custom Voice Upload</h3>
      <p>Upload up to 4 WAV audio samples of your character's voice. Files must be mono, 16-bit, 22050Hz, 44100Hz, or 48000Hz, ≤20 seconds, and under 3MB each.</p>
      
      {% if character.speaker_file %}
      <div class="alert alert-success">
        <p>Voice samples configured: <strong>{{ character.speaker_file }}</strong></p>
      </div>
      {% endif %}
      
      <div class="file-input-wrapper">
        <label for="voice-file-input" class="btn btn-secondary">Browse Files</label>
        <span id="file-select-text">No file selected</span>
        <input type="file" id="voice-file-input" accept="audio/wav" style="display: none;">
      </div>
      
      <button type="button" id="add-file-btn" class="btn btn-secondary" disabled style="margin-top: 10px;">Add File</button>
      
      <div id="validation-message" class="alert alert-error" style="display: none; margin-top: 10px;"></div>
      
      <div id="selected-files-container" style="margin-top: 15px; display: none;">
        <h4>Selected Files</h4>
        <table class="file-list-table" style="width: 100%; border-collapse: collapse;">
          <thead>
            <tr>
              <th style="text-align: left; padding: 8px; border-bottom: 1px solid var(--border);">Filename</th>
              <th style="text-align: left; padding: 8px; border-bottom: 1px solid var(--border);">Size</th>
              <th style="text-align: left; padding: 8px; border-bottom: 1px solid var(--border);">Actions</th>
            </tr>
          </thead>
          <tbody id="file-list-table">
            <!-- Files will be added here dynamically -->
          </tbody>
        </table>
      </div>
      
      <button type="button" id="upload-btn" class="btn btn-primary" style="margin-top: 15px;" disabled>Upload Voice Samples</button>
    </div>
  </div>

  <style>
    input[type="file"].form-control {
        padding: 6px;
        background-color: var(--input-bg);
        color: var(--primary-text);
        border: 1px solid var(--border);
        border-radius: 6px;
        width: 100%;
        max-width: 500px;
        margin-top: 5px;
      }
      
    .form-text {
      display: block;
      margin-top: 5px;
      color: var(--secondary-text);
    }

    .file-input-wrapper {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    #file-select-text {
      color: var(--secondary-text);
      margin-left: 5px;
      flex-grow: 1;
    }
    
    .file-list-table {
      background-color: var(--input-bg);
      border-radius: 6px;
      overflow: hidden;
    }
    
    .file-list-table tbody tr {
      border-bottom: 1px solid var(--border);
    }
    
    .file-list-table tbody tr:last-child {
      border-bottom: none;
    }
    
    .file-list-table td {
      padding: 8px;
    }
    
    .file-action-btn {
      background-color: var(--button-secondary-bg);
      color: var(--primary-text);
      border: none;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .file-action-btn:hover {
      background-color: var(--button-secondary-hover);
    }
    
    .remove-file-btn {
      color: var(--error);
    }
  </style>
{% endblock %}
{% block extraScripts %}
<script>
  document.addEventListener('DOMContentLoaded', () => {
    const fileInput = document.getElementById('voice-file-input');
    const fileSelectText = document.getElementById('file-select-text');
    const addFileBtn = document.getElementById('add-file-btn');
    const fileListTable = document.getElementById('file-list-table');
    const selectedFilesContainer = document.getElementById('selected-files-container');
    const validationMessage = document.getElementById('validation-message');
    const uploadBtn = document.getElementById('upload-btn');
    
    // Array to store selected files with their data
    const selectedFiles = [];
    
    // When file is selected in the file input
    fileInput.addEventListener('change', async (e) => {
      validationMessage.style.display = 'none';
      
      if (fileInput.files.length > 0) {
        const file = fileInput.files[0];
        fileSelectText.textContent = file.name;
        
        // Check file size
        if (file.size > 3 * 1024 * 1024) {
          validationMessage.textContent = 'File exceeds 3MB size limit';
          validationMessage.style.display = 'block';
          addFileBtn.disabled = true;
          return;
        }
        
        // Check file extension
        if (!file.name.toLowerCase().endsWith('.wav')) {
          validationMessage.textContent = 'Only WAV files are accepted';
          validationMessage.style.display = 'block';
          addFileBtn.disabled = true;
          return;
        }
        
        addFileBtn.disabled = false;
      } else {
        fileSelectText.textContent = 'No file selected';
        addFileBtn.disabled = true;
      }
    });
    
    // Add file button click
    addFileBtn.addEventListener('click', async () => {
      if (fileInput.files.length === 0) return;
      
      const file = fileInput.files[0];
      
      // Check if we already have 4 files
      if (selectedFiles.length >= 4) {
        validationMessage.textContent = 'Maximum 4 files allowed';
        validationMessage.style.display = 'block';
        return;
      }
      
      // Check if file with same name already exists
      if (selectedFiles.some(f => f.name === file.name)) {
        validationMessage.textContent = 'A file with this name is already added';
        validationMessage.style.display = 'block';
        return;
      }
      
      try {
        // Read file as base64
        const base64 = await readFileAsBase64(file);
        
        // Add file to our array
        selectedFiles.push({
          name: file.name,
          size: file.size,
          data: base64
        });
        
        // Add to UI
        addFileToTable(file);
        
        // Reset file input
        fileInput.value = '';
        fileSelectText.textContent = 'No file selected';
        addFileBtn.disabled = true;
        
        // Show container if this is the first file
        if (selectedFiles.length === 1) {
          selectedFilesContainer.style.display = 'block';
        }
        
        // Enable upload button if we have files
        updateUploadButtonState();
      } catch (error) {
        console.error('Error reading file:', error);
        validationMessage.textContent = 'Error reading file';
        validationMessage.style.display = 'block';
      }
    });
    
    // Function to read file as base64
    function readFileAsBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }
    
    // Function to add a file to the table
    function addFileToTable(file) {
      const row = document.createElement('tr');
      row.id = `file-row-${file.name.replace(/[^a-z0-9]/gi, '-')}`;
      
      const sizeKB = (file.size / 1024).toFixed(1);
      
      row.innerHTML = `
        <td>${file.name}</td>
        <td>${sizeKB} KB</td>
        <td>
          <button type="button" class="file-action-btn remove-file-btn" data-filename="${file.name}">
            Remove
          </button>
        </td>
      `;
      
      fileListTable.appendChild(row);
      
      // Add event listener to remove button
      row.querySelector('.remove-file-btn').addEventListener('click', function() {
        const filename = this.getAttribute('data-filename');
        removeFile(filename);
      });
    }
    
    // Function to remove a file
    function removeFile(filename) {
      // Remove from array
      const index = selectedFiles.findIndex(f => f.name === filename);
      if (index > -1) {
        selectedFiles.splice(index, 1);
      }
      
      // Remove from UI
      const row = document.getElementById(`file-row-${filename.replace(/[^a-z0-9]/gi, '-')}`);
      if (row) {
        row.remove();
      }
      
      // Hide container if no files left
      if (selectedFiles.length === 0) {
        selectedFilesContainer.style.display = 'none';
      }
      
      // Update upload button state
      updateUploadButtonState();
    }
    
    // Update upload button enabled/disabled state
    function updateUploadButtonState() {
      uploadBtn.disabled = selectedFiles.length === 0;
    }
    
    // Handle upload button click - send data via AJAX
    uploadBtn.addEventListener('click', async () => {
      if (selectedFiles.length === 0) {
        validationMessage.textContent = 'Please add at least one file';
        validationMessage.style.display = 'block';
        return;
      }
      
      // Show loading state
      uploadBtn.disabled = true;
      uploadBtn.innerHTML = '<span class="loading"></span> Uploading...';
      
      try {
        // Send files to server
        const response = await fetch('/api/v1/character/voice-upload', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ files: selectedFiles })
        });
        
        // Handle response
        if (response.redirected) {
          window.location.href = response.url;
        } else {
          const data = await response.json();
          if (data.success) {
            window.location.href = '/web/character?success=Voice+files+uploaded+successfully';
          } else {
            validationMessage.textContent = data.error || 'Upload failed';
            validationMessage.style.display = 'block';
            uploadBtn.disabled = false;
            uploadBtn.textContent = 'Upload Voice Samples';
          }
        }
      } catch (error) {
        console.error('Upload error:', error);
        validationMessage.textContent = 'Error uploading files';
        validationMessage.style.display = 'block';
        uploadBtn.disabled = false;
        uploadBtn.textContent = 'Upload Voice Samples';
      }
    });
  });
</script>
{% endblock %}
</file>

<file path="config-helper.js">
import fs from "fs-extra";
import path from "path";
import { fileURLToPath } from "url";
import { dirname } from "path";
import levenshtein from "fast-levenshtein";
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const configFilePath = path.join(__dirname, "./config/config.json");
let configCache = null;
let originalConfigTypes = {}; // Store original data types

/**
 * Loads the configuration file into memory.
 * @returns {Promise<void>}
 */
async function loadConfig() {
  if (configCache) return configCache;  // Prevent loading if already loaded
  
  try {
    configCache = await fs.readJSON(configFilePath)
    await storeOriginalTypes(configCache)
    return configCache
  } catch (err) {
    configCache = {}
    return configCache;
  }
}

/**
 * Converts a string value to the original type.
 * @param {string} value - The user input value as a string.
 * @param {string} originalType - The expected type (e.g., "number", "boolean").
 * @returns {any} - The converted value.
 */
function convertValueToOriginalType(value, originalType) {
  switch (originalType) {
    case "number":
      return parseFloat(value);
    case "boolean":
      return value === "true" || value === "1" || value === 1 || value === true;
    case "string":
      return value;
    default:
      return value;
  }
}

function findClosestKey(inputPath, config, threshold = 2) {
  const keys = extractAllPaths(config);
  const lowerInputPath = inputPath.toLowerCase();

  const exactMatch = keys.find(key => key.toLowerCase() === lowerInputPath);
  if (exactMatch) return exactMatch;

  const closestMatch = keys.reduce(
    (bestMatch, key) => {
      const distance = levenshtein.get(lowerInputPath, key.toLowerCase());
      if (distance < bestMatch.distance) {
        return { key, distance };
      }
      return bestMatch;
    },
    { key: null, distance: Infinity }
  );

  return closestMatch.distance <= threshold ? closestMatch.key : null;
}

function extractAllPaths(obj, parentKey = "") {
  let paths = [];
  for (const key in obj) {
    const fullPath = parentKey ? `${parentKey}.${key}` : key;
    if (typeof obj[key] === "object" && obj[key] !== null) {
      paths = paths.concat(extractAllPaths(obj[key], fullPath));
    } else {
      paths.push(fullPath);
    }
  }
  return paths;
}

/**
 * Saves a value to the configuration and writes it to disk.
 * @param {string} path - The path to the value to save (e.g., "samplers.topK").
 * @param {string} userInput - The user-provided value as a string.
 * @returns {Promise<boolean>} - A promise that resolves to true if successful, false otherwise.
 */
async function saveConfigValue(path, userInput) {
  if (!configCache) {
    await loadConfig();
  }

  const inferredPath = findClosestKey(path, configCache);
  if (!inferredPath) {
    return false;
  }

  const pathParts = inferredPath.split(".");
  let obj = configCache;
  for (let i = 0; i < pathParts.length - 1; i++) {
    const part = pathParts[i];
    if (!obj[part] || typeof obj[part] !== "object") {
      obj[part] = {};
    }
    obj = obj[part];
  }

  const key = pathParts[pathParts.length - 1];
  const originalType = originalConfigTypes[inferredPath];

  if (!originalType) {
    throw new Error(`Unknown configuration path: ${inferredPath}`);
  }

  let convertedValue;
  try {
    convertedValue = convertValueToOriginalType(userInput, originalType);
  } catch (error) {
    return false;
  }

  obj[key] = convertedValue;

  try {
    await saveConfigToDisk()
    await reloadConfig()
    return true;
  } catch (error) {
    return false;
  }
}

async function storeOriginalTypes(obj, parentKey = "") {
  for (const key in obj) {
    const value = obj[key];
    const fullPath = parentKey ? `${parentKey}.${key}` : key;

    if (typeof value === "object" && value !== null) {
      await storeOriginalTypes(value, fullPath);
    } else {
      originalConfigTypes[fullPath] = typeof value;
    }
  }
}

async function reloadConfig() {
  configCache = null;
  await loadConfig();
}


/**
 * Retrieves a value from the configuration using a dot notation path.
 * @param {string} path - The path to the desired value (e.g., "samplers.topK").
 * @returns {Promise<any>} - A promise that resolves to the value at the specified path, or undefined if not found.
 */
async function retrieveConfigValue(path) {
  await reloadConfig();
  const pathParts = path.split(".");
  let value = configCache;
  for (const part of pathParts) {
    if (value[part] === undefined) {
      return undefined; // Value not found
    }
    value = value[part];
  }
  if (typeof value === "object" && value !== null) {
    return value;
  }
  // Get the original type from the stored types
  const originalType = originalConfigTypes[path];

  // Convert the value to the original type if possible
  if (originalType) {
      try {
          return convertValueToOriginalType(value, originalType);
      } catch (error) {
          return value;
      }
  } else {
      // If no original type is found, return the value as is
      return value;
  }
}


/**
 * Writes the current configuration to disk.
 * @returns {Promise<void>}
 */
async function saveConfigToDisk() {
  try {
    if (configCache) {
      await fs.writeJSON(configFilePath, configCache, { spaces: 2 });
    } else {
    }
  } catch (error) {
  }
}

export { loadConfig, retrieveConfigValue, saveConfigToDisk, saveConfigValue };
</file>

<file path="token-helper.js">
import fs from "fs";
import path from "path";
import { Tokenizer } from "tokenizers";
import axios, { AxiosHeaders } from "axios";
import { retrieveConfigValue } from "./config-helper.js";

const tokenizerJsons = {};
const tokenizerInstances = {}; // Cache for Tokenizer instances

export const preloadAllTokenizers = () => {
  const resourcesPath = "./resources";
  const modelDirectories = fs
    .readdirSync(resourcesPath)
    .filter((file) =>
      fs.statSync(path.join(resourcesPath, file)).isDirectory(),
    );
  for (const modelDir of modelDirectories) {
    const tokenizerFilePath = path.join(resourcesPath, modelDir, "tokenizer.json");
    if (fs.existsSync(tokenizerFilePath)) {
      try {
        const tokenizerContent = fs.readFileSync(tokenizerFilePath, "utf-8");
        tokenizerJsons[modelDir] = tokenizerContent;
      } catch (error) {
        logger.log("Tokenizer", `Failed to load tokenizer for model ${modelDir}: ${error.message}`, "err");
      }
    } else {
      logger.log("Tokenizer", `Tokenizer file not found for model: ${modelDir}`, "err");
    }
  }
  logger.log("Tokenizer", `Loaded tokenizers: ${Object.keys(tokenizerJsons).join(", ")}`);
};

export const getTokenizerInstance = async (model) => {
  if (tokenizerInstances[model]) {
    return tokenizerInstances[model];
  }
  const tokenizerJson = tokenizerJsons[model];
  if (!tokenizerJson) {
    logger.log("Tokenizer", `Tokenizer JSON not found for model: ${model}`, "err");
    return null;
  }
  try {
    const instance = await Tokenizer.fromString(tokenizerJson);
    tokenizerInstances[model] = instance;
    return instance;
  } catch (error) {
    logger.log("Tokenizer", `Error creating tokenizer for model ${model}: ${error.message}`, "err");
    return null;
  }
};


export const getTokenizerJson = async (model) => tokenizerJsons[model];

export const getPromptCount = async (
  systemPrompt,
  userPrompt,
  modelType,
  contextPrompt = "",
) => {
  const tokenizerJson = await getTokenizerJson(modelType);
  if (!tokenizerJson) {
    logger.log(
      "Tokenizer",
      `Tokenizer not found for model type: ${modelType}`,
      "err",
    );
  }
  try {
    const tokenizer = await Tokenizer.fromString(tokenizerJson);

    const systemEncoded = await tokenizer.encode(JSON.stringify(systemPrompt));
    const userEncoded = await tokenizer.encode(JSON.stringify(userPrompt));
    const contextEncoded = contextPrompt
      ? await tokenizer.encode(JSON.stringify(contextPrompt))
      : { getLength: () => 0 };
    const tokenCount =
      systemEncoded.getLength() +
      userEncoded.getLength() +
      contextEncoded.getLength();
    return tokenCount;
  } catch (error) {
    logger.log(
      "error",
      `Error during tokenization for model ${modelType}: ${error.message}`,
    );
  }
};

export const getPromptTokens = async (
  requestBody,
  modelType
) => {
  const tokenizerJson = await getTokenizerJson(modelType);
  if (!tokenizerJson) {
    logger.log(
      "Tokenizer",
      `Tokenizer not found for model type: ${modelType}`,
      "err",
    );
  }
  try {
    const tokenizer = await Tokenizer.fromString(tokenizerJson);

    let totalTokens = 0
    for await (const message of requestBody.messages) {
      const messageContent = await tokenizer.encode(message.content)
      totalTokens += messageContent.getLength()
    }
    return totalTokens;
  } catch (error) {
    logger.log(
      "error",
      `Error during tokenization for model ${modelType}: ${error.message}`,
    );
  }
};

export const getOutputTokens = async (
  message,
  modelType
) => {
  const tokenizerJson = await getTokenizerJson(modelType);
  if (!tokenizerJson) {
    logger.log(
      "Tokenizer",
      `Tokenizer not found for model type: ${modelType}`,
      "err",
    );
  }
  try {
    const tokenizer = await Tokenizer.fromString(tokenizerJson);
    let totalTokens = 0
    const messageContent = await tokenizer.encode(message)
    totalTokens += messageContent.getLength()
    return totalTokens;
  } catch (error) {
    logger.log(
      "error",
      `Error during tokenization for model ${modelType}: ${error.message}`,
    );
  }
};

export const tokenizedFromRemote = async (message) => {
  const tokenizerUrl = await retrieveConfigValue("models.chat.endpoint") + "/tokenize"
  const modelName = await retrieveConfigValue("models.chat.model")
  try {
    const response = await axios.post(tokenizerUrl,
      {
        model: `${modelName}`,
        prompt: `${message}`
      },
      { 
        headers: {
          'Content-Type': 'application/json',
          'Accept-Encoding': 'gzip, deflate, br'
        },
      }
    )
    return response.data.count;
  } catch (error) {
    logger.log(
      "error",
      `Error during tokenization for model ${await retrieveConfigValue("models.chat.model")}: ${error.message}`,
    );
  }
}

export const promptTokenizedFromRemote = async (message) => {
  const tokenizerUrl = await retrieveConfigValue("models.chat.endpoint") + "/tokenize"
  const modelName = await retrieveConfigValue("models.chat.model")
  try {
    const response = await axios.post(tokenizerUrl,
      {
        model: `${modelName}`,
        messages: message
      },
      { 
        headers: {
          'Content-Type': 'application/json',
          'Accept-Encoding': 'gzip, deflate, br'
        },
      }
    )
    return response.data.count;
  } catch (error) {
    logger.log(
      "error",
      `Error during tokenization for model ${await retrieveConfigValue("models.chat.model")}: ${error.message}`,
    );
  }
}
</file>

<file path="config/config.example.json">
{
  "server": {
    "cookieSecret": "",
    "authFilePath": "./auth/auth_keys.json",
    "port": 3002,
    "authRequired": true,
    "endpoints": {
      "external": "http://localhost:3002",
      "internal": "::"
    },
    "externalScraper": {
      "enabled": false,
      "endpoint": "",
      "deviceType": "",
      "caching": ""
    }
  },
  "brave": {
    "apiKey": ""
  },
  "milvus": {
    "collections": {
      "intelligence": "",
      "voice": "",
      "chat": "",
      "user": ""
    },
    "endpoint": "",
    "localTextDirectory": "./data"
  },
  "twitch": {
    "maxChatsToSave": 40,
    "maxCharLimit": 500,
    "clientId": "",
    "clientSecret": "",
    "redirectUri": "",
    "scopes": {
      "streamer": [
        "bits:read",
        "analytics:read:games",
        "analytics:read:extensions",
        "channel:edit:commercial",
        "channel:read:subscriptions",
        "channel:read:hype_train",
        "channel:read:goals",
        "channel:read:redemptions",
        "channel:read:charity",
        "channel:read:polls",
        "channel:read:predictions",
        "channel:manage:broadcast",
        "channel:manage:raids",
        "channel:manage:ads",
        "channel:manage:raids",
        "channel:moderate",
        "channel:read:stream_key",
        "chat:read",
        "moderator:read:followers",
        "moderator:read:chatters",
        "user:write:chat"
      ],
      "bot": [
        "bits:read",
        "chat:read",
        "chat:edit",
        "moderator:read:chatters",
        "moderator:read:followers",
        "moderator:read:shoutouts",
        "moderator:manage:announcements",
        "moderator:read:suspicious_users",
        "moderator:manage:chat_messages",
        "moderator:read:guest_star",
        "moderator:manage:guest_star",
        "moderator:read:moderators",
        "moderator:manage:shoutouts",
        "user:read:email",
        "user:read:chat",
        "user:write:chat"
      ]
    }
  },
  "models": {
    "summary": {
      "enabled": true,
      "endpoint": "",
      "apiKey": "",
      "model": "",
      "modelType": "",
      "maxTokens": 131072
    },
    "query": {
      "endpoint": "",
      "apiKey": "",
      "model": "",
      "modelType": "",
      "maxTokens": 4096
    },
    "chat": {
      "author": "",
      "organization": "",
      "endpoint": "",
      "apiKey": "",
      "model": "",
      "modelType": "",
      "maxTokens": 12288
    },
    "embedding": {
      "endpoint": "1",
      "apiKey": "",
      "apiKeyType": "",
      "model": "",
      "dimensions": 1024,
      "embeddingType": ""
    },
    "rerank": {
      "endpoint": "",
      "apiKey": "",
      "apiKeyType": "",
      "model": ""
    },
    "classifier": {
      "endpoint": "",
      "apiKey": "",
      "apiKeyType": "",
      "model": ""
    },
    "conversion": {
      "endpoint": "",
      "apiKey": "",
      "model": "",
      "modelType": "",
      "maxTokens": 131072
    },
    "rerankTransform": {
      "endpoint": "",
      "apiKey": "",
      "model": "",
      "modelType": "",
      "maxTokens": 4096
    },
    "moderator": {
      "endpoint": "",
      "apiKey": "",
      "apiKeyType": "",
      "model": "",
      "modelType": "",
      "maxTokens": 4096
    }
  },
  "samplers": {
    "chat": {
      "topK": -1,
      "maxTokens": 1024,
      "generateWindow": 1024,
      "topP": 0.95,
      "typicalP": 1,
      "minP": 0.05,
      "temperature": 0.1,
      "minTokens": 90,
      "repetitionPenalty": 1,
      "presencePenalty": 1,
      "xtcThreshold": 0.1,
      "xtcProbability": 0.2,
      "dynTemp": true,
      "dynTempMin": 0.07,
      "dynTempMax": 0.13
    },
    "tool": {
      "topK": -1,
      "topP": 0.9,
      "minP": 0.05,
      "temperature": 0.4,
      "maxTokens": 1024,
      "generateWindow": 1024
    }
  },
  "funFacts": {
    "key": ""
  },
  "ttsPreference": "",
  "alltalk": {
    "ttsGenEndpoint": {
      "internal": "",
      "external": ""
    },
    "ttsServeEndpoint": {
      "internal": "",
      "external": ""
    },
    "healthcheck": {
      "internal": "",
      "external": ""
    }
  },
  "fishTTS": {
    "ttsGenEndpoint": {
      "internal": "",
      "external": ""
    },
    "ttsServeEndpoint": {
      "internal": "",
      "external": ""
    },
    "healthcheck": {
      "internal": "",
      "external": ""
    }
  }
}
</file>

<file path="logger.js">
// logger.js - Updated with fixed error handling
import moment from "moment";
import fs from 'fs/promises';

// Create logs directory if it doesn't exist
try {
  await fs.mkdir('./logs', { recursive: true });
} catch (err) {
  // Directory likely already exists, ignore
}

export const createLogger = (
  withUI = false,
  logBox = null,
  screen = null,
) => {
  const getTimestamp = () => moment().format("MM/DD/YY [at] HH:mm");

  const formatLogMessage = (source, message) => {
    const timestamp = getTimestamp();
    const formattedMessage =
      typeof message === "string" ? message : JSON.stringify(message);
    return `{gray-fg}${timestamp}{/} [${source}] ${formattedMessage}`;
  };

  const logToScreen = (source, message) => {
    if (withUI && logBox && screen) {
      const formattedLog = formatLogMessage(source, message);
      logBox.pushLine(formattedLog);
      screen.render();
    }
  };

  const logToFile = async (source, message, type) => {
    try {
      const timestamp = getTimestamp();
      const formattedMessage = typeof message === "string" ? message : JSON.stringify(message);
      const logEntry = `${timestamp} [${source}] [${type}] ${formattedMessage}\n`;
      
      // Append to daily log file
      const today = moment().format('YYYY-MM-DD');
      await fs.appendFile(`./logs/${today}.log`, logEntry);
      
      // Also append to type-specific log if it's an error or warning
      if (type === 'error' || type === 'warn') {
        await fs.appendFile(`./logs/${type}.log`, logEntry);
      }
    } catch (err) {
      // If we can't log to file, at least try to show it on screen
      if (withUI && logBox && screen) {
        logBox.pushLine(`{red-fg}Error writing to log file: ${err.message}{/}`);
        screen.render();
      }
    }
  };

  const writeTrace = async (trace, dest) => {
    try {
      await fs.writeFile(`./logs/${dest}`, trace + '\n');
    } catch (err) {
      if (withUI && logBox && screen) {
        logBox.pushLine(`{red-fg}Error writing trace to file: ${err.message}{/}`);
        screen.render();
      }
    }
  };

  const logMessage = (source, message, type = "info") => {
    // Log to UI
    logToScreen(source, message);
    
    // Log to file
    logToFile(source, message, type);
  };

  return {
    log: (source, message, type = "info") => logMessage(source, message, type),
    system: (message) => logMessage("System", message, "info"),
    error: (source, message) => logMessage(source, message, "error"),
    warn: (source, message) => logMessage(source, message, "warn"),
    info: (source, message) => logMessage(source, message, "info"),
    debug: (source, message) => logMessage(source, message, "debug"),
    trace: (trace, dest) => writeTrace(trace, dest)
  };
};

// Get the global logger if available, otherwise create a basic one
export function getLogger() {
  if (global._sharedObjects && global._sharedObjects.logger) {
    return global._sharedObjects.logger;
  }
  
  if (global.logger) {
    return global.logger;
  }
  
  // Fallback logger
  return createLogger(false);
}

// Export a shared logger instance to be used by modules
export const logger = getLogger();
</file>

<file path="main.js">
// main.js - Main application file without using cluster
import blessed from "neo-blessed";
import { createLogger } from "./logger.js";
import * as aiHelper from "./ai-logic.js";
import { saveAuthToDisk, updateUserParameter } from "./api-helper.js";
import { saveConfigToDisk, retrieveConfigValue, saveConfigValue } from "./config-helper.js";
import { fork } from "child_process";

// Capture original console methods
const originalConsole = {
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error,
  debug: console.debug
};

// Setup the UI
const screen = blessed.screen({
  fastCSR: true,
  terminal: "xterm-256color",
  fullUnicode: true,
  dockBorders: true,
  autoPadding: true,
  ignoreDockContrast: false,
});

// Set application title
screen.title = "🌟 Enspira";

// Create UI components
const statusBar = blessed.box({
  top: 0,
  left: 0,
  width: "100%",
  height: 1,
  border: {
    type: "line",
  },
  style: {
    border: {
      fg: "green",
    },
  },
});

const servicesText = blessed.text({
  parent: statusBar,
  top: 0,
  left: 1,
  content: "{bold}Services: {gray-fg}?{/gray-fg}{/bold}",
  tags: true,
});

const apiStatusText = blessed.text({
  parent: statusBar,
  left: `69%`,
  top: 0,
  content: "{left}REST: {gray-fg}?{/gray-fg}{/left}",
  tags: true,
});

const dbStatus = blessed.text({
  parent: statusBar,
  left: `80%`,
  top: 0,
  content: "{left}DB: {gray-fg}?{/gray-fg}{/left}",
  tags: true,
});

const llmStackStatus = blessed.text({
  parent: statusBar,
  left: `90%`,
  top: 0,
  content: "{left}LLM: {gray-fg}?{/gray-fg}{/left}",
  tags: true,
});

const logBox = blessed.log({
  top: 3,
  left: 0,
  bottom: 6,
  width: "100%",
  height: `97%-${statusBar.height + 3}`,
  label: "Logs",
  border: {
    type: "line",
  },
  style: {
    border: {
      fg: "cyan",
    },
  },
  tags: true,
  scrollable: true,
  alwaysScroll: true,
  scrollbar: {
    ch: " ",
    track: {
      bg: "grey",
    },
    style: {
      inverse: true,
    },
  },
  keys: true,
  mouse: true,
  vi: true,
});

const inputBar = blessed.textbox({
  bottom: 0,
  left: 0,
  width: "100%",
  height: 3,
  label: "Command",
  border: {
    type: "line",
  },
  style: {
    border: {
      fg: "magenta",
    },
  },
  inputOnFocus: true,
});

// Add components to screen
screen.append(logBox);
screen.append(inputBar);
screen.append(statusBar);

// Create the logger and set it globally
const logger = createLogger(true, logBox, screen);
global.logger = logger;

// Make logger available as a module export for other modules to import
if (!global._sharedObjects) {
  global._sharedObjects = {};
}
global._sharedObjects.logger = logger;

console.log = (...args) => logger.log("Console", args.join(' '));
console.info = (...args) => logger.info(args.join(' '));
console.warn = (...args) => logger.warn(args.join(' '));
console.error = (...args) => logger.error(args.join(' '));
console.debug = (...args) => logger.debug(args.join(' '));

// Setup status bar update function
function updateStatusBar(apiActive = false, dbConnected = false, llmStackConnected = 0) {
  try {
    const apiStatus = apiActive
      ? "{left}REST: {green-fg}✓{/green-fg} Up{/left}"
      : "{left}REST: {red-fg}❌{/red-fg} Down{/left}";

    // Update DB status
    try {
      if (dbStatus) {
        screen.clearRegion(
          dbStatus.left,
          dbStatus.top,
          dbStatus.width,
          dbStatus.height
        );
        dbStatus.setContent(dbConnected
          ? `{left}DB: {green-fg}✓{/green-fg} Up{/left}`
          : `{left}DB: {red-fg}❌{/red-fg} Down{/left}`
        );
      }
    } catch (dbError) {
      logger.error("UI", `Error updating DB status: ${dbError.message}`);
    }

    // Update LLM stack status
    try {
      if (servicesText && llmStackStatus) {
        switch (llmStackConnected) {
          case 0:
            screen.title = "🌟 [DOWN] Enspira";
            servicesText.setContent(`{bold}Services: {red-fg}Down{/red-fg}{/bold}`);
            llmStackStatus.setContent(`{left}LLM: {red-fg}❌{/red-fg} Down{/left}`);
            break;
          case 1:
            screen.title = "🌟 [DEGRADED] Enspira";
            servicesText.setContent(`{bold}Services: {yellow-fg}Degraded{/yellow-fg}{/bold}`);
            llmStackStatus.setContent(`{left}LLM: {yellow-fg}⚠{/yellow-fg}{/left}`);
            break;
          case 2:
            screen.title = "🌟 [HEALTHY] Enspira";
            servicesText.setContent(`{bold}Services: {green-fg}All Online{/green-fg}{/bold}`);
            llmStackStatus.setContent(`{left}LLM: {green-fg}✓{/green-fg} Up{/left}`);
            break;
          default:
            break;
        }
      }
    } catch (llmError) {
      logger.error("UI", `Error updating LLM status: ${llmError.message}`);
    }

    // Update API status
    try {
      if (apiStatusText) {
        apiStatusText.setContent(apiStatus);
      }
    } catch (apiError) {
      logger.error("UI", `Error updating API status: ${apiError.message}`);
    }

    // Render screen only once at the end
    try {
      screen.render();
    } catch (renderError) {
      logger.error("UI", `Error rendering screen: ${renderError.message}`);
    }
  } catch (error) {
    logger.error("UI", `Error in updateStatusBar: ${error.message}`);
    // Don't propagate UI errors
  }
}

// Handle scrolling and navigation events
logBox.on("wheelup", () => {
  logBox.scroll(-1);
  screen.render();
});

logBox.on("wheeldown", () => {
  logBox.scroll(1);
  screen.render();
});

logBox.key(["pageup"], () => {
  logBox.scroll(-logBox.height);
  screen.render();
});

logBox.key(["pagedown"], () => {
  logBox.scroll(logBox.height);
  screen.render();
});

logBox.key(["enter"], () => {
  inputBar.focus();
  screen.render();
});

screen.key(["i"], () => {
  inputBar.focus();
  inputBar.readInput();
  screen.render();
});

screen.key(["up", "down"], () => {
  logBox.focus();
  screen.render();
});

// Variable to track whether we're shutting down
let isShuttingDown = false;

// Function to reset the app module cache
function clearModuleCache() {
  Object.keys(require.cache).forEach(function (key) {
    if (!key.includes('node_modules')) {
      delete require.cache[key];
    }
  });
}

// Application restart function
async function restartApplication() {
  logger.log("System", "Restarting application...");

  // Clean up and save anything important
  await saveAuthToDisk();
  await saveConfigToDisk();

  // For ES modules, we'll use a different approach with child_process
  const restartProcess = fork('./restart-helper.js', [], {
    detached: true,
    stdio: 'ignore'
  });

  restartProcess.unref();
  process.exit(0);
}

// Function to perform a clean shutdown
async function shutdown() {
  if (isShuttingDown) return;

  isShuttingDown = true;
  logger.log("System", "Saving data before shutdown...");

  try {
    await saveAuthToDisk();
    await saveConfigToDisk();
    logger.log("System", "All data saved. Shutting down...");

    // Give time for message to display
    setTimeout(() => {
      process.exit(0);
    }, 500);
  } catch (error) {
    logger.error("System", `Error during shutdown: ${error.message}`);
    process.exit(1);
  }
}

// Handle command input
inputBar.on("submit", async (text) => {
  if (!text.trim()) {
    inputBar.clearValue();
    screen.render();
    return;
  }

  const firstWord = text.trim().split(/\s+/)[0].toLowerCase();
  const args = text.trim().slice(firstWord.length).trim();

  inputBar.clearValue();
  screen.render();

  try {
    switch (firstWord) {
      case "exit":
        shutdown();
        break;

      case "restart":
        logger.log("System", "Restarting framework...");
        restartApplication();
        break;

      case "flush_chat":
        await saveChatContextToDisk(args);
        break;

      case "setpass":
        if (!args) {
          logger.log("System", `Please specify a user ID and password.`);
          break;
        }

        const passArgs = args.split(' ');
        if (passArgs.length < 2) {
          logger.log("System", `Please provide both a user ID and password.`);
          break;
        }

        const userIds = passArgs[0];
        const plainPassword = passArgs.slice(1).join(' '); // Handle passwords with spaces

        try {
          // Import hashPassword function from routes/v1.js
          const { hashPassword } = await import('./routes/v1.js');
          const passwordData = await hashPassword(plainPassword);

          // Update user parameters with hashed password data
          const hashUpdate = await updateUserParameter(
            userIds,
            "webPasswordHash",
            passwordData.hash
          );

          const saltUpdate = await updateUserParameter(
            userIds,
            "webPasswordSalt",
            passwordData.salt
          );

          const iterUpdate = await updateUserParameter(
            userIds,
            "webPasswordIterations",
            passwordData.iterations
          );

          if (hashUpdate && saltUpdate && iterUpdate) {
            logger.log("System", `Password updated successfully for user ${userIds}`);
          } else {
            logger.log("System", `Failed to update password for user ${userIds}`);
          }
        } catch (passError) {
          logger.error("System", `Error setting password: ${passError.message}`);
        }
        break;

      case "test_chats":
        const testChats = await aiHelper.returnRecentChats(args, true);
        logger.log("Milvus", `Got the following content: ${JSON.stringify(testChats.chatList)} in ${testChats.executionTime} seconds.`);
        break;

      case "reload_db":
        if (!args) {
          logger.log("System", `Please specify a database to reload.`);
          break;
        }

        const items = args.split(" ");
        const collectionName = items[0];
        const userId = items[1];

        logger.log("System", `Issuing reload DB command...`);
        const done = await aiHelper.weGottaGoBald(collectionName, userId);

        if (done) {
          logger.log("System", `Database reload initiated.`);
        } else {
          logger.log("System", `Database reload failed.`);
        }
        break;

      case "get":
        if (!args) {
          logger.log("System", `Please specify a setting to retrieve.`);
          break;
        }

        const getSetValue = await retrieveConfigValue(args);
        logger.log("System", `'${args}' is set to: ${typeof (getSetValue) === "object" ?
          `${JSON.stringify(getSetValue, { spaces: 2 })}` : `${getSetValue}`}`);
        break;

      case "set":
        if (!args) {
          logger.log("System", `Please specify a setting and value to set.`);
          break;
        }

        const choices = args.split(' ');
        if (choices.length < 2) {
          logger.log("System", `Please provide both a setting name and value.`);
          break;
        }

        const didSave = await saveConfigValue(choices[0], choices[1]);
        didSave ?
          logger.log("Config", `Value '${choices[1]}' for parameter '${choices[0]}' saved.`) :
          logger.log("Config", `Value '${choices[1]}' for parameter '${choices[0]}' failed to save.`);
        break;

      case "setuser":
        if (!args) {
          logger.log("System", `Please specify a user, setting, and value.`);
          break;
        }

        const userChoices = args.split(' ');
        if (userChoices.length < 3) {
          logger.log("System", `Please provide a user ID, setting name, and value.`);
          break;
        }

        const updated = await updateUserParameter(userChoices[0], userChoices[1], userChoices[2]);
        updated ?
          logger.log("Config", `Value '${userChoices[2]}' for parameter '${userChoices[1]}' for user '${userChoices[0]}' saved.`) :
          logger.log("Config", `Value '${userChoices[2]}' for parameter '${userChoices[1]}' for user '${userChoices[0]}' failed to save.`);
        break;

      case "augment":
        logger.log("System", `Sending augmentation request...`);
        const augArgs = args.split(' ');
        if (augArgs.length < 2) {
          logger.log("System", `Please provide both a query and subject.`);
          break;
        }
        await manualRetrieveWebContext(augArgs[0], augArgs[1]);
        break;

      case "reindex":
        logger.log("System", "Issuing RAG rebuild...");
        if (!args) {
          logger.log("System", `Please specify a user ID.`);
          break;
        }
        await aiHelper.startIndexingVectors(args);
        break;

      case "infer":
        if (!args) {
          logger.log("System", "Please enter a search inference");
          break;
        }
        logger.log("LLM", `Generating inference optimized search for term ${args}`);
        await aiHelper.inferSearchParam(args);
        break;

      default:
        logger.log("System", `Invalid command '${firstWord}'. Try again.`);
        break;
    }
  } catch (error) {
    logger.error("System", `Error executing command: ${error.message}`);
  }

  logBox.focus();
});

// Handle confirmation dialog setup
const showConfirmationBox = (title, message) => {
  return new Promise((resolve) => {
    const boxWidth = Math.floor(screen.width * 0.8);

    const lines = message.split("\n").reduce((acc, line) => {
      const wrappedLines = Math.ceil(line.length / (boxWidth - 4));
      return acc + wrappedLines;
    }, 0);

    const boxHeight = Math.min(lines + 5, Math.floor(screen.height * 0.5));
    const buttonHeight = 3;
    const totalHeight = boxHeight + buttonHeight;

    const confirmBox = blessed.box({
      parent: screen,
      border: "line",
      height: totalHeight,
      width: boxWidth,
      top: Math.floor((screen.height - totalHeight) / 2),
      left: Math.floor((screen.width - boxWidth) / 2),
      label: ` {bold}${title}{/bold} `,
      tags: true,
      keys: true,
      vi: true,
      style: {
        border: {
          fg: "yellow",
        },
        focus: {
          border: {
            fg: "green",
          },
        },
      },
    });

    const messageText = blessed.text({
      parent: confirmBox,
      content: message,
      top: 1,
      left: 1,
      shrink: true,
      width: boxWidth - 4,
      style: {
        fg: "white",
      },
    });

    const yesButton = blessed.button({
      parent: confirmBox,
      mouse: true,
      keys: true,
      shrink: true,
      padding: {
        left: 1,
        right: 1,
      },
      left: Math.floor(boxWidth * 0.25),
      top: totalHeight - buttonHeight + 1,
      name: "yes",
      content: "Yes",
      style: {
        bg: "green",
        focus: {
          bg: "white",
          fg: "black",
        },
      },
    });

    const noButton = blessed.button({
      parent: confirmBox,
      mouse: true,
      keys: true,
      shrink: true,
      padding: {
        left: 1,
        right: 1,
      },
      left: Math.floor(boxWidth * 0.55),
      top: totalHeight - buttonHeight + 1,
      name: "no",
      content: "No",
      style: {
        bg: "red",
        focus: {
          bg: "white",
          fg: "black",
        },
      },
    });

    yesButton.on("press", () => {
      confirmBox.destroy();
      screen.render();
      resolve(true);
    });

    noButton.on("press", () => {
      confirmBox.destroy();
      screen.render();
      resolve(false);
    });

    yesButton.key(["tab"], () => {
      noButton.focus();
    });

    noButton.key(["tab"], () => {
      yesButton.focus();
    });

    confirmBox.key(["enter"], () => {
      if (yesButton.hasFocus()) {
        yesButton.emit("press");
      } else {
        noButton.emit("press");
      }
    });

    yesButton.focus();

    yesButton.on("focus", () => {
      yesButton.style.bg = "white";
      yesButton.style.fg = "black";
      noButton.style.bg = "red";
      noButton.style.fg = "white";
    });

    noButton.on("focus", () => {
      noButton.style.bg = "white";
      noButton.style.fg = "black";
      yesButton.style.bg = "green";
      yesButton.style.fg = "white";
    });

    screen.render();
  });
};

// Handle process shutdown gracefully
process.on("SIGTERM", shutdown);
process.on("SIGINT", shutdown);

// Initialize and run the application
async function initializeApp() {
  try {
    // Log application startup
    logger.log("System", "Enspira application starting...");
    // Import and start the API server
    const { initializeApp: startApp } = await import('./index.js');

    // Start the application and get the server and status
    logger.log("System", "Starting REST server and initializing services...");
    const { server, status } = await startApp();

    // Process preflight status
    let failed = 0;
    let available = 0;
    Object.keys(status.llmStatuses).forEach(function (key) {
      if (status.llmStatuses[key] == true) {
        available += 1;
      } else {
        failed += 1;
      }
    });

    try {
      if (failed == available) {
        logger.log(
          "System",
          "Pre-flight checks failed for all LLM services. Check your URLs and API keys, and try again.",
        );
        updateStatusBar(status.restIsOnline, status.dbIsOnline, 0);
      } else if (failed < available && failed > 0) {
        logger.log(
          "System",
          "Some pre-flight checks failed for LLM services. Check your URLs and API keys, and try again.",
        );
        updateStatusBar(status.restIsOnline, status.dbIsOnline, 1);
      } else {
        logger.log("System", "All pre-flight checks for LLM services passed.");
        updateStatusBar(status.restIsOnline, status.dbIsOnline, 2);
      }
    } catch (uiError) {
      logger.error("System", `Error updating status bar UI: ${uiError.message}`);
      // Continue execution even if UI update fails
    }

    try {
      logger.log("System", "Importing Twitch EventSub manager...");
      const { registerAllUsersEventSub } = await import('./twitch-eventsub-manager.js');

      logger.log("System", "Registering Twitch EventSub subscriptions...");
      const eventSubResults = await registerAllUsersEventSub();
      logger.log("System", `EventSub registration complete: ${eventSubResults.success} successful, ${eventSubResults.failures} failed`);
    } catch (eventSubError) {
      logger.error("System", `Error with Twitch EventSub: ${eventSubError.message}`);
      // Continue execution even if EventSub registration fails
    }

    logger.log("System", "Enspira is fully initialized and ready!");
    return { server, status };
  } catch (error) {
    logger.error("System", `Failed to initialize application: ${error.message}`);
    try {
      updateStatusBar(false, false, 0);
    } catch (uiError) {
      // Ignore UI errors during failure state
    }
    throw error;
  }
}

// Start everything up
initializeApp();
</file>

<file path="auth/auth_keys.example.json">
[
  {
    "display_name": "Player Name",
    "email": "player@player.com",
    "user_id": "player1",
    "user_name": "Player",
    "twitch_name": "Player_TTV",
    "socials": {
      "ttv": "Player_TTV",
      "tt": "Player_TT",
      "yt": "Player YT"
    },
    "commands_list": [
      "!discord",
      "!socials",
      "!specs",
      "!changegame",
      "!changetitle"
    ],
    "tts_enabled": true,
    "bot_twitch": "@AiTwitchHandle",
    "speaker_file": "voice_path/",
    "rvc_model": "RVC_MODEL/RVC_Model.pth",
    "rvc_pitch": "0",
    "bot_name": "AiBot",
    "role": "ADMIN",
    "api_token": "",
    "api_token_type": "Bearer",
    "is_local": true,
    "latitude": "",
    "longitude": "",
    "timeZone": "",
    "lastIp": "",
    "weather": true,
    "max_chats": 40,
    "ttsEqPref": "",
    "ttsUpsamplePref": false,
    "twitch_tokens": {
      "bot": {
        "access_token": "",
        "refresh_token": "",
        "expires_at": 0
      },
      "streamer": {
        "access_token": "",
        "refresh_token": "",
        "expires_at": 0
      }
    },
    "current_game": {
      "online": false,
      "updated_at": ""
    },
    "fishTTSVoice": "",
    "current_followers": 0,
    "current_viewers": 0,
    "stream_status": {
      "online": false,
      "updated_at": ""
    },
    "webPasswordHash": "",
    "webPasswordSalt": "",
    "useFishTTS": false
  }
]
</file>

<file path="audio-processor.js">
// ffmpeg-processor.js - Fixed version with proper promise handling
import fs from 'fs-extra';
import path from 'path';
import { execFileSync } from 'child_process';
import { logger } from './create-global-logger.js';

/**
 * Processes audio using ffmpeg in a way that maximizes performance
 * @param {string} inputFilePath - Path to the input WAV file
 * @param {Object} options - Processing options
 * @returns {string} - Path to the processed file (synchronous return)
 */
export function processAudio(inputFilePath, options = {}) {
    const {
        enhanceVocals = true,
        outputDir = 'final',
        preset = 'clarity',
        userId = 'null'
    } = options;

    try {
        // Prepare paths
        const outputDirectory = path.resolve(process.cwd(), outputDir);
        const inputFileName = path.basename(inputFilePath, path.extname(inputFilePath));
        const outputFileName = `${userId}_${inputFileName}.wav`;
        const outputFilePath = path.join(outputDirectory, outputFileName);
        
        // Ensure output directory exists
        fs.ensureDirSync(outputDirectory);
        
        // Get filter string based on preset
        const filterString = enhanceVocals ? getPresetFilters(preset).join(',') : '';
        
        // Create the ffmpeg command
        const ffmpegCommand = `ffmpeg -y -i "${inputFilePath}" -af "${filterString}" -ar 48000 -ac 1 -codec:a pcm_s24le -threads 4 "${outputFilePath}"`;
        
        // Log the command
        logger.debug("Audio", `Executing command: ${ffmpegCommand}`);
        
        // Execute ffmpeg command synchronously
        execFileSync("ffmpeg", ["-nostdin", "-y", "-i", inputFilePath, "-af", filterString, "-ac", "1", "-threads", "8", outputFilePath], {
            stdio: ['ignore'] // Capture stderr only for errors
        });
        
        // Check that the output file exists
        if (!fs.existsSync(outputFilePath)) {
            throw new Error(`Output file was not created: ${outputFilePath}`);
        }
        
        logger.log("Audio", `Successfully processed audio to ${outputFilePath}`);
        return `/${outputFileName}`;
    } catch (error) {
        logger.error("Audio", `Error processing audio: ${error.message}`);
        throw error; // Re-throw to let caller handle it
    }
}

/**
 * Process multiple audio files in sequence
 * @param {Array<string>} inputFiles - Array of input file paths
 * @param {Object} options - Processing options
 * @returns {Array<string>} - Array of processed file paths
 */
export function batchProcessAudio(inputFiles, options = {}) {
    const results = [];
    for (const file of inputFiles) {
        const outputPath = processAudio(file, options);
        results.push(outputPath);
    }
    return results;
}

/**
 * Gets audio filters for the specified preset
 * @param {string} preset - Name of the preset
 * @returns {Array} - Array of filter strings
 */
function getPresetFilters(preset) {
    const basePresets = {
        clarity: [
            'highpass=f=150',
            'lowpass=f=11000',
            'equalizer=f=250:width_type=o:width=1:g=0.5',
            'equalizer=f=2500:width_type=o:width=1:g=1.5',
            'equalizer=f=4000:width_type=q:width=20:g=-2',
            'equalizer=f=6000:width_type=o:width=1:g=-1',
            'compand=0.2|0.3:1|1:-90/-60|-60/-40|-40/-30|-20/-20:6:0:-90:0.2',
            'loudnorm=I=-16:TP=-1.5:LRA=11'
        ],
        warmVocal: [
            'highpass=f=100',
            'lowpass=f=11000',
            'equalizer=f=200:width_type=o:width=1:g=2',
            'equalizer=f=600:width_type=o:width=1:g=1',
            'equalizer=f=3000:width_type=o:width=1.5:g=1',
            'equalizer=f=4000:width_type=q:width=20:g=-2',
            'compand=0.2|0.3:1|1:-90/-60|-60/-40|-40/-30|-20/-15:5:0:-90:0.3',
            'loudnorm=I=-16:TP=-1.5:LRA=10'
        ],
        brightVocal: [
            'highpass=f=130',
            'lowpass=f=12000',
            'equalizer=f=3000:width_type=o:width=1:g=2',
            'equalizer=f=4000:width_type=q:width=20:g=-2',
            'equalizer=f=6000:width_type=o:width=1:g=0.5',
            'equalizer=f=200:width_type=o:width=1:g=-1',
            'compand=0.1|0.2:1|1:-90/-60|-60/-40|-40/-30|-20/-15:5:0:-90:0.1',
            'loudnorm=I=-14:TP=-1.5:LRA=6'
        ],
        smoothVocal: [
            'highpass=f=80',
            'lowpass=f=11000',
            'highshelf=f=6000:g=-6',
            'equalizer=f=2000:width_type=o:width=1:g=1',
            'equalizer=f=4000:width_type=q:width=20:g=-2',
            'compand=0.3|0.5:1|1:-90/-60|-60/-40|-40/-30|-20/-15:4:0:-90:0.5',
            'loudnorm=I=-16:TP=-1.5:LRA=11'
        ],
        richVocal: [
            'highpass=f=70',
            'lowpass=f=11000',
            'equalizer=f=120:width_type=o:width=1.5:g=3',
            'equalizer=f=250:width_type=o:width=1.5:g=2.5',
            'equalizer=f=400:width_type=o:width=1:g=1.5',
            'equalizer=f=800:width_type=q:width=4:g=-0.5',
            'equalizer=f=2500:width_type=o:width=1:g=1',
            'equalizer=f=4000:width_type=q:width=20:g=-2',
            'compand=0.2|0.3:1|1:-90/-60|-60/-40|-40/-30|-20/-18:5:0:-90:0.3',
            'loudnorm=I=-16:TP=-1.5:LRA=10'
        ],
        broadcastSound: [
            'highpass=f=140',
            'lowpass=f=11000',
            'equalizer=f=120:width_type=o:width=1.5:g=3',
            'equalizer=f=250:width_type=o:width=1.5:g=2.5',
            'equalizer=f=500:width_type=o:width=1:g=1',
            'equalizer=f=800:width_type=o:width=1:g=-1',
            'equalizer=f=3000:width_type=o:width=1:g=2',
            'equalizer=f=4000:width_type=q:width=20:g=-2',
            'equalizer=f=6000:width_type=o:width=1:g=1',
            'compand=0.1|0.2:1|1:-90/-60|-60/-40|-40/-30|-30/-20|-20/-10:4:0:-90:0.2',
            'volume=1.0',
            'alimiter=limit=0.9:attack=5:release=20',
            'loudnorm=I=-14:TP=-1:LRA=8',
        ],
        femaleVocal: [
            'highpass=f=150',
            'lowpass=f=12000',
            'equalizer=f=200:width_type=o:width=1.5:g=1.5',
            'equalizer=f=400:width_type=o:width=1:g=1',
            'equalizer=f=1200:width_type=o:width=1:g=-1',
            'equalizer=f=2500:width_type=o:width=1:g=1.5',
            'equalizer=f=4000:width_type=q:width=20:g=-2',
            'equalizer=f=5000:width_type=o:width=1:g=1',
            'highshelf=f=8000:g=-2',
            'compand=0.2|0.4:1|1:-90/-60|-60/-40|-40/-30|-20/-18:4:0:-90:0.4',
            'loudnorm=I=-16:TP=-1.5:LRA=9',
            'adeclick=window=55:overlap=75:arorder=8:threshold=2:burst=2:method=add'
        ],
        deepBass: [
            'highpass=f=50',
            'lowpass=f=11000',
            'equalizer=f=80:width_type=o:width=1.2:g=4',
            'equalizer=f=200:width_type=o:width=1:g=2',
            'equalizer=f=500:width_type=q:width=4:g=-2',
            'equalizer=f=4000:width_type=q:width=20:g=-2',
            'compand=0.3|0.5:1|1:-90/-70|-70/-50|-50/-30|-20/-15:5:0:-90:0.3',
            'loudnorm=I=-17:TP=-2:LRA=12'
        ],
        telephone: [
            'highpass=f=300',
            'lowpass=f=3400',
            'equalizer=f=1000:width_type=o:width=0.7:g=4',
            'compand=0.1|0.1:1|1:-90/-40|-40/-20|-20/-10|-10/-5:3:0:-90:0.1',
            'loudnorm=I=-14:TP=-3:LRA=5'
        ],
        presenceBoost: [
            'highpass=f=150',
            'lowpass=f=11000',
            'equalizer=f=200:width_type=o:width=1:g=-1',
            'equalizer=f=2500:width_type=o:width=1.5:g=3',
            'equalizer=f=4000:width_type=q:width=20:g=-3',
            'equalizer=f=6000:width_type=o:width=1:g=2',
            'compand=0.1|0.2:1|1:-90/-60|-60/-40|-40/-30|-20/-15:6:0:-90:0.1',
            'loudnorm=I=-15:TP=-1.5:LRA=7'
        ],
        deBoom: [
            'highpass=f=100',
            'lowpass=f=11000',
            'equalizer=f=150:width_type=q:width=5:g=-4',
            'equalizer=f=300:width_type=q:width=4:g=-2',
            'equalizer=f=2500:width_type=o:width=1:g=1',
            'equalizer=f=4000:width_type=q:width=20:g=-2',
            'compand=0.2|0.3:1|1:-90/-60|-60/-40|-40/-30|-20/-18:6:0:-90:0.2',
            'loudnorm=I=-16:TP=-1.5:LRA=10'
        ],
        gentleCurve: [
            'highpass=f=100',
            'lowpass=f=11000',
            'equalizer=f=100:width_type=o:width=1.5:g=1',
            'equalizer=f=500:width_type=q:width=3:g=-1',
            'equalizer=f=3000:width_type=o:width=1.2:g=1',
            'equalizer=f=4000:width_type=q:width=20:g=-1',
            'compand=0.3|0.5:1|1:-90/-65|-65/-45|-45/-30|-20/-15:6:0:-90:0.3',
            'loudnorm=I=-16:TP=-1.5:LRA=11'
        ],
        thinToFull: [
            'highpass=f=85',
            'lowpass=f=11000',
            'equalizer=f=180:width_type=o:width=1.5:g=3',
            'equalizer=f=350:width_type=o:width=1.2:g=2',
            'equalizer=f=2800:width_type=o:width=1:g=1',
            'equalizer=f=4000:width_type=q:width=20:g=-2.5',
            'compand=0.2|0.4:1|1:-90/-60|-60/-40|-40/-30|-20/-17:5:0:-90:0.2',
            'loudnorm=I=-16.5:TP=-1.8:LRA=10'
        ]
    };
    
    return basePresets[preset] || basePresets.clarity;
}

/**
 * Cleans up files older than a specified number of days in a directory
 * @param {string} directory - Directory to clean up
 * @param {number} days - Delete files older than this many days (default: 5)
 * @return {Promise<number>} - Number of files deleted
 */
export async function cleanupOldFiles(directory, days = 5) {
    try {
        const now = Date.now();
        const cutoffTime = now - (days * 24 * 60 * 60 * 1000);

        const files = await fs.readdir(directory);
        let deletedCount = 0;

        for (const file of files) {
            const filePath = path.join(directory, file);

            try {
                const stats = await fs.stat(filePath);

                if (stats.isFile() && stats.ctimeMs < cutoffTime) {
                    await fs.unlink(filePath);
                    deletedCount++;
                }
            } catch (fileError) {
                logger.error("Audio", `Error processing file ${filePath}: ${fileError.message}`);
            }
        }

        return deletedCount;
    } catch (error) {
        logger.error("Audio", `Error cleaning up directory ${directory}: ${error.message}`);
        return 0;
    }
}

/**
 * Schedule automatic cleanup of a directory at regular intervals
 * @param {string} directory - Directory to clean up
 * @param {number} days - Delete files older than this many days (default: 5)
 * @param {number} intervalHours - How often to run cleanup in hours (default: 24)
 * @return {Object} - Timer object that can be cleared with clearInterval()
 */
export function scheduleCleanup(directory, days = 5, intervalHours = 24) {
    fs.mkdir(directory, { recursive: true })
        .catch(err => logger.error("Audio", `Error creating directory ${directory}: ${err.message}`));

    // Run cleanup immediately
    cleanupOldFiles(directory, days)
        .then(count => {
            if (count > 0) {
                logger.log("Audio", `Cleaned up ${count} old files from ${directory}`);
            }
        })
        .catch(err => logger.error("Audio", `Error in cleanup: ${err.message}`));

    const intervalMs = intervalHours * 60 * 60 * 1000;
    const timer = setInterval(() => {
        cleanupOldFiles(directory, days)
            .then(count => {
                if (count > 0) {
                    logger.log("Audio", `Cleaned up ${count} old files from ${directory}`);
                }
            })
            .catch(err => logger.error("Audio", `Error in scheduled cleanup: ${err.message}`));
    }, intervalMs);

    return timer;
}
</file>

<file path="data-helper.js">
import axios from "axios";
import {
  inferSearchParam,
  searchSearXNG,
  retrieveWebContext,
  rerankString,
} from "./ai-logic.js";
import fs from "fs-extra";
import { Readability } from "@mozilla/readability";
import { join } from "path";
import * as cheerio from 'cheerio';
import { JSDOM } from "jsdom";
import { retrieveConfigValue } from './config-helper.js'

const userAgentStrings = [
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.2227.0 Safari/537.36",
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.6 Safari/605.1.1",
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36 Edg/131.0.0.",
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36 Herring/97.1.8280.8"
];

/**
 * A structured error response for web RAG operations
 * @param {string} stage - The stage where the error occurred (e.g., 'search', 'retrieval')
 * @param {string} message - Human-readable error message
 * @param {object} [details] - Additional error details
 * @returns {object} - Structured error object
 */
export function createRagError(stage, message, details = null) {
  return {
    success: false,
    error: true,
    stage: stage,
    message: message,
    details: details,
    timestamp: new Date().toISOString()
  };
}

/**
 * Maintains a history of voice messages in a text file, adding new lines
 * and removing old ones to keep the file within a specified size limit.
 *
 * @param {string} newLine - The new line to add to the voice message history.
 * @returns {Promise<void>}
 */
async function maintainVoiceContext(newLine) {
  try {
    const chatContextPath = join(process.cwd(), "/world_info/voice_messages.txt");

    await fs.ensureFile(chatContextPath); // Ensures the file exists

    const currentContent = await fs.readFile(chatContextPath, "utf-8");
    const currentLines = currentContent.split("\n").filter(Boolean);

    currentLines.push("- " + newLine);

    // Remove oldest lines if the number of lines exceeds the limit
    while (currentLines.length > await retrieveConfigValue("twitch.maxChatsToSave")) {
      currentLines.shift();
    }

    await fs.writeFile(chatContextPath, currentLines.join("\n") + "\n");
  } catch (error) {
    logger.log("Voice Context", `Error maintaining voice context: ${error}`);
  }
}

/**
 * Reranks and filters a list of text contents based on their relevance to a given message.
 *
 * @param {Array} contextBody - An array of objects, each containing either 'text_content' or 'summary'.
 * @param {string} message - The message used for ranking relevance.
 * @param {string} userId - The ID of the user.
 * @param {boolean} requiresSearch - Indicates if a web search should be attempted if reranking results are poor.
 * @returns {Promise<string>} - A concatenated string of relevant content, or a default message if no relevant content is found.
 */
export async function resultsReranked(
  contextBody,
  message,
  userId,
  requiresSearch = false,
  cotReturn = false
) {
  try {
    if (!contextBody || !message) {
      logger.log("Embedding", "Missing contextBody or message parameter");
      return "- No additional information to provide.\n";
    }

    // Case 1: No documents at all - trigger web search immediately if allowed
    if (contextBody.length === 0) {
      logger.log("Embedding", "No context body provided for reranking.");
      
      if (requiresSearch) {
        logger.log("Embedding", "Attempting web search for additional context (no documents found)");
        const webResults = await startWebResults(message, userId);
        
        if (webResults && webResults.error) {
          if (webResults.optedOut) {
            return "- No additional context available for this query.\n";
          }
          logger.log("Search", `Web search failed: ${webResults.message}`);
          return "- Unable to find relevant information for this query.\n";
        }
        
        if (webResults) {
          return cotReturn ? [webResults] : webResults;
        }
        
        return "- No additional context provided for this section.";
      } else {
        return "- No additional context provided for this section.";
      }
    }
    
    // Process the documents for reranking
    let resultsRaw = [];
    let resultsTitle = [];
    
    if (!contextBody[0].relation) {
      resultsRaw = contextBody
        .map((item) => item.text_content || item.summary)
        .filter(Boolean);
      resultsTitle = contextBody
        .map((item) => item.relation)
        .filter(Boolean);
    } else {
      resultsRaw = contextBody
        .map((item) => item.text_content || item.summary)
        .filter(Boolean);
    }

    if (resultsRaw.length === 0) {
      logger.log("Embedding", "No valid content found in context body.");
      
      // Case 2: No valid content in documents - trigger web search if allowed
      if (requiresSearch) {
        logger.log("Embedding", "Attempting web search for additional context (no valid content)");
        const webResults = await startWebResults(message, userId);
        
        if (webResults && !webResults.error) {
          return cotReturn ? [webResults] : webResults;
        }
      }
      
      return "- No additional information to provide.\n";
    }

    // Get optimized query for reranking
    logger.log("Embedding", "Asking rerank helper to optimize...");
    let rerankOptimized = await rerankString(message, userId);
    
    if (rerankOptimized && rerankOptimized.error) {
      logger.log("Embedding", `Error optimizing rerank query: ${rerankOptimized.message}`);
      rerankOptimized = message;
    }

    // Perform the reranking
    const rerankData = {
      model: await retrieveConfigValue("models.rerank.model"),
      query: rerankOptimized,
      documents: resultsRaw,
      top_k: contextBody.length
    };

    logger.log("Embedding", `Starting rerank...`);
    
    try {
      const response = await axios.post(`${await retrieveConfigValue("models.rerank.endpoint")}/rerank`, rerankData, {
        headers: {
          "Content-Type": "application/json",
          "Accept-Encoding": "gzip, deflate, br",
          Connection: "keep-alive",
          Authorization: `Bearer ${await retrieveConfigValue("models.rerank.apiKey")}`
        },
        timeout: 10000,
      });

      logger.log("Embedding", `Rerank finished. Sorting results.`);
      const rerankedArray = response.data;

      // ADJUSTED RELEVANCE THRESHOLDS FOR LOGIT SCORES (-10 to 10 range)
      const HIGH_RELEVANCE_THRESHOLD = 6.0;    // Very high relevance (was 0.7)
      const ACCEPTABLE_THRESHOLD = 4.5;        // Good relevance (was 0.5)
      const LOW_RELEVANCE_THRESHOLD = 1.4;     // Low but possibly useful (new)
      
      // Count documents in each relevance category
      const highRelevanceCount = rerankedArray.filter(item => item.score >= HIGH_RELEVANCE_THRESHOLD).length;
      const acceptableCount = rerankedArray.filter(item => item.score >= ACCEPTABLE_THRESHOLD).length;
      const lowRelevanceCount = rerankedArray.filter(item => item.score < ACCEPTABLE_THRESHOLD).length;
      
      // Calculate average relevance of top 5 results
      const avgTopRelevance = rerankedArray
        .slice(0, 5)
        .reduce((sum, item) => sum + item.score, 0) / Math.min(5, rerankedArray.length);
      
      logger.log("Embedding", `Relevance stats - High (>=${HIGH_RELEVANCE_THRESHOLD}): ${highRelevanceCount}, ` +
        `Acceptable (>=${ACCEPTABLE_THRESHOLD}): ${acceptableCount}, Low: ${lowRelevanceCount}, ` +
        `Avg Top 5: ${avgTopRelevance.toFixed(2)}`);
      
      // Filter results based on the new acceptable threshold (5.0)
      let rerankProcessed = rerankedArray
        .filter(item => item.score >= ACCEPTABLE_THRESHOLD)
        .map(item => resultsRaw[parseInt(item.index)]);

      // If we have less than 3 acceptable results, include some lower-scoring ones
      if (rerankProcessed.length < 3) {
        logger.log("Embedding", `Not enough results above threshold ${ACCEPTABLE_THRESHOLD}. Including lower-scoring results.`);
        
        // Get additional items that didn't meet the acceptable threshold, but still have some relevance
        const additionalItems = rerankedArray
          .filter(item => item.score >= LOW_RELEVANCE_THRESHOLD && item.relevance_score < ACCEPTABLE_THRESHOLD)
          .map(item => resultsRaw[parseInt(item.index)]);
        
        // Add them to our processed results
        rerankProcessed = rerankProcessed.concat(additionalItems);
        
        // If we still don't have enough, just take the top 5
        if (rerankProcessed.length < 3) {
          rerankProcessed = rerankedArray
            .slice(0, 5)
            .map(item => resultsRaw[parseInt(item.index)]);
        }
      }

      // Trigger web search if ANY of these conditions are met:
      const shouldSearchWeb = requiresSearch && (
        // 1. We have fewer than 2 high-quality documents  
        highRelevanceCount < 2 || 
        // 2. Average top 5 score is below 6.0 (moderately relevant)
        avgTopRelevance < 6.0 ||
        // 3. More than 60% of results are below our acceptable threshold
        (lowRelevanceCount > 0 && lowRelevanceCount / rerankedArray.length > 0.6)
      );
      
      if (shouldSearchWeb) {
        logger.log(
          "Embedding", 
          `Attempting web search for additional context. Relevance too low: ` +
          `High: ${highRelevanceCount}, Avg: ${avgTopRelevance.toFixed(2)}, ` + 
          `Low Ratio: ${(lowRelevanceCount / rerankedArray.length).toFixed(2)}`
        );
        
        const augmentResult = await startWebResults(message, userId);
        
        if (augmentResult && augmentResult.error) {
          logger.log("Embedding", `Web search failed: ${augmentResult.message}`);
        } else if (augmentResult) {
          logger.log("Embedding", "Web search returned additional context, adding to results");
          rerankProcessed.push(augmentResult);
        }
      } else if (requiresSearch) {
        logger.log(
          "Embedding", 
          `Skipping web search - sufficient document quality. ` +
          `High: ${highRelevanceCount}, Acceptable: ${acceptableCount}, Avg: ${avgTopRelevance.toFixed(2)}`
        );
      }
      
      if (cotReturn) {
        return rerankProcessed;
      } else {
        return rerankProcessed.join("\n");
      }
    } catch (rerankError) {
      logger.log("Embedding", `Error during reranking: ${rerankError.message}`);
      
      // If reranking fails and search is allowed, try web search as fallback
      if (requiresSearch) {
        logger.log("Embedding", "Falling back to web search due to rerank failure");
        try {
          const webResults = await startWebResults(message, userId);
          if (webResults && !webResults.error) {
            return cotReturn ? [webResults] : webResults;
          }
        } catch (webError) {
          logger.log("Embedding", `Web search fallback also failed: ${webError.message}`);
        }
      }
      
      // Last resort: return the raw results limited to 5
      if (resultsRaw.length > 0) {
        const limitedResults = resultsRaw.slice(0, 5);
        return cotReturn ? limitedResults : limitedResults.join("\n");
      }
      
      return "- Error processing information. Using available context.\n";
    }
  } catch (error) {
    logger.log("Embedding", `Error in resultsReranked: ${error.stack}`);
    return createRagError('reranking', error.message, { stack: error.stack });
  }
}

export async function axiosRequestWithRetry(config, attempts = 3, initialDelay = 1000) {
  let delay = initialDelay;
  for (let i = 0; i < attempts; i++) {
    try {
      return await axios(config);
    } catch (error) {
      if (i === attempts - 1) {
        throw error;
      }
      await new Promise(resolve => setTimeout(resolve, delay));
      delay *= 2; // Exponential backoff
    }
  }
}

/**
 * Initiates a web search process for a given message and user ID.
 * It uses the message to infer a search query, performs a Brave search,
 * and then retrieves web context based on the search results.
 *
 * @param {string} message - The message to initiate the web search for.
 * @param {string} userId - The ID of the user performing the search.
 * @returns {Promise<string>} - The result of the web context retrieval, or an empty string if no query is inferred.
 */
export async function startWebResults(message, userId) {
  const queryResult = await inferSearchParam(message, userId);

  // Handle structured error from inferSearchParam
  if (!queryResult.success) {
    if (queryResult.optedOut) {
      logger.log("LLM", `Search opted out: ${queryResult.reason}`);
      return { 
        success: false, 
        optedOut: true, 
        reason: queryResult.reason,
        noSearchNeeded: true 
      };
    }
    
    logger.log("LLM", `Search parameter inference failed: ${queryResult.message}`);
    return queryResult; // Return the error object
  }

  try {
    const pmWebSearch = await searchSearXNG(queryResult.searchTerm, queryResult.freshness);
    
    // Check if searchSearXNG returned an error object
    if (pmWebSearch && pmWebSearch.error) {
      return pmWebSearch; // Already a properly formatted error
    }
    
    if (!pmWebSearch || pmWebSearch.length === 0) {
      return createRagError(
        'search-execution', 
        'No search results found',
        { searchTerm: queryResult.searchTerm, freshness: queryResult.freshness }
      );
    }
    
    logger.log("LLM", `Starting web search for '${queryResult.searchTerm}'`);
    const searchedResults = await retrieveWebContext(
      pmWebSearch,
      queryResult.searchTerm,
      queryResult.subject,
      userId
    );

    // Check if retrieveWebContext returned an error
    if (searchedResults && searchedResults.error) {
      return searchedResults;
    }

    return searchedResults || createRagError(
      'context-retrieval',
      'Failed to retrieve context from search results',
      { searchResults: pmWebSearch.length }
    );
  } catch (error) {
    logger.log("LLM", `Error in web search process: ${error.message}`);
    return createRagError('web-search', error.message, { stack: error.stack });
  }
}

/**
 * Classifies the emotions present in a given message using a specified classification model.
 * It sends the message to an embedding endpoint for classification and returns the ranked emotions.
 *
 * @param {string} message - The message to classify emotions from.
 * @returns {Promise<string>} - A string describing the ranked emotions in the message.
 */
const interpretEmotions = async (message) => {
  try {
    const classifyBody = {
      model: await retrieveConfigValue("models.classifier.model"),
      input: [message],
    };
    const response = await axios.post(`${await retrieveConfigValue("models.classifier.endpoint")}/classify`, classifyBody);
    const results = response.data.data[0];
    let emotionsResult = getEmotionRanking(results);
    return emotionsResult;
  } catch (error) {
    logger.log("Emotion", `Error in interpretEmotions: ${error}`);
    return "Error interpreting emotions.";
  }
};

/**
 * Pulls content from multiple web pages using Cheerio, parses, and cleans it.
 *
 * @param {Array} urls - An array of objects, each containing a URL to process.
 * @param {string} subject - The subject matter related to the URLs.
 * @returns {Promise<string>} - A concatenated string of cleaned content from all URLs, or an empty string if no content is found.
 */
const pullFromWeb = async (urls, subject) => {
  if (!urls || urls.length === 0) {
    logger.log("Augment", "No URLs provided for content extraction.");
    return "";
  }

  const fetchPromises = urls.map(async (link, index) => {
    try {
      const response = await axios.get(link.url, {
        headers: {
          "User-Agent":
            userAgentStrings[
            Math.floor(Math.random() * userAgentStrings.length)
            ],
        },
        timeout: 10000,
      });

      const $ = cheerio.load(response.data);

      // Remove script and style tags
      $("script, style").remove();

      // Get the HTML content after removing script and style tags
      const htmlContent = $.html();

      // Use Readability to extract the main content
      const document = new JSDOM(htmlContent); // Use JSDOM here
      const reader = new Readability(document.window.document);
      const article = reader.parse();

      if (!article) {
        logger.log("Augment", `Could not parse content from "${link.url}".`);
        return "";
      }

      const cleanContent = cleanContentWithNewlines(article.textContent);
      let content = "";

      if (index === 0) {
        content += `# Start of documents related to the subject "${subject}"`;
        content += `\n\n## From the web page "${link.source}", :\n\n${cleanContent}`;
      } else if (index === urls.length - 1) {
        content += `\n\n## From the web page "${link.url}", titled "${link.title}":\n\n${cleanContent}`;
        content += `\n\n# End of documents`;
      } else {
        content += `\n\n## From the web page "${link.url}" in regards to the subject matter "${subject}":\n\n${cleanContent}`;
      }

      return content;
    } catch (error) {
      logger.log("Augment", `Error processing URL "${link.url}": ${error}`);
      return "";
    }
  });

  const contents = await Promise.all(fetchPromises);
  const pageContentText = contents.filter(Boolean).join("\n\n");

  return pageContentText;
};

/**
 * Pulls content from multiple web pages using the scraper service
 * @param {Array} urls - Array of URL objects
 * @param {string} subject - The subject related to the URLs
 * @returns {Promise<string|object>} - Concatenated content or error object
 */
export async function pullFromWebScraper(urls, subject) {
  if (!urls || urls.length === 0) {
    return createRagError('scraping', 'No URLs provided for content extraction');
  }
  
  try {
    const fetchPromises = urls.map(async (link) => {
      try {
        const url = new URL(`${await retrieveConfigValue("server.externalScraper.endpoint")}/api/article`);
        url.searchParams.set("cache", await retrieveConfigValue("server.externalScraper.caching"));
        url.searchParams.set("resource", "document");
        url.searchParams.set("device", await retrieveConfigValue("server.externalScraper.deviceType"));
        url.searchParams.set("url", link.url);
        url.searchParams.set("format", "json");

        const response = await axios.get(url.toString(), { timeout: 15000 });
        
        // Check if the response has the expected structure
        if (!response.data || typeof response.data !== 'object') {
          logger.log("Augment", `Invalid response format for URL ${link.url}`);
          return "";
        }
        
        // Check for textContent property specifically
        if (!response.data.textContent || typeof response.data.textContent !== 'string') {
          logger.log("Augment", `No text content found for URL ${link.url}`);
          return "";
        }
        
        return `## From the web page "${link.source}", titled "${link.title}":\n\n${response.data.textContent}`;
      } catch (error) {
        logger.log("Augment", `Error processing URL "${link.url}": ${error.message}`);
        return ""; // Return empty string on error to be filtered later
      }
    });

    const contents = await Promise.all(fetchPromises);
    const validContents = contents.filter(Boolean);
    
    if (validContents.length === 0) {
      return createRagError(
        'scraping-results', 
        'No valid content extracted from any URL',
        { urlsAttempted: urls.length }
      );
    }

    // Construct the final page content text
    let pageContentText = `# Start of documents related to the subject "${subject}"\n\n`;
    pageContentText += validContents.join("\n\n");
    pageContentText += `\n\n# End of documents related to the subject "${subject}"`;

    return pageContentText;
  } catch (error) {
    logger.log("Augment", `Error in web scraping: ${error.message}`);
    return createRagError('scraping-execution', error.message);
  }
}

/**
 * Cleans a given text content by removing extra spaces and normalizing newlines.
 *
 * @param {string} content - The text content to clean.
 * @returns {string} - The cleaned text content.
 */
function cleanContentWithNewlines(content) {
  return content
    .replace(/\s+/g, " ")
    .replace(/(?:\s*\n\s*)+/g, "\n")
    .trim();
}

/**
 * Generates a description of the emotional tone conveyed in a message based on emotion classification results.
 *
 * @param {Array} emotions - An array of emotion objects, each with a 'label' and 'score'.
 * @returns {string} - A description of the emotional tone.
 */
const getEmotionRanking = (emotions) => {
  const getModifier = (score) => {
    if (score <= 0.33) {
      return "a bit of";
    } else if (score <= 0.66) {
      return "quite a bit of";
    } else {
      return "a lot of";
    }
  };

  const getEmotionDescription = (label) => {
    switch (label) {
      case "curious":
        return "a quizzical and curious vibe";
      case "surprise":
        return "shock and awe";
      case "think":
        return "curiosity";
      case "cheeky":
        return "cheeky banter";
      case "grumpy":
        return "a grumpy vibe";
      case "whiny":
        return "a whiny tone";
      case "empathetic":
        return "a sense of compassion";
      case "guilty":
        return "regret";
      case "anger":
        return "a heated emotion";
      case "disgust":
        return "a disgusted tone";
      case "impatient":
        return "frustration";
      case "energetic":
        return "an electrifying energy";
      case "joy":
        return "an uplifting and vibrant energy";
      case "serious":
        return "a stone-cold serious vibe";
      case "neutral":
        return "a lack of emotional energy";
      case "fear":
        return "a reserved or tense mood";
      case "love":
        return "a heartfelt or warm sentiment";
      case "confuse":
        return "a puzzled demeanor";
      case "suspicious":
        return "a doubtful tone";
      case "sadness":
        return "melancholy";
      default:
        return "an undefined or mixed feeling";
    }
  };

  const topEmotions = emotions.sort((a, b) => b.score - a.score).slice(0, 3);

  const messageParts = topEmotions.map(({ label, score }) => {
    const modifier = getModifier(score);
    const description = getEmotionDescription(label);
    return `${modifier} ${description}`;
  });

  const formattedMessage =
    messageParts.length > 1
      ? `${messageParts.slice(0, -1).join(", ")}, and ${messageParts.slice(-1)}`
      : messageParts[0];

  return `You feel that this message gives off ${formattedMessage}.`;
};

export {
  interpretEmotions,
  maintainVoiceContext,
  pullFromWeb,
};
</file>

<file path="oai-requests.js">
import { retrieveConfigValue } from "./config-helper.js";

export class ChatRequestBody {
  constructor(promptData) {
    this.messages = [
      // System message with core instructions
      {
        role: "system",
        content: promptData.systemPrompt
      }
    ];

    // Add each context component as a separate user message
    if (promptData.characterDescription) {
      this.messages.push({
        role: "user",
        content: promptData.characterDescription
      });
    }

    if (promptData.characterPersonality) {
      this.messages.push({
        role: "user",
        content: promptData.characterPersonality
      });
    }

    if (promptData.worldInfo) {
      this.messages.push({
        role: "user",
        content: promptData.worldInfo
      });
    }

    if (promptData.scenario) {
      this.messages.push({
        role: "user",
        content: promptData.scenario
      });
    }

    if (promptData.playerInfo) {
      this.messages.push({
        role: "user",
        content: promptData.playerInfo
      });
    }

    if (promptData.recentChat) {
      this.messages.push({
        role: "user",
        content: promptData.recentChat
      });
    }

    if (promptData.weatherInfo) {
      this.messages.push({
        role: "user",
        content: promptData.weatherInfo
      });
    }

    // Add additional context elements if they exist
    if (promptData.additionalContext) {
      Object.entries(promptData.additionalContext).forEach(([key, value]) => {
        if (value && value.trim()) {
          this.messages.push({
            role: "user",
            content: value
          });
        }
      });
    }

    // Add assistant acknowledgment
    this.messages.push({
      role: "assistant",
      content: "I understand. I'll keep the provided rules, character information, and provided context in mind when responding to the next user message."
    });

    // Add the actual user query
    this.messages.push({
      role: "user",
      content: promptData.userMessage
    });

    // Set streaming to true by default
    this.stream = true;
  }

  // Static factory method for async initialization
  static async create(promptData) {
    const instance = new ChatRequestBody(promptData);
    await instance.initialize();
    return instance;
  }

  // Handle async initialization
  async initialize() {
    // Load all configuration values in parallel for better performance
    const [
      model,
      topK,
      minP,
      xtcThreshold,
      xtcProbability,
      topP,
      typicalP,
      minTokens,
      repetitionPenalty,
      presencePenalty,
      repetitionRange,
      presenceRange,
      temperature,
      dynTempMax,
      dynTempMin,
      dynTemp,
      maxTokens,
      generateWindow
    ] = await Promise.all([
      retrieveConfigValue("models.chat.model"),
      retrieveConfigValue("samplers.chat.topK"),
      retrieveConfigValue("samplers.chat.minP"),
      retrieveConfigValue("samplers.chat.xtcThreshold"),
      retrieveConfigValue("samplers.chat.xtcProbability"),
      retrieveConfigValue("samplers.chat.topP"),
      retrieveConfigValue("samplers.chat.typicalP"),
      retrieveConfigValue("samplers.chat.minTokens"),
      retrieveConfigValue("samplers.chat.repetitionPenalty"),
      retrieveConfigValue("samplers.chat.presencePenalty"),
      retrieveConfigValue("samplers.chat.repetitionRange"),
      retrieveConfigValue("samplers.chat.presenceRange"),
      retrieveConfigValue("samplers.chat.temperature"),
      retrieveConfigValue("samplers.chat.dynTempMin"),
      retrieveConfigValue("samplers.chat.dynTempMax"),
      retrieveConfigValue("samplers.chat.dynTemp"),
      retrieveConfigValue('samplers.chat.maxTokens'),
      retrieveConfigValue('samplers.chat.generateWindow')
    ]);

    // Assign values to this instance
    this.model = model;
    this.top_k = parseInt(topK);
    this.min_p = parseFloat(minP);
    this.xtc_threshold = parseFloat(xtcThreshold);
    this.xtc_probability = parseFloat(xtcProbability);
    this.top_p = parseFloat(topP);
    this.typical_p = parseFloat(typicalP);
    this.min_tokens = parseInt(minTokens);
    this.repetition_penalty = parseFloat(repetitionPenalty);
    this.presence_penalty = parseFloat(presencePenalty);
    this.repetition_range = parseInt(repetitionRange);
    this.presence_range = parseInt(presenceRange);
    this.temperature = parseFloat(temperature);
    this.max_tokens = parseInt(maxTokens);
    this.generate_window = parseInt(generateWindow);
    
    // Add dynamic temperature settings if enabled
    if (dynTemp) {
      this.dynatemp = dynTemp;
      this.dynatemp_min = parseFloat(dynTempMin);
      this.dynatemp_max = parseFloat(dynTempMax);
    }
  }
}

export class ChatRequestBodyCoT {
  constructor(promptData) {
    // Initialize with the system prompt
    this.messages = [
      {
        role: "system",
        content: promptData.systemPrompt
      }
    ];

    // Add each context component as a separate user message
    if (promptData.characterDescription) {
      this.messages.push({
        role: "user",
        content: promptData.characterDescription
      });
    }

    if (promptData.characterPersonality) {
      this.messages.push({
        role: "user",
        content: promptData.characterPersonality
      });
    }

    if (promptData.worldInfo) {
      this.messages.push({
        role: "user",
        content: promptData.worldInfo
      });
    }

    if (promptData.scenario) {
      this.messages.push({
        role: "user",
        content: promptData.scenario
      });
    }

    if (promptData.playerInfo) {
      this.messages.push({
        role: "user",
        content: promptData.playerInfo
      });
    }

    if (promptData.recentChat) {
      this.messages.push({
        role: "user",
        content: promptData.recentChat
      });
    }

    if (promptData.weatherInfo) {
      this.messages.push({
        role: "user",
        content: promptData.weatherInfo
      });
    }

    // Add additional context elements if they exist
    if (promptData.additionalContext) {
      Object.entries(promptData.additionalContext).forEach(([key, value]) => {
        if (value && value.trim()) {
          this.messages.push({
            role: "user",
            content: value
          });
        }
      });
    }

    // Add assistant acknowledgment
    this.messages.push({
      role: "assistant",
      content: "I understand all given instructions and who I am now. I'll ensure I think deeply but concisely about the message and respond according to my thoughts."
    });

    // Add the actual user query
    this.messages.push({
      role: "user",
      content: promptData.userMessage
    });

    // Set streaming to true by default
    this.stream = true;

    // Define the JSON response format for chain-of-thought
    this.response_format = {
      type: "json_schema",
      json_schema: {
        name: "thoughtful_response",
        schema: {
          type: "object",
          properties: {
            thoughts: {
              type: "array",
              items: {
                type: "string",
                description: "One brief thought about the user's message. Keep each thought under 250 words maximum."
              },
              maxItems: 6,
              description: "A short list of key thoughts that capture your reasoning process."
            },
            final_response: {
              type: "string",
              description: "Your final response to the user, optimized for Twitch chat. Keep it under 500 characters when possible."
            }
          },
          required: ["thoughts", "final_response"],
          additionalProperties: false
        },
        strict: true
      }
    };
  }

  // Static factory method for async initialization
  static async create(promptData) {
    const instance = new ChatRequestBodyCoT(promptData);
    await instance.initialize();
    return instance;
  }

  // Handle async initialization
  async initialize() {
    // Load all configuration values in parallel for better performance
    const [
      model,
      maxTokens,
      generateWindow,
      topK,
      minP,
      xtcThreshold,
      xtcProbability,
      topP,
      typicalP,
      minTokens,
      repetitionPenalty,
      presencePenalty,
      repetitionRange,
      presenceRange,
      temperature,
      dynTemp,
      dynTempMin,
      dynTempMax
    ] = await Promise.all([
      retrieveConfigValue("models.chat.model"),
      retrieveConfigValue("samplers.chat.maxTokens"),
      retrieveConfigValue("samplers.chat.generateWindow"),
      retrieveConfigValue("samplers.chat.topK"),
      retrieveConfigValue("samplers.chat.minP"),
      retrieveConfigValue("samplers.chat.xtcThreshold"),
      retrieveConfigValue("samplers.chat.xtcProbability"),
      retrieveConfigValue("samplers.chat.topP"),
      retrieveConfigValue("samplers.chat.typicalP"),
      retrieveConfigValue("samplers.chat.minTokens"),
      retrieveConfigValue("samplers.chat.repetitionPenalty"),
      retrieveConfigValue("samplers.chat.presencePenalty"),
      retrieveConfigValue("samplers.chat.repetitionRange"),
      retrieveConfigValue("samplers.chat.presenceRange"),
      retrieveConfigValue("samplers.chat.temperature"),
      retrieveConfigValue("samplers.chat.dynTemp"),
      retrieveConfigValue("samplers.chat.dynTempMin"),
      retrieveConfigValue("samplers.chat.dynTempMax")
    ]);

    // Assign and parse all configuration values
    this.model = model;
    this.max_tokens = parseInt(maxTokens);
    this.generate_window = parseInt(generateWindow);
    this.top_k = parseInt(topK);
    this.min_p = parseFloat(minP);
    this.xtc_threshold = parseFloat(xtcThreshold);
    this.xtc_probability = parseFloat(xtcProbability);
    this.top_p = parseFloat(topP);
    this.typical_p = parseFloat(typicalP);
    this.min_tokens = parseInt(minTokens);
    this.repetition_penalty = parseFloat(repetitionPenalty);
    this.presence_penalty = parseFloat(presencePenalty);
    this.repetition_range = parseInt(repetitionRange);
    this.presence_range = parseInt(presenceRange);
    this.temperature = parseFloat(temperature);
    
    // Add dynamic temperature settings if enabled
    if (dynTemp) {
      this.dynatemp = dynTemp;
      this.dynatemp_min = parseFloat(dynTempMin);
      this.dynatemp_max = parseFloat(dynTempMax);
    }
  }
}

export class ToolRequestBody {
  // Constructor handles synchronous initialization
  constructor(prompt, model, message) {
    // Initialize the basic message structure
    this.model = model;
    this.messages = [
      {
        role: "system",
        content: prompt,
      },
      {
        role: "user",
        content: message,
      },
    ];
  }

  // Static factory method provides a clean async interface
  static async create(prompt, model, message) {
    const instance = new ToolRequestBody(prompt, model, message);
    await instance.initialize();
    return instance;
  }

  // Private method handles all async initialization
  async initialize() {
    // Load all configuration values in parallel for better performance
    const [temperature, topP, topK, minP] = await Promise.all([
      retrieveConfigValue("samplers.tool.temperature"),
      retrieveConfigValue("samplers.tool.topP"),
      retrieveConfigValue("samplers.tool.topK"),
      retrieveConfigValue("samplers.tool.minP")
    ]);

    // Assign the parsed values to the instance
    this.temperature = parseFloat(temperature);
    this.top_p = parseFloat(topP);
    this.top_k = parseInt(topK);
    this.min_p = parseFloat(minP);
    this.stream = true;
  }
}

export class QueryRequestBody {
  // Constructor handles all synchronous initialization
  constructor(prompt, model, message) {
    // Set up the basic message structure
    this.model = model;
    this.messages = [
      {
        role: "system",
        content: prompt,
      },
      {
        role: "user",
        content: message,
      },
    ];

    // Initialize the JSON schema response format
    this.response_format = {
      type: "json_schema",
      json_schema: {
        name: "query_response",
        schema: {
          type: "object",
          properties: {
            valid: {
              type: "boolean",
              description: "Whether or not this is a Valid Inquiry for performing searches on. True for valid, False for invalid."
            },
            searchTerm: {
              type: "string",
              description: "The SEO-optimized search term related to the inquiry."
            },
            subject: {
              type: "string",
              description: "The inferred subject of the inquiry."
            },
            vectorString: {
              type: "string",
              description: "The vector similiarity search optimized string you have created."
            },
            freshness: {
              type: "string",
              description: "The freshness rating that applies to this search."
            },
            reason: {
              type: "string",
              description: "If query was deemed to be not valid, briefly and concisely explain why you determined the query was invalid. For valid queries, leave this empty."
            }
          },
          required: ["valid", "searchTerm", "subject", "vectorString", "freshness", "reason"],
          additionalProperties: false
        },
        strict: true
      }
    };
  }

  // Static factory method provides the async creation interface
  static async create(prompt, model, message) {
    const instance = new QueryRequestBody(prompt, model, message);
    await instance.initialize();
    return instance;
  }

  // Private method handles all async initialization
  async initialize() {
    // Load all configuration values in parallel for better performance
    const [
      temperature,
      topP,
      topK,
      minP,
      generateWindow,
      maxTokens
    ] = await Promise.all([
      retrieveConfigValue("samplers.tool.temperature"),
      retrieveConfigValue("samplers.tool.topP"),
      retrieveConfigValue("samplers.tool.topK"),
      retrieveConfigValue("samplers.tool.minP"),
      retrieveConfigValue("samplers.tool.generateWindow"),
      retrieveConfigValue("samplers.tool.maxTokens")
    ]);

    // Assign and parse all the configuration values
    this.temperature = parseFloat(temperature);
    this.top_p = parseFloat(topP);
    this.top_k = parseInt(topK);
    this.min_p = parseFloat(minP);
    this.generate_window = parseInt(generateWindow);
    this.max_tokens = parseInt(maxTokens);
    this.stream = true;
  }
}

export class ModerationRequestBody {
  // Constructor handles synchronous initialization of message structure and schema
  constructor(prompt, model, message) {
    // Initialize the basic messaging structure for moderation requests
    this.model = model;
    this.messages = [
      {
        role: "system",
        content: prompt,
      },
      {
        role: "user",
        content: message,
      },
    ];

    // Set up the JSON schema for moderation responses
    // This is static and defines the structure all moderation responses must follow
    this.response_format = {
      type: "json_schema",
      json_schema: {
        name: "moderator_response",
        schema: {
          type: "object",
          properties: {
            actionNeeded: {
              type: "boolean",
              description: "Whether the user's message is deemed safe (false) or needs to be actioned (true)."
            },
            actionType: {
              type: "string",
              description: "Whether or not the user's message requires a strike or a ban."
            },
            reason: {
              type: "string",
              description: "The reason for issuing the action to the user."
            },
          },
          required: ["actionNeeded", "actionType", "reason"],
          additionalProperties: false
        },
        strict: true
      }
    };
  }

  // Static factory method provides a clean async interface for creating instances
  static async create(prompt, model, message) {
    const instance = new ModerationRequestBody(prompt, model, message);
    await instance.initialize();
    return instance;
  }

  // Private method handles asynchronous initialization of configuration values
  async initialize() {
    // Load all configuration values in parallel using Promise.all for efficiency
    const [temperature, topP, topK, minP] = await Promise.all([
      retrieveConfigValue("samplers.tool.temperature"),
      retrieveConfigValue("samplers.tool.topP"),
      retrieveConfigValue("samplers.tool.topK"),
      retrieveConfigValue("samplers.tool.minP")
    ]);

    // Parse and assign the configuration values to the instance
    this.temperature = parseFloat(temperature);
    this.top_p = parseFloat(topP);
    this.top_k = parseInt(topK);
    this.min_p = parseFloat(minP);
    this.stream = true;
  }
}

export class SummaryRequestBody {
  // Constructor handles synchronous initialization of the core structure
  constructor(prompt, model, message) {
    // Set up the basic message structure that all requests need
    this.model = model;
    this.messages = [
      {
        role: "system",
        content: prompt,
      },
      {
        role: "user",
        content: message,
      },
    ];

    // Define the JSON schema that governs the format of summary responses
    // This schema ensures we get both a vector-optimized string and complete summary
    this.response_format = {
      type: "json_schema",
      json_schema: {
        name: "summary_response",
        schema: {
          type: "object",
          properties: {
            vectorString: {
              type: "string",
              description: "A single brief and concise sentence about what you've summarized, optimized for ease of retrieval in a vector similarity search."
            },
            summaryContents: {
              type: "string",
              description: "The complete contents of your summary."
            },
          },
          required: ["vectorString", "summaryContents"],
          additionalProperties: false
        },
        strict: true
      }
    };
  }

  // Static factory method creates a clean interface for async instantiation
  static async create(prompt, model, message) {
    const instance = new SummaryRequestBody(prompt, model, message);
    await instance.initialize();
    return instance;
  }

  // Private method handles all asynchronous configuration loading
  async initialize() {
    // Load all sampler configuration values in parallel for better performance
    // This reduces initialization time compared to sequential loading
    const [temperature, topP, topK, minP] = await Promise.all([
      retrieveConfigValue("samplers.tool.temperature"),
      retrieveConfigValue("samplers.tool.topP"),
      retrieveConfigValue("samplers.tool.topK"),
      retrieveConfigValue("samplers.tool.minP")
    ]);

    // Parse and assign the configuration values, ensuring proper type conversion
    this.temperature = parseFloat(temperature);
    this.top_p = parseFloat(topP);
    this.top_k = parseInt(topK);
    this.min_p = parseFloat(minP);
    this.stream = true;
  }
}

export class ConvertDocsRequestBody {
  constructor(prompt, model, message) {
    return (async () => {
      this.model = model;
      this.messages = [
        {
          role: "system",
          content: prompt,
        },
        {
          role: "user",
          content: message,
        },
      ];

      this.temperature = parseFloat(
        await retrieveConfigValue("samplers.tool.temperature"),
      );
      this.top_p = parseFloat(await retrieveConfigValue("samplers.tool.topP"));
      this.top_k = parseInt(await retrieveConfigValue("samplers.tool.topK"));
      this.min_p = parseFloat(await retrieveConfigValue("samplers.tool.minP"));
      this.response_format = {
        "type": "json_schema",
        "json_schema": {
          "name": "conversion_response",
          "schema": {
            "type": "object",
            "properties": {
              "vectorString": { "type": "string", "description": "A concisely written phrasing of the contents you've summarized, optimized for ease of retrieval in a vector similarity search." },
              "summaryContents": { "type": "string", "description": "The complete contents of the summary about the document." },
            },
            "required": ["vectorString", "summaryContents"],
            "additionalProperties": false
          },
          "strict": true
        }
      }
      return this;
    })();
  }
}
</file>

<file path="routes/twitch.js">
// routes/twitch.js
import crypto from "crypto";
import { retrieveConfigValue } from "../config-helper.js";
import { returnAuthObject, updateUserParameter } from "../api-helper.js";
import { logger } from "../create-global-logger.js";

// Notification request headers
const TWITCH_MESSAGE_ID = "twitch-eventsub-message-id";
const TWITCH_MESSAGE_TIMESTAMP = "twitch-eventsub-message-timestamp";
const TWITCH_MESSAGE_SIGNATURE = "twitch-eventsub-message-signature";
const MESSAGE_TYPE = "twitch-eventsub-message-type";

// Notification message types
const MESSAGE_TYPE_VERIFICATION = "webhook_callback_verification";
const MESSAGE_TYPE_NOTIFICATION = "notification";
const MESSAGE_TYPE_REVOCATION = "revocation";

// Prepend this string to the HMAC that's created from the message
const HMAC_PREFIX = "sha256=";

async function getWebhookSecret(userId) {
  try {
    const user = await returnAuthObject(userId);

    // Check if user has webhook secret
    if (
      !user ||
      !user.twitch_tokens ||
      !user.twitch_tokens.streamer ||
      !user.twitch_tokens.streamer.webhook_secret
    ) {
      logger.log(
        "Twitch",
        `No webhook secret found for user ${userId}, generating temporary one`
      );

      // If there's no webhook secret, we should create one for future use
      // But for this verification, we'll return a dummy one that will fail verification
      if (user && user.twitch_tokens && user.twitch_tokens.streamer) {
        const newSecret = crypto.randomBytes(32).toString("hex");

        // Try to ensure path exists and set the webhook secret
        await ensureParameterPath(userId, "twitch_tokens.streamer");
        await updateUserParameter(
          userId,
          "twitch_tokens.streamer.webhook_secret",
          newSecret
        );

        // Log but still return a dummy secret for this verification
        logger.log(
          "Twitch",
          `Generated new webhook secret for future use, but current verification will fail`
        );
      }

      // Return a dummy secret that will cause verification to fail (this is intentional)
      return "invalid-verification-will-fail";
    }

    // Return the actual webhook secret
    return user.twitch_tokens.streamer.webhook_secret;
  } catch (error) {
    logger.error("Twitch", `Error getting webhook secret: ${error.message}`);
    // Return a dummy secret that will cause verification to fail
    return "error-getting-secret";
  }
}

async function twitchEventSubRoutes(fastify, options) {
  // Configure the raw body parser specifically for this route
  fastify.addContentTypeParser(
    "application/json",
    { parseAs: "buffer" },
    (req, body, done) => {
      done(null, body);
    }
  );

  // Helper functions for EventSub signature verification
  const getSecret = async (userId) => {
    // Get the secret from configuration
    try {
      const user = await returnAuthObject(userId);
      if (!user || !user.twitch_tokens || !user.twitch_tokens.webhook_secret) {
        logger.error("Twitch", `No webhook secret found for user ${userId}`);
        return null;
      }
      return user.twitch_tokens.webhook_secret;
    } catch (error) {
      logger.error("Twitch", `Error getting webhook secret: ${error.message}`);
      return null;
    }
  };

  const getHmacMessage = (headers, body) => {
    if (!headers || !body) {
      logger.error("Twitch", "Missing headers or body for HMAC calculation");
      return "";
    }

    const messageId = headers[TWITCH_MESSAGE_ID];
    const timestamp = headers[TWITCH_MESSAGE_TIMESTAMP];

    if (!messageId || !timestamp) {
      logger.error("Twitch", "Missing required headers for HMAC calculation");
      return "";
    }

    return messageId + timestamp + body;
  };

  const getHmac = (secret, message) => {
    if (!secret || !message) {
      logger.error("Twitch", "Missing secret or message for HMAC calculation");
      return "";
    }

    return crypto.createHmac("sha256", secret).update(message).digest("hex");
  };

  const verifyMessage = (hmac, verifySignature) => {
    try {
      return crypto.timingSafeEqual(
        Buffer.from(hmac),
        Buffer.from(verifySignature)
      );
    } catch (error) {
      logger.error("Twitch", `Error verifying signature: ${error.message}`);
      return false;
    }
  };

  // Test webhook endpoint for simulating Twitch events
  fastify.post("/eventsub/test/:userId", async (request, reply) => {
    try {
      const { userId } = request.params;
      const { eventType, eventData, eventVersion = "1" } = request.body;

      // Validate required parameters

      logger.log(
        "Twitch",
        `Processing test ${eventType} event for user ${userId}`
      );

      // Import the event processor
      const { processEventSubNotification } = await import(
        "../twitch-eventsub-manager.js"
      );

      // Process the event using the existing event processor
      const result = await processEventSubNotification(
        eventType,
        eventData,
        userId,
        eventVersion
      );

      return reply.send({
        success: true,
        eventType,
        userId,
        result,
      });
    } catch (error) {
      logger.error("Twitch", `Error processing test event: ${error.message}`);
      return reply.code(500).send({ error: error.message });
    }
  });
  fastify.get("/eventsub/test/examples/:eventType", async (request, reply) => {
    const { eventType } = request.params;

    // Import user object to get broadcaster ID if needed
    const { returnAuthObject } = await import("../api-helper.js");

    // Get user ID from query param or use a default
    const userId = request.query.userId || "default_user_id";

    // Try to get user details to populate broadcaster information
    let userObj;
    try {
      userObj = await returnAuthObject(userId);
    } catch (error) {
      logger.warn(
        "Twitch",
        `Could not get user object for ${userId}: ${error.message}`
      );
    }

    const broadcasterId =
      userObj?.twitch_tokens?.streamer?.twitch_user_id || "123456789";
    const broadcasterName = userObj?.twitch_name || "TestStreamer";

    const examples = {
      "channel.follow": {
        eventType: "channel.follow",
        eventData: {
          user_name: "TestFollower",
          user_id: "987654321",
          broadcaster_user_id: broadcasterId,
          broadcaster_user_name: broadcasterName,
          followed_at: new Date().toISOString(),
        },
        eventVersion: "2",
      },
      "channel.subscribe": {
        eventType: "channel.subscribe",
        eventData: {
          user_name: "TestSubscriber",
          user_id: "987654321",
          broadcaster_user_id: broadcasterId,
          broadcaster_user_name: broadcasterName,
          tier: "1000",
          is_gift: false,
        },
        eventVersion: "1",
      },
      "channel.subscription.gift": {
        eventType: "channel.subscription.gift",
        eventData: {
          user_name: "TestGifter",
          user_id: "987654321",
          broadcaster_user_id: broadcasterId,
          broadcaster_user_name: broadcasterName,
          tier: "1000",
          is_anonymous: false,
          recipient_user_name: "GiftRecipient",
          recipient_user_id: "456789123",
          total: 1,
        },
        eventVersion: "1",
      },
      "channel.raid": {
        eventType: "channel.raid",
        eventData: {
          from_broadcaster_user_id: "987654321",
          from_broadcaster_user_name: "TestRaider",
          to_broadcaster_user_id: broadcasterId,
          to_broadcaster_user_name: broadcasterName,
          viewers: 42,
        },
        eventVersion: "1",
      },
      "channel.chat.message": {
        eventType: "channel.chat.message",
        eventData: {
          broadcaster_user_id: broadcasterId,
          broadcaster_user_name: broadcasterName,
          chatter: {
            user_id: "987654321",
            user_name: "TestChatter",
            badges: [{ set_id: "subscriber", version: "1" }],
          },
          message: {
            text: "This is a test message! @" + broadcasterName,
            is_first: false,
            fragments: [
              {
                type: "text",
                text: "This is a test message! @" + broadcasterName,
              },
            ],
          },
        },
        eventVersion: "1",
      },
    };

    if (!examples[eventType]) {
      return reply.code(404).send({
        error: "Event type not found",
        availableTypes: Object.keys(examples),
      });
    }

    return reply.send(examples[eventType]);
  });

  // List current EventSub subscriptions
  fastify.get("/subscriptions/:userId", async (request, reply) => {
    const { userId } = request.params;

    try {
      const user = await returnAuthObject(userId);

      if (!user || !user.twitch_tokens || !user.twitch_tokens.access_token) {
        return reply
          .code(400)
          .send({ error: "User has no Twitch integration" });
      }

      // Get subscriptions from Twitch API
      const response = await axios.get(
        "https://api.twitch.tv/helix/eventsub/subscriptions",
        {
          headers: {
            "Client-ID": await retrieveConfigValue("twitch.clientId"),
            Authorization: `Bearer ${user.twitch_tokens.access_token}`,
          },
        }
      );

      return {
        success: true,
        subscriptions: response.data.data,
        total: response.data.total,
        max: response.data.max_total_cost,
      };
    } catch (error) {
      logger.error("Twitch", `Error listing subscriptions: ${error.message}`);
      return reply.code(500).send({ error: error.message });
    }
  });

  // Manually register all EventSub for a user
  fastify.post("/subscriptions/register/:userId", async (request, reply) => {
    const { userId } = request.params;

    try {
      // Import registration function
      const { registerUserSubscriptions } = await import(
        "../twitch-eventsub-manager.js"
      );

      // Register subscriptions
      const result = await registerUserSubscriptions(userId);

      return {
        success: result.success,
        created: result.created,
        skipped: result.skipped,
        error: result.error,
      };
    } catch (error) {
      logger.error(
        "Twitch",
        `Error registering subscriptions: ${error.message}`
      );
      return reply.code(500).send({ error: error.message });
    }
  });

  // Route to handle EventSub notifications
  fastify.post("/eventsub/:userId", async (request, reply) => {
    const { userId } = request.params;

    if (!userId) {
      logger.error("Twitch", "No userId provided in EventSub webhook URL");
      return reply.code(400).send({ error: "Missing userId parameter" });
    }

    // Get the webhook secret for this user
    const secret = await getWebhookSecret(userId);

    // Get and verify the signature
    const headers = request.headers;
    const rawBody = request.body;

    try {
      // Calculate the expected signature
      const message = getHmacMessage(headers, rawBody);
      const hmac = HMAC_PREFIX + getHmac(secret, message);

      // Verify the request is actually from Twitch
      if (!verifyMessage(hmac, headers[TWITCH_MESSAGE_SIGNATURE])) {
        logger.error("Twitch", "EventSub signature verification failed");

        // If the secret was a dummy one, it means we don't have a valid webhook secret
        if (
          secret === "invalid-verification-will-fail" ||
          secret === "error-getting-secret"
        ) {
          logger.error(
            "Twitch",
            `Invalid webhook secret for user ${userId}, verification was expected to fail`
          );

          // Register EventSub for this user to generate a valid webhook secret for next time
          const { registerUserSubscriptions } = await import(
            "../twitch-eventsub-manager.js"
          );
          registerUserSubscriptions(userId).catch((err) => {
            logger.error(
              "Twitch",
              `Failed to register EventSub subscriptions: ${err.message}`
            );
          });
        }

        return reply.code(403).send({ error: "Signature verification failed" });
      }

      // Signature verified, process the notification
      const notification = JSON.parse(rawBody.toString());
      const messageType = headers[MESSAGE_TYPE];

      // Handle different message types
      if (messageType === MESSAGE_TYPE_NOTIFICATION) {
        // Process the event
        await processEvent(notification, userId);
        return reply.code(204).send();
      } else if (messageType === MESSAGE_TYPE_VERIFICATION) {
        // Respond to webhook verification challenge
        logger.log(
          "Twitch",
          `EventSub verification received for user ${userId}`
        );
        return reply.code(200).type("text/plain").send(notification.challenge);
      } else if (messageType === MESSAGE_TYPE_REVOCATION) {
        // Handle subscription revocation
        logger.log(
          "Twitch",
          `EventSub ${notification.subscription.type} notifications revoked for user ${userId}`
        );
        logger.log("Twitch", `Reason: ${notification.subscription.status}`);

        // Update user's subscription status
        await handleEventSubRevocation(notification, userId);
        return reply.code(204).send();
      } else {
        logger.log("Twitch", `Unknown message type: ${messageType}`);
        return reply.code(204).send();
      }
    } catch (error) {
      logger.error(
        "Twitch",
        `Error processing EventSub notification: ${error.message}`
      );
      return reply.code(500).send({ error: "Internal server error" });
    }
  });

  fastify.post("/eventsub/register/:userId", async (request, reply) => {
    const { userId } = request.params;

    try {
      // Import registration function
      const { registerUserSubscriptions } = await import(
        "../twitch-eventsub-manager.js"
      );

      // Register subscriptions
      const result = await registerUserSubscriptions(userId);

      return {
        success: result.success,
        created: result.created,
        skipped: result.skipped,
        error: result.error,
      };
    } catch (error) {
      logger.error(
        "Twitch",
        `Error registering subscriptions: ${error.message}`
      );
      return reply.code(500).send({ error: error.message });
    }
  });

  fastify.get("/eventsub/subscriptions/:userId", async (request, reply) => {
    const { userId } = request.params;

    try {
      const user = await returnAuthObject(userId);

      if (!user || !user.twitch_tokens?.streamer?.access_token) {
        return reply
          .code(400)
          .send({ error: "User has no Twitch integration" });
      }

      // Import axios if needed
      const axios = (await import("axios")).default;

      // Get subscriptions from Twitch API
      const response = await axios.get(
        "https://api.twitch.tv/helix/eventsub/subscriptions",
        {
          headers: {
            "Client-ID": await retrieveConfigValue("twitch.clientId"),
            Authorization: `Bearer ${user.twitch_tokens.streamer.access_token}`,
          },
        }
      );

      return {
        success: true,
        subscriptions: response.data.data,
        total: response.data.total,
        max: response.data.max_total_cost,
      };
    } catch (error) {
      logger.error("Twitch", `Error listing subscriptions: ${error.message}`);
      return reply.code(500).send({ error: error.message });
    }
  });

  // EventSub subscription management endpoint
  fastify.post("/eventsub/subscribe", async (request, reply) => {
    const { userId, type, condition } = request.body;

    if (!userId || !type) {
      return reply.code(400).send({ error: "Missing required parameters" });
    }

    try {
      const result = await subscribeToEvent(userId, type, condition);
      return reply.send(result);
    } catch (error) {
      logger.error("Twitch", `Error subscribing to event: ${error.message}`);
      return reply.code(500).send({ error: error.message });
    }
  });
}

// Function to subscribe to EventSub events
async function subscribeToEvent(userId, type, condition = {}) {
  try {
    const user = await returnAuthObject(userId);

    if (!user) {
      throw new Error("User not found");
    }

    // Generate a new secret if one doesn't exist
    if (!user.twitch_tokens?.streamer?.webhook_secret) {
      const newSecret = crypto.randomBytes(32).toString("hex");

      // Ensure the path exists
      await ensureParameterPath(userId, "twitch_tokens.streamer");

      // Save the new secret
      await updateUserParameter(
        userId,
        "twitch_tokens.streamer.webhook_secret",
        newSecret
      );
    }

    // Default condition uses the broadcaster's ID
    if (Object.keys(condition).length === 0) {
      if (!user.twitch_tokens?.streamer?.twitch_user_id) {
        throw new Error("No broadcaster user ID available");
      }
      condition = {
        broadcaster_user_id: user.twitch_tokens.streamer.twitch_user_id,
      };
    }

    // Import needed functions
    const { getAppAccessToken } = await import("../twitch-eventsub-manager.js");
    const appToken = await getAppAccessToken();

    // Prepare the subscription payload
    const callbackUrl = `${await retrieveConfigValue("server.endpoints.external")}/api/v1/twitch/eventsub/${userId}`;

    // Get fresh user data to ensure we have the webhook secret
    const freshUser = await returnAuthObject(userId);

    const subscriptionBody = {
      type,
      version: "1",
      condition,
      transport: {
        method: "webhook",
        callback: callbackUrl,
        secret: freshUser.twitch_tokens.streamer.webhook_secret,
      },
    };

    // Make the API request to create the subscription
    const axios = (await import("axios")).default;
    const response = await axios.post(
      "https://api.twitch.tv/helix/eventsub/subscriptions",
      subscriptionBody,
      {
        headers: {
          "Client-ID": await retrieveConfigValue("twitch.clientId"),
          Authorization: `Bearer ${appToken}`, // Use app token here
          "Content-Type": "application/json",
        },
      }
    );

    // Save subscription ID in user's data
    const subscriptionId = response.data.data[0].id;

    // Update user's subscriptions list
    const subscriptions = freshUser.twitch_tokens.streamer.subscriptions || [];
    subscriptions.push({
      id: subscriptionId,
      type,
      created_at: new Date().toISOString(),
    });

    await updateUserParameter(
      userId,
      "twitch_tokens.streamer.subscriptions",
      subscriptions
    );

    logger.log(
      "Twitch",
      `Created EventSub subscription for ${userId}: ${type}`
    );

    return {
      success: true,
      subscription: response.data.data[0],
    };
  } catch (error) {
    logger.error("Twitch", `Failed to create subscription: ${error.message}`);
    throw error;
  }
}

// Handle EventSub revocation
async function handleEventSubRevocation(notification, userId) {
  try {
    const subscriptionId = notification.subscription.id;

    if (!userId || !subscriptionId) {
      logger.error("Twitch", "Missing userId or subscriptionId for revocation");
      return;
    }

    const user = await returnAuthObject(userId);

    if (!user || !user.twitch_tokens?.streamer?.subscriptions) {
      logger.error("Twitch", `No subscriptions found for user ${userId}`);
      return;
    }

    // Filter out the revoked subscription
    const subscriptions = user.twitch_tokens.streamer.subscriptions.filter(
      (sub) => sub.id !== subscriptionId
    );

    // Update the subscriptions list
    await updateUserParameter(
      userId,
      "twitch_tokens.streamer.subscriptions",
      subscriptions
    );

    logger.log(
      "Twitch",
      `Removed revoked subscription ${subscriptionId} for user ${userId}`
    );
  } catch (error) {
    logger.error("Twitch", `Error handling revocation: ${error.message}`);
  }
}

async function processEvent(notification, userId) {
  try {
    const eventType = notification.subscription.type;
    const eventVersion = notification.subscription.version || "1";
    const event = notification.event;

    // Log the event
    logger.log(
      "Twitch",
      `Processing ${eventType} (v${eventVersion}) event for user ${userId}`
    );

    // Import the event processor from the manager
    const { processEventSubNotification } = await import(
      "../twitch-eventsub-manager.js"
    );

    // Process based on the event type
    return await processEventSubNotification(
      eventType,
      event,
      userId,
      eventVersion
    );
  } catch (error) {
    logger.error("Twitch", `Error processing event: ${error.message}`);
    return { success: false, error: error.message };
  }
}

export default twitchEventSubRoutes;
</file>

<file path="twitch-helper.js">
import fs from "fs-extra";
import { funFact, returnAuthObject } from "./api-helper.js";
import { sendChatCompletionRequest, moderatorPrompt } from "./prompt-helper.js";
import moment from "moment";
import { retrieveConfigValue } from './config-helper.js'
const lastFunFactTime = new Map();

/**
 * Returns a formatted string for a Twitch event based on its type.
 *
 * @param {object} eventThing - The event data.
 * @param {string} userId - The ID of the user associated with the event.
 * @returns {Promise<string>} - A formatted string describing the event.
 */
async function returnTwitchEvent(eventThing, userId) {
  const userObj = await returnAuthObject(userId);
  const event = {
    ...eventThing,
    playerName: userObj.user_name,
    playerId: userObj.user_id,
  };

  const eventTypeHandlers = {
    sub: subMessage,
    dono: donoMessage,
    chat: chatMessage,
    raid: raidMessage,
    follow: followMessage,
    hype_start: hypeStartMessage,
    hype_update: hypeUpdateMessage,
    hype_end: hypeEndMessage,
    hype_up: hypeLevelUpMessage,
    trivia: triviaMessage,
    ad: adMessage,
    summary: summaryMessage,
    shoutout: shoutoutMessage,
  };

  const handler = eventTypeHandlers[event.eventType];
  if (handler) {
    return await handler(event);
  } else {
  }
}

/**
 * Processes command-driven events from chat
 * @param {string} command - The command text 
 * @param {string} userId - The user ID
 * @returns {Promise<object>} - Event object if command is valid
 */
export async function processCommandEvent(command, userId) {
  if (command.startsWith('!summary')) {
    return {
      eventType: 'summary',
      eventData: {}
    };
  } else if (command.startsWith('!trivia')) {
    return {
      eventType: 'trivia',
      eventData: {}
    };
  }

  return null;
}

/**
 * Processes real-time chat messages from any source
 * @param {object} chatEvent - The chat event data
 * @param {string} userId - The user ID
 * @returns {Promise<object>} - The processing result
 */
export async function processChatMessage(chatEvent, userId) {
  try {
    // Normalize the chat message
    const normalizedChat = normalizeMessageFormat(chatEvent);
    
    // Get user data
    const user = await returnAuthObject(userId);
    
    // Skip messages from ignored bots
    const fromBot = await containsAuxBotName(normalizedChat.user, userId);
    if (fromBot) return { success: true, ignored: true, reason: "bot_user" };
    
    // Check if message is a command
    const isCommand = await isCommandMatch(normalizedChat.message, userId);
    if (isCommand) return { success: true, ignored: true, reason: "command" };
    
    // Check if message mentions the character
    const mentionsChar = await containsCharacterName(normalizedChat.message, userId);
    
    // Format date for context
    const formattedDate = new Date().toLocaleString();
    
    // Process first messages or character mentions
    if (normalizedChat.firstMessage || mentionsChar) {
      // Add message to vector storage
      const summaryString = `On ${formattedDate} ${normalizedChat.user} said in ${user.twitch_name}'s Twitch chat: "${normalizedChat.message}"`;
      
      // Store asynchronously
      addChatMessageAsVector(
        summaryString,
        normalizedChat.message,
        normalizedChat.user,
        formattedDate,
        "",
        userId
      ).catch(err => logger.error("Twitch", `Error storing chat vector: ${err.message}`));
      
      // Return data needed for response generation
      return {
        success: true,
        processed: true,
        mentioned: mentionsChar,
        firstMessage: normalizedChat.firstMessage,
        requiresResponse: mentionsChar || normalizedChat.firstMessage,
        messageData: {
          message: normalizedChat.message,
          user: normalizedChat.user
        }
      };
    }
    
    // For other messages, store if configured
    if (user.store_all_chat) {
      const summaryString = `On ${formattedDate} ${normalizedChat.user} said in ${user.twitch_name}'s Twitch chat: "${normalizedChat.message}"`;
      
      addChatMessageAsVector(
        summaryString,
        normalizedChat.message,
        normalizedChat.user,
        formattedDate,
        "",
        userId
      ).catch(err => logger.error("Twitch", `Error storing regular chat: ${err.message}`));
    }
    
    return {
      success: true,
      processed: false,
      requiresResponse: false
    };
  } catch (error) {
    logger.error("Twitch", `Error processing chat: ${error.message}`);
    return { success: false, error: error.message };
  }
}

/**
 * Calculates the time difference between a given date and the current time.
 *
 * @param {string} inputDate - The date string to compare with the current time.
 * @returns {string} - A string describing the time difference.
 */
const getTimeDifferenceFromNow = (inputDate) => {
  const format = "MM/DD/YYYY hh:mm:ss A";
  const momentDate = moment.utc(inputDate, format);
  const now = moment.utc();

  const diffInMinutes = momentDate.diff(now, "minutes");
  const absDiff = Math.abs(diffInMinutes);

  if (diffInMinutes > 0) {
    return `in ${absDiff < 60 ? `${absDiff} minute${absDiff === 1 ? "" : "s"}` : `${Math.round(absDiff / 60)} hour${Math.round(absDiff / 60) === 1 ? "" : "s"}`}`;
  } else {
    return `${absDiff < 60 ? `${absDiff} minute${absDiff === 1 ? "" : "s"}` : `${Math.round(absDiff / 60)} hour${Math.round(absDiff / 60) === 1 ? "" : "s"}`} ago`;
  }
};

const eventMessagesCache = {};

async function readEventMessages(playerId) {
  if (eventMessagesCache[playerId]) {
    return eventMessagesCache[playerId];
  }
  try {
    const filePath = `./world_info/${playerId}/event_messages.txt`;
    const fileContent = await fs.readFile(filePath, "utf-8");
    const parsed = JSON.parse(fileContent);
    eventMessagesCache[playerId] = parsed;
    return parsed;
  } catch (error) {
    logger.log("Files", `Error reading event messages for player ${playerId}: ${error}`);
    return {};
  }
}

/**
 * Normalizes chat messages from various sources into a standard format
 * @param {object} messageData - Raw message from EventSub or API
 * @returns {object} - Standardized chat object
 */
export function normalizeMessageFormat(messageData) {
  // From EventSub webhook
  if (messageData.chatter && messageData.message && messageData.message.text) {
    return {
      user: messageData.chatter.user_name,
      userId: messageData.chatter.user_id,
      message: messageData.message.text,
      firstMessage: messageData.message.is_first || false,
      badges: messageData.chatter.badges?.map(badge => badge.set_id) || [],
      emotes: messageData.message.fragments
        ?.filter(f => f.type === 'emote')
        .map(e => ({ id: e.id, code: e.text })) || [],
      emoteCount: messageData.message.fragments?.filter(f => f.type === 'emote').length || 0,
      color: messageData.color,
      source: 'eventsub'
    };
  }
  
  // From Enspira API
  return {
    user: messageData.user,
    userId: messageData.userId || null,
    message: messageData.message,
    firstMessage: messageData.firstMessage || false,
    badges: messageData.badges || [],
    emotes: messageData.emotes || [],
    emoteCount: messageData.emoteCount || 0,
    color: messageData.color || null,
    source: 'api'
  };
}

/**
 * Generates a formatted string for a subscription event.
 *
 * @param {object} event - The subscription event data.
 * @returns {Promise<string>} - A formatted string describing the subscription event.
 */
const subMessage = async (event) => {
  const parsedAddons = await readEventMessages(event.playerId);
  const subValues = {
    prime: "$4.99",
    "tier 1": "$4.99",
    "tier 2": "$9.99",
    "tier 3": "$24.99",
  };
  const subValNum = {
    prime: 4.99,
    "tier 1": 4.99,
    "tier 2": 9.99,
    "tier 3": 24.99,
  };
  let subString = "";

  switch (event.eventData.subType) {
    case "sub":
      subString += `${event.eventData.user} just gave ${event.playerName} a ${event.eventData.subTier} sub! They spent ${subValues[event.eventData.subTier]} to give them a subscription. `;
      subString += event.eventData.multiMonth
        ? `They also decided to subscribe for ${event.eventData.monthLength} months, and have been subscribed for ${event.eventData.tenure} months so far! `
        : "";
      subString += event.eventData.primeUpgrade
        ? `They upgraded from their Twitch Prime subscription right into being a ${event.eventData.subTier} subscriber, paying ${subValues[event.eventData.subTier]} to do so! `
        : "";
      subString += event.eventData.paidForward
        ? "They decided to pay their gifted subscription forward! "
        : "";
      subString += event.eventData.message
        ? `${event.eventData.user} said this in the Twitch chat afterward:\n${event.eventData.message}`
        : "";
      break;
    case "resub":
      subString += `${event.eventData.user} just decided to resubscribe to ${event.playerName}'s Twitch channel! They resubscribed with a ${event.eventData.subTier} sub! `;
      subString += `They spent ${subValues[event.eventData.subTier]} to resubscribe. They're on a ${event.eventData.streak} month streak and have been a subscriber for ${event.eventData.tenure} months. `;
      subString += `${event.eventData.user} said the following in the Twitch chat afterward:\n${event.eventData.sharedChat}`;
      break;
    case "gift_sub":
      if (event.eventData.anonymous) {
        subString += `Some generous person just gave ${event.eventData.recipientUserName} a ${event.eventData.subTier} sub to ${event.playerName}'s Twitch channel! `;
        subString += `They spent ${subValues[event.eventData.subTier]} to gift this sub. `;
      } else {
        subString += `${event.eventData.user} just gave ${event.eventData.recipientUserName} a ${event.eventData.subTier} sub to ${event.playerName}'s Twitch channel! They spent ${subValues[event.eventData.subTier]} to gift this sub. `;
      }
      subString += event.eventData.random
        ? `This sub was randomly given to ${event.eventData.recipientUserName}. `
        : `This sub was specifically given to ${event.eventData.recipientUserName}. `;
      subString += `They're on a ${event.eventData.streak} month streak with their own sub, and have been a subscriber for ${event.eventData.tenure} months so far. `;
      if (event.eventData.anonymous) {
        subString += `Though they wished to be anonymous, they said the following in the Twitch chat afterward:\n${event.eventData.message}`;
      } else {
        subString += `${event.eventData.user} said the following in the Twitch chat afterward:\n${event.eventData.message}`;
      }
      break;
    case "gift_bomb":
      if (event.eventData.anonymous) {
        subString += `Some generous person just gave out ${event.eventData.giftAmt} ${event.eventData.subTier} subs to ${event.playerName}'s channel! `;
        subString += event.eventData.sharedAmt
          ? `They spent $${(subValNum[event.eventData.subTier] * event.eventData.giftAmt).toFixed(2)} on these subs. `
          : `Each sub was worth ${subValNum[event.eventData.subTier]}. `;
      } else {
        subString += `${event.eventData.user} just gave out ${event.eventData.giftAmt} ${event.eventData.subTier} subs to ${event.playerName}'s channel! `;
        subString += event.eventData.sharedAmt
          ? `They spent $${(subValNum[event.eventData.subTier] * event.eventData.giftAmt).toFixed(2)} on these subs. `
          : `Each sub was worth ${subValNum[event.eventData.subTier]}. `;
      }
      subString +=
        event.eventData.bonusGifts > 0
          ? `Twitch themselves also decided to add subs towards ${event.playerName}'s channel too! `
          : "";
      subString += event.eventData.anonymous
        ? `They said this in the chat afterward:\n${event.eventData.systemMessage}`
        : `${event.eventData.user} said this in the chat afterward:\n${event.eventData.systemMessage}`;
      break;
    default:
      break;
  }
  subString += `\n${parsedAddons.sub.replace("{{user}}", event.playerName)}`;
  return subString;
};

/**
 * Generates a formatted string for a donation event.
 *
 * @param {object} event - The donation event data.
 * @returns {Promise<string>} - A formatted string describing the donation event.
 */
const donoMessage = async (event) => {
  const parsedAddons = await readEventMessages(event.playerId);
  let subString = "";
  switch (event.eventData.donoType) {
    case "tip":
      subString += `A donation for ${event.eventData.donoAmt} just came through from ${event.eventData.donoFrom}! `;
      break;
    case "charity":
      subString += `A donation towards our favorite charity ${event.eventData.forCharity} just came through, in the amount of $${event.eventData.donoAmt}! `;
      break;
    case "bits":
      subString += `${event.eventData.donoFrom} just donated ${event.eventData.donoAmt} bits to ${event.playerName}'s channel! While each one of these is only worth a cent, they do stack up! `;
    default:
      break;
  }
  subString +=
    event.eventData.donoType === "charity"
      ? `\n${parsedAddons.charity.replace("{{user}}", event.playerName)}`
      : `They said this in a message:\n${event.eventData.donoMessage}\n${parsedAddons.dono.replace(
        "{{user}}",
        event.playerName,
      )}`;
  return subString;
};

/**
 * Generates a formatted string for a raid event.
 *
 * @param {object} event - The raid event data.
 * @returns {Promise<string>} - A formatted string describing the raid event.
 */
const raidMessage = async (event) => {
  const parsedAddons = await readEventMessages(event.playerId);
  let subString = `${event.eventData.username} just raided ${event.playerName}'s Twitch channel! `;
  subString += `${event.eventData.username} has been streaming for ${event.eventData.accountAge} as well! `;
  subString += event.eventData.isFollowing
    ? `They are not currently a follower of ${event.playerName}'s channel. `
    : `They are a follower of ${event.playerName}'s channel! `;
  subString += `They were last seen playing the video game ${event.eventData.lastGame} to their viewers! `;
  subString += `Their raid brought along ${event.eventData.viewers} viewers with them, who will now be eagerly watching ${event.playerName} stream and game!\n`;
  subString += parsedAddons.raid.replace("{{user}}", event.playerName);
  return subString;
};

/**
 * Generates a formatted string for a follow event.
 *
 * @param {object} event - The follow event data.
 * @returns {Promise<string>} - A formatted string describing the follow event.
 */
const followMessage = async (event) => {
  const parsedAddons = await readEventMessages(event.playerId);
  return `${event.eventData.username} just followed ${event.playerName}'s Twitch channel!\n\n${parsedAddons.follow.replace("{{user}}", event.playerName)}`;
};

/**
 * Generates a formatted string for a summary message during a break in streaming.
 *
 * @param {object} event - The summary event data.
 * @returns {Promise<string>} - A formatted string summarizing the stream's events.
 */
const summaryMessage = async (event) => {
  return `${event.playerName} is taking a small break from streaming. While ${event.playerName}'s away from their keyboard, briefly summarize the events in the stream using only the previous chat interactions and any other Twitch events that occured. Do not imagine any other details about the live stream, only use the provided context. Be creative in your summary and put a creative spin on things, but avoid responding with more than 500 characters.`;
};

/**
 * Generates a formatted string for a chat message event.
 *
 * @param {object} event - The chat message event data.
 * @returns {Promise<string>} - A formatted string describing the chat message event.
 */
const chatMessage = async (event) => {
  const parsedAddons = await readEventMessages(event.playerId);
  let subString = `${event.user} sent the following message in ${event.playerName}'s Twitch chat:\n${event.message}`;
  subString += event.firstMessage
    ? `\nThis is ${event.user}'s *first ever* chat message in ${event.playerName}'s Twitch channel as well!`
    : "";
  subString += `\n${parsedAddons.firstchat.replace(
    "{{user}}",
    event.playerName,
  )}`;
  return subString;
};

/**
 * Generates a formatted string for a hype train start event.
 *
 * @param {object} event - The hype train start event data.
 * @returns {Promise<string>} - A formatted string describing the hype train start event.
 */
const hypeStartMessage = async (event) => {
  const parsedAddons = await readEventMessages(event.playerId);
  let subString = `A hype train on ${event.playerName}'s channel just started!\n`;
  subString += `It is currently at level ${event.eventData.level}, started ${getTimeDifferenceFromNow(
    event.eventData.startedAt,
  )}, and will expire ${getTimeDifferenceFromNow(event.eventData.expiresAt)}.\n`;
  subString += `We are ${event.eventData.percent * 100
    }% of the way to level ${parseInt(event.eventData.level) + 1}!\n`;
  subString += `${event.eventData.topSubUser} has the most gifted subscriptions at ${event.eventData.topSubTotal} subs, and ${event.eventData.topBitsUser} has donated the most bits with ${event.eventData.topBitsAmt} bits donated!`;
  subString += "\n" + parsedAddons.hype;
  return subString;
};

/**
 * Generates a formatted string for a hype train update event.
 *
 * @param {object} event - The hype train update event data.
 * @returns {Promise<string>} - A formatted string describing the hype train update event.
 */
const hypeUpdateMessage = async (event) => {
  const parsedAddons = await readEventMessages(event.playerId);
  let subString = `Here's an update on the Hype Train ${event.playerName}'s channel has started:\n`;
  subString += `It is currently at level ${event.eventData.level}, started ${getTimeDifferenceFromNow(
    event.eventData.startedAt,
  )}, and will expire ${getTimeDifferenceFromNow(event.eventData.expiresAt)}.\n`;
  subString += `There are ${event.eventData.contributors} contributors!\n`;
  subString += event.eventData.isGolden
    ? `This is now a Golden Kappa train, a rare event rewarding contributors with the Golden Kappa emote for 24 hours!\n`
    : "";
  subString += `We are ${event.eventData.percent * 100
    }% of the way to level ${parseInt(event.eventData.level) + 1}!\n`;
  subString += `${event.eventData.topSubUser} has the most gifted subscriptions at ${event.eventData.topSubTotal} subs, and ${event.eventData.topBitsUser} has donated the most bits with ${event.eventData.topBitsAmt} bits donated!`;
  subString += "\n" + parsedAddons.hype;
  return subString;
};

/**
 * Generates a formatted string for a hype train end event.
 *
 * @param {object} event - The hype train end event data.
 * @returns {Promise<string>} - A formatted string describing the hype train end event.
 */
const hypeEndMessage = async (event) => {
  const parsedAddons = await readEventMessages(event.playerId);
  let subString = `The Hype Train on ${event.playerName}'s channel has just ended!\n`;
  subString += `It ended at level ${event.eventData.level}, started ${getTimeDifferenceFromNow(
    event.eventData.startedAt,
  )}, and reached ${event.eventData.percent * 100
    }% towards level ${parseInt(event.eventData.level) + 1}.\n`;
  subString += `There were ${event.eventData.contributors} contributors! `;
  subString += event.eventData.isGolden
    ? `This was a Golden Kappa train, a rare event rewarding contributors with the Golden Kappa emote for 24 hours.\n`
    : "";
  subString += `${event.eventData.topSubUser} gifted the most subscriptions at ${event.eventData.topSubTotal} subs, and ${event.eventData.topBitsUser} donated the most bits with ${event.eventData.topBitsAmt} bits donated!`;
  subString += "\n" + parsedAddons.hype;
  return subString;
};

/**
 * Generates a formatted string for a hype train level up event.
 *
 * @param {object} event - The hype train level up event data.
 * @returns {Promise<string>} - A formatted string describing the hype train level up event.
 */
const hypeLevelUpMessage = async (event) => {
  const parsedAddons = await readEventMessages(event.playerId);
  let subString = `The hype train on ${event.playerName}'s channel has just leveled up!\n`;
  subString += `It is now at level ${event.eventData.level}, started ${getTimeDifferenceFromNow(
    event.eventData.startedAt,
  )}, and will expire ${getTimeDifferenceFromNow(event.eventData.expiresAt)}.\n`;
  subString += `There are ${event.eventData.contributors} contributors!\n`;
  subString += event.eventData.isGolden
    ? `This is now a Golden Kappa train, a rare event rewarding contributors with the Golden Kappa emote for 24 hours!\n`
    : "";
  subString += `We are ${event.eventData.percent * 100
    }% of the way to level ${parseInt(event.eventData.level) + 1}!\n`;
  subString += `${event.eventData.topSubUser} has the most gifted subscriptions at ${event.eventData.topSubTotal} subs, and ${event.eventData.topBitsUser} has donated the most bits with ${event.eventData.topBitsAmt} bits donated!`;
  subString += "\n" + parsedAddons.hype;
  return subString;
};

/**
 * Generates a formatted string for a trivia message event.
 *
 * @param {object} event - The trivia message event data.
 * @returns {Promise<string>} - A formatted string containing a fun fact.
 */
const triviaMessage = async (event) => {
  return `You're about to receive a fun fact to tell all of the viewers of ${event.playerName}'s channel. Share the entirety of this fact, and your thoughts about it, to all of the viewers. Here is the fun fact:\n${await funFact()}`;
};



/**
 * Generates a formatted string for a shoutout message event.
 *
 * @param {object} event - The shoutout message event data.
 * @returns {Promise<string>} - A formatted string describing the shoutout event.
 */
const shoutoutMessage = async (event) => {
  let subString = `${event.playerName} wants you to give ${event.eventData.user} a shoutout in their Twitch channel! Here is some information regarding ${event.eventData.user} to consider when shouting them out!\n`;
  subString += `${event.eventData.user} started their streaming career ${getTimeDifferenceFromNow(
    event.eventData.accountAge,
  )}!\n`;
  subString += `The last time ${event.eventData.user} was live, they were streaming ${event.eventData.game} for their viewers! `;
  subString += `${event.eventData.user} was last active ${getTimeDifferenceFromNow(
    event.eventData.lastActive,
  )} on their channel! The title of their last stream was '${event.eventData.streamTitle
    }'. `;
  subString += event.eventData.isMod
    ? `They are also a moderator in ${event.playerName}'s Twitch channel!\n`
    : "";
  subString += event.eventData.isAffiliate
    ? `They are also a Twitch affiliate!\n`
    : "";
  subString += event.eventData.isPartner
    ? `They are also an official Twitch partner!\n`
    : "";
  subString += event.eventData.isSubbed
    ? `They are also currently subscribed to ${event.playerName}'s Twitch channel!\n`
    : "";
  subString += `Make sure you give ${event.eventData.user} the type of hype-up you can only get from ${event.playerName}'s Twitch channel!`;
  return subString;
};

/**
 * Generates a formatted string for an ad message event.
 *
 * @param {object} event - The ad message event data.
 * @returns {Promise<string>} - A formatted string describing the ad event.
 */
const adMessage = async (event) => {
  return `Give a heads up to the viewers of ${event.playerName}'s channel that ads will be coming in ${event.minutesLeft} minutes. Playfully hint towards avoiding the ads by subscribing to ${event.playerName}'s channel, and how much it would mean to you.`;
};

/**
 * Retrieves and formats social media information for a user.
 * Enhanced to better support template variables and specific platform requests.
 *
 * @param {string} userId - The ID of the user.
 * @param {string} [platform] - If provided, returns information for a specific platform.
 * @returns {Promise<string|object>} - A formatted string, specific platform value, or object containing social media information.
 */
async function socialMedias(userId, platform = "") {
  try {
    const currentUser = await returnAuthObject(userId);
    
    if (!currentUser?.socials) {
      return platform ? "" : "";
    }
    
    // Return all social media as an object if requested
    if (platform === "all") {
      return { ...currentUser.socials };
    }

    // Normalize platform name and return specific value if requested
    const normalizedPlatform = normalizePlatformName(platform);
    if (normalizedPlatform) {
      return currentUser.socials[normalizedPlatform] || "";
    }

    // Format all available platforms for template use
    return Object.entries(currentUser.socials)
      .filter(([_, value]) => value?.trim())
      .map(([key, value]) => formatSocialMediaValue(key, value))
      .filter(Boolean)
      .join(", ")
      ? `(${Object.entries(currentUser.socials)
          .filter(([_, value]) => value?.trim())
          .map(([key, value]) => formatSocialMediaValue(key, value))
          .filter(Boolean)
          .join(", ")})`
      : "";
  } catch (error) {
    logger.log("System", `Error retrieving social media: ${error.message}`);
    return platform ? "" : "";
  }
}

/**
 * Normalizes platform names to consistent keys.
 * 
 * @param {string} platform - The platform identifier to normalize.
 * @returns {string} - The normalized platform key.
 */
function normalizePlatformName(platform) {
  if (!platform) return "";
  
  const platformMap = {
    // TikTok variations
    "tt": "tiktok",
    "tik": "tiktok",
    "tiktok": "tiktok",
    
    // YouTube variations
    "yt": "youtube",
    "youtube": "youtube",
    
    // Twitter/X variations
    "twitter": "twitter",
    "x": "twitter",
    "tweet": "twitter",
    
    // Twitch
    "twitch": "twitch",
    
    // Instagram
    "ig": "instagram",
    "insta": "instagram",
    "instagram": "instagram",
    
    // Discord
    "discord": "discord",
    
    // Kick
    "kick": "kick",
    
    // Facebook
    "fb": "facebook",
    "facebook": "facebook",
    
    // Other common platforms
    "linkedin": "linkedin",
    "github": "github",
    "reddit": "reddit"
  };
  
  return platformMap[platform.toLowerCase()] || platform.toLowerCase();
}

/**
 * Formats a social media value for display.
 * 
 * @param {string} platform - The platform name.
 * @param {string} value - The social media handle or URL.
 * @returns {string} - Formatted social media value.
 */
function formatSocialMediaValue(platform, value) {
  if (!value || value.trim() === "") return "";
  
  let formattedValue = value.trim();
  
  // Add @ prefix for handles if not present
  const handlePlatforms = ["twitter", "tiktok", "instagram"];
  if (handlePlatforms.includes(platform.toLowerCase()) && !formattedValue.startsWith("@")) {
    formattedValue = `@${formattedValue}`;
  }
  
  return `${formattedValue}`;
}

export { 
  socialMedias,
  normalizePlatformName, // Export for testing or direct use
  formatSocialMediaValue // Export for testing or direct use
};

/**
 * Checks if an input string matches any of a user's social media identifiers.
 *
 * @param {string} input - The input string to check.
 * @param {string} userId - The ID of the user.
 * @returns {Promise<boolean>} - True if a match is found, false otherwise.
 */
async function checkForUser(input, userId) {
  const socialMediaObj = await socialMedias(userId, "all");

  if (Object.keys(socialMediaObj).length === 0) {
    logger.log("System", "socialMediaObj is empty.");
    return false;
  }

  const normalizedInput = input.trim().toLowerCase();
  return Object.values(socialMediaObj).some((value) => {
    const normalizedValue = value.trim().toLowerCase();
    return normalizedValue === normalizedInput;
  });
}

/**
 * Checks if a message matches any command in the user's command list.
 *
 * @param {string} message - The message to check.
 * @param {string} userId - The ID of the user.
 * @returns {Promise<boolean>} - True if the message matches a command, false otherwise.
 */
const isCommandMatch = async (message, userId) => {
  const userObj = await returnAuthObject(userId);
  const commandRegex = new RegExp(
    `^(${userObj.commands_list.join("|")})$`,
    "i",
  );
  return commandRegex.test(message);
};

/**
 * Prepares a moderation chat request by formatting the message and adding relevant context.
 *
 * @param {string} userName - The name of the user being moderated.
 * @param {string} userMessage - The message from the user.
 * @param {number} emoteCount - The number of emotes in the message.
 * @param {string} userId - The ID of the user associated with the moderation.
 * @returns {Promise<string|object>} - The moderation action to take, or an object with details for further action.
 */
async function prepareModerationChatRequest(
  userName,
  userMessage,
  emoteCount,
  userId,
) {
  try {
    const strikeInfo = await getStrikesByUserName(userName, userId);
    const banInfo = await checkBanned(userName, userId);
    const userStrikes = strikeInfo.strikes;
    const userObject = await returnAuthObject(userId);

    let userMessageFormatted = `${userName} sent the following message:\n\`${userMessage}\`\nThey have ${userStrikes} strikes currently.\nThey sent ${emoteCount} emotes.`;

    if (userStrikes === 2) {
      userMessageFormatted += userObject.global_strikes
        ? `\n${userName} has ${userStrikes} strikes across all users platforms. This is their last strike. If they commit another offense, apply a ban.`
        : `\nThis is ${userName}'s last strike on ${userObject.user_name}'s channel. If they commit another offense, apply a ban.`;
    } else if (userStrikes >= 3) {
      userMessageFormatted += userObject.global_bans
        ? `\n${userName} has surpassed their max strikes on all user platforms. Apply a ban immediately regardless of their offense.`
        : `\n${userName} has surpassed their max strikes on ${userObject.user_name}'s channel. Apply a ban immediately regardless of their offense.`;
    }

    if (banInfo.banned) {
      userMessageFormatted += `\n${userName} has been banned in ${banInfo.banCount} other communities. Per ${userObject.user_name}'s request, apply a ban immediately regardless of their offense.`;
    }

    const moderationPrompt = await moderatorPrompt(
      userMessageFormatted,
      userId,
    );

    const completion = await sendChatCompletionRequest(moderationPrompt, await retrieveConfigValue("models.moderator"));
    const formattedCompletion = JSON.parse(completion.response)
    if (formattedCompletion.actionNeeded == true) {
      const reason = formattedCompletion.reason
      const action = formattedCompletion.actionType
      if (action === "strike") {
        logger.log(
          "Moderation",
          `${userName} earned a strike in ${userObject.twitch_name}'s channel. Reason: ${reason}'`,
        );
        const newStrikes = await incrementStrikes(userName, userId);
        return {
          action,
          reason,
          user: userName,
          userMsg: userMessage,
          strikeCount: newStrikes.strikes,
        };
      } else if (action === "ban") {
        logger.log(
          "Moderation",
          `${userName} received a ${action} in ${userObject.twitch_name}'s channel. Reason: '${reason}'`,
        );
        await addBanToUser(userName, userObject.twitch_name);
        return {
          action,
          reason,
          user: userName,
          userMsg: userMessage,
        };
      }
    } else {
      return "safe"
    }
  } catch (error) {
    logger.log("Moderation", `Error creating mod chat completion: ${error}`);
    return "error";
  }
}

/**
 * Retrieves the number of strikes for a given user.
 *
 * @param {string} userName - The name of the user.
 * @param {string} userId - The ID of the user associated with the strikes.
 * @returns {Promise<object>} - An object containing the user name and their number of strikes.
 */
const getStrikesByUserName = async (userName, userId) => {
  const userObject = await returnAuthObject(userId);
  try {
    const data = await fs.readFile("./data/global/strikes.json", "utf8");

    if (!data.trim()) {
      logger.log("Moderation", "The strike list is currently empty.");
      return { userName, strikes: 0 };
    }

    const strikes = JSON.parse(data);

    if (userObject.global_strikes && strikes.hasOwnProperty(userName)) {
      const sumOfAllStrikes = Object.values(strikes[userName]).reduce(
        (sum, count) => sum + count,
        0,
      );
      return { userName, strikes: sumOfAllStrikes };
    } else if (strikes.hasOwnProperty(userName)) {
      return {
        userName,
        strikes: strikes[userName][userObject.twitch_name] || 0,
      };
    } else {
      return { userName, strikes: 0 };
    }
  } catch (error) {
    logger.log(
      "Moderation",
      `Error reading or parsing the JSON file: ${error}`,
    );
  }
};

/**
 * Increments the strike count for a given user.
 *
 * @param {string} userName - The name of the user.
 * @param {string} userId - The ID of the user associated with the strikes.
 * @returns {Promise<object>} - An object containing the user name and their updated number of strikes.
 */
async function incrementStrikes(userName, userId) {
  const userObject = await returnAuthObject(userId);
  const strikesFilePath = "./data/global/strikes.json";

  try {
    await fs.ensureFile(strikesFilePath);
    let strikes = {};

    const data = await fs.readFile(strikesFilePath, "utf8");
    if (data.trim()) {
      strikes = JSON.parse(data);
    }

    if (!strikes.hasOwnProperty(userName)) {
      strikes[userName] = {};
    }

    strikes[userName][userObject.twitch_name] =
      (strikes[userName][userObject.twitch_name] || 0) + 1;

    await fs.writeFile(
      strikesFilePath,
      JSON.stringify(strikes, null, 2),
      "utf8",
    );

    return { userName, strikes: strikes[userName][userObject.twitch_name] };
  } catch (error) {
    logger.log("Moderation", `Error updating strikes: ${error}`, "err");
  }
}

/**
 * Checks if a user is banned and retrieves their ban information.
 *
 * @param {string} userName - The name of the user to check.
 * @param {string} userId - The ID of the user associated with the ban list.
 * @returns {Promise<object>} - An object containing ban information.
 */
const checkBanned = async (userName, userId) => {
  try {
    const bansData = JSON.parse(
      await fs.readFile("./data/global/bans.json", "utf-8"),
    );
    const userObject = await returnAuthObject(userId);

    if (userObject.global_bans && bansData.hasOwnProperty(userName)) {
      const streamerBans = bansData[userName]; // Array of streamers where the user is banned
      return {
        banned: true,
        streamerBans,
        banCount: streamerBans.length,
      };
    } else {
      return {
        banned: false,
        streamerBans: [],
        banCount: 0,
      };
    }
  } catch (error) {
    logger.log("Moderator", `Error reading or processing bans.json: ${error}`);
  }
};

/**
 * Adds a ban for a user in a specific streamer's context.
 *
 * @param {string} userName - The name of the user to ban.
 * @param {string} streamerName - The name of the streamer banning the user.
 * @returns {Promise<void>}
 */
const addBanToUser = async (userName, streamerName) => {
  try {
    const bansFilePath = "./data/global/bans.json";
    await fs.ensureFile(bansFilePath);

    let bansData = {};
    const data = await fs.readFile(bansFilePath, "utf8");
    if (data.trim()) {
      bansData = JSON.parse(data);
    }

    if (!bansData.hasOwnProperty(userName)) {
      bansData[userName] = [];
    }

    if (!bansData[userName].includes(streamerName)) {
      bansData[userName].push(streamerName);
      await fs.writeFile(
        bansFilePath,
        JSON.stringify(bansData, null, 2),
        "utf8",
      );
      logger.log(
        "System",
        `Banned ${userName} from ${streamerName}'s channel.`,
      );
    } else {
      logger.log(
        "Moderator",
        `${streamerName} is already in ${userName}'s ban list.`,
      );
    }
  } catch (error) {
    logger.log("Moderator", `Error reading or updating bans.json: ${error}`);
  }
};

/**
 * Checks if it's time to generate a fun fact based on the user's settings
 * @param {string} userId - The user ID
 * @returns {Promise<boolean>} - True if it's time for a fun fact, false otherwise
 */
export async function shouldGenerateFunFact(userId) {
  try {
    const user = await returnAuthObject(userId);
    
    // If fun facts are disabled, return false
    if (!user.funFacts) {
      return false;
    }
    
    const now = Date.now();
    const lastTime = lastFunFactTime.get(userId) || 0;
    const interval = (user.funFactsInterval || 30) * 60 * 1000; // Convert minutes to milliseconds
    
    // Check if enough time has passed since the last fun fact
    if (now - lastTime >= interval) {
      // Update the last fun fact time
      lastFunFactTime.set(userId, now);
      return true;
    }
    
    return false;
  } catch (error) {
    logger.error("Twitch", `Error checking fun fact timing: ${error.message}`);
    return false;
  }
}

/**
 * Removes a ban for a user in a specific streamer's context.
 *
 * @param {string} userName - The name of the user to unban.
 * @param {string} streamerName - The name of the streamer unbanning the user.
 * @returns {Promise<void>}
 */
const undoBan = async (userName, streamerName) => {
  try {
    const bansFilePath = "./data/global/bans.json";
    await fs.ensureFile(bansFilePath);

    let bansData = {};
    const data = await fs.readFile(bansFilePath, "utf8");
    if (data.trim()) {
      bansData = JSON.parse(data);
    }

    if (!bansData.hasOwnProperty(userName)) {
      logger.log(
        "Moderator",
        `User ${userName} does not exist in the ban list.`,
      );
      return;
    }

    const userBans = bansData[userName];
    const index = userBans.indexOf(streamerName);

    if (index !== -1) {
      userBans.splice(index, 1);
      if (userBans.length === 0) {
        delete bansData[userName]; // Remove the user entry if the ban list is empty
      }
      await fs.writeFile(
        bansFilePath,
        JSON.stringify(bansData, null, 2),
        "utf8",
      );
      logger.log(
        "System",
        `Removed ${streamerName} from ${userName}'s ban list.`,
      );
    } else {
      logger.log(
        "Moderator",
        `${streamerName} is not in ${userName}'s ban list.`,
      );
    }
  } catch (error) {
    logger.log("Moderator", `Error reading or updating bans.json: ${error}`);
  }
};

/**
 * Checks if a message contains any of the auxiliary bot names associated with a user.
 *
 * @param {string} message - The message to check.
 * @param {string} userId - The ID of the user associated with the auxiliary bots.
 * @returns {Promise<boolean>} - True if the message contains any of the auxiliary bot names, false otherwise.
 */
async function containsAuxBotName(message, userId) {
  const userObj = await returnAuthObject(userId);
  const auxBots = userObj.aux_bots;

  if (typeof message !== "string" || !Array.isArray(auxBots)) {

  }

  const lowerCaseMessage = message.toLowerCase();
  return auxBots.some((botName) =>
    lowerCaseMessage.includes(botName.toLowerCase()),
  );
}

export {
  returnTwitchEvent,
  isCommandMatch,
  prepareModerationChatRequest,
  incrementStrikes,
  getStrikesByUserName,
  checkForUser,
  containsAuxBotName,
  checkBanned,
  undoBan
};
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*
package-lock.json

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock
auth_keys.json
# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port
*.env
# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*
data/*
world_info/*
instructs/*
resources/*
.prettierrc
*.json
!*.example.json
!package.json
*.key
*.crt
start.sh
final/*
temp/*
*.go
go.mod
go.sum
bin/*
logs/*
*.sh
repomix-output.md
images/*
PRIVACY_POLICY.md
</file>

<file path="package.json">
{
  "name": "streamer-llm",
  "version": "1.0.2",
  "description": "Just a Node.js interface to a chat completion API to create responses and (optionally) send them to a TTS service",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Prolix OCs",
  "license": "ISC",
  "dependencies": {
    "@fastify/compress": "^8.0.1",
    "@fastify/cookie": "^11.0.2",
    "@fastify/cors": "^10.0.1",
    "@fastify/formbody": "^8.0.1",
    "@fastify/multipart": "^9.0.3",
    "@fastify/rate-limit": "^10.2.1",
    "@fastify/static": "^8.1.1",
    "@fastify/view": "^11.0.0",
    "@fastify/websocket": "^11.0.1",
    "@mozilla/readability": "^0.6.0",
    "@zilliz/milvus2-sdk-node": "^2.5.5",
    "ansi-colors-es6": "^5.0.0",
    "axios": "^1.7.7",
    "chalk": "^5.3.0",
    "cheerio": "^1.0.0",
    "commander": "^12.1.0",
    "fast-levenshtein": "^3.0.0",
    "fastify": "^5.0.0",
    "ffmpeg-static": "^5.2.0",
    "form-data": "^4.0.2",
    "fs-extra": "^11.2.0",
    "jsdom": "^25.0.1",
    "jsonrepair": "^3.11.2",
    "mediainfo.js": "^0.3.3",
    "moment": "^2.30.1",
    "mongoose": "^8.13.1",
    "neo-blessed": "^0.2.0",
    "node-addon-api": "^8.2.1",
    "node-cron": "^3.0.3",
    "node-web-audio-api": "^1.0.4",
    "nunjucks": "^3.2.4",
    "openai": "^4.68.4",
    "puppeteer": "^23.10.4",
    "readline": "^1.3.0",
    "tokenizers": "^0.13.3",
    "tokenizers-linux-x64-gnu": "^0.13.4-rc1",
    "untruncate-json": "^0.0.1",
    "uuid": "^11.1.0",
    "ws": "^8.18.0",
    "zod": "^3.24.1"
  },
  "overrides": {
    "whatwg-url": "14.x",
    "tough-cookie": "5.x"
  },
  "events": {
    "start": "node -e console.clear() "
  },
  "devDependencies": {
    "prettier": "3.4.2"
  }
}
</file>

<file path="routes/web.js">
// routes/web.js
import fs from "fs-extra";
import path from "path";
import { returnAuthObject, updateUserParameter } from "../api-helper.js";
import { logger } from "../create-global-logger.js";
import { fileURLToPath } from "url";
import { dirname } from "path";
import { getChatCount } from "../mongodb-client.js";
import {
  loadPreset,
  loadAllPresets,
  hashPassword,
  isPasswordCorrect,
} from "./v1.js";

// Get the directory name properly in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

/**
 * Loads text content from a file if it exists, or returns an empty string
 * @param {string} userId - The user ID
 * @param {string} fileName - The file name
 * @returns {Promise<string>} - The file content or empty string
 */
async function loadTextContent(userId, fileName) {
  try {
    const filePath = path.join(
      process.cwd(),
      "world_info",
      userId,
      `${fileName}.txt`
    );

    // Create directory if it doesn't exist
    await fs.ensureDir(path.join(process.cwd(), "world_info", userId));

    // Check if file exists
    const exists = await fs.pathExists(filePath);
    if (!exists) {
      return "";
    }

    // Read file content
    return await fs.readFile(filePath, "utf8");
  } catch (error) {
    logger.error(
      "Web",
      `Error loading ${fileName} for user ${userId}: ${error.message}`
    );
    return "";
  }
}

// Import verifySessionToken function from existing auth code
import { verifySessionToken } from "./v1.js";

/**
 * Authentication middleware for web routes
 * @param {object} request - The request object
 * @param {object} reply - The reply object
 * @returns {Promise<void>}
 */
async function requireAuth(request, reply) {
  // Check if cookies object exists and if the enspira_session cookie is set
  const sessionToken = request.cookies?.enspira_session;

  if (!sessionToken) {
    logger.log("Auth", "No session token found, redirecting to login");
    return reply.redirect("/web/auth/login"); // Updated path
  }

  try {
    // Verify and decode the session token
    const decoded = verifySessionToken(sessionToken);

    if (!decoded || !decoded.userId) {
      // Invalid token
      reply.clearCookie("enspira_session");
      return reply.redirect("/web/auth/login"); // Updated path
    }

    // Get user from database
    const user = await returnAuthObject(decoded.userId);

    if (!user) {
      // User doesn't exist
      reply.clearCookie("enspira_session");
      return reply.redirect("/web/auth/login"); // Updated path
    }

    // Add user to request for use in route handlers
    request.user = user;

    // Continue to route handler
    return;
  } catch (error) {
    logger.error("Auth", `Session validation error: ${error.message}`);
    reply.clearCookie("enspira_session");
    return reply.redirect("/web/auth/login"); // Updated path
  }
}

// Helper function to extract form field values
function getFieldValue(field) {
  if (!field) return "";

  // If the field is a Part object from @fastify/multipart
  if (field.value !== undefined) {
    return field.value;
  }

  // If the field is already a string
  if (typeof field === "string") {
    return field;
  }

  // If the field is a readable stream (file upload)
  if (field.pipe && typeof field.pipe === "function") {
    // For this implementation, we're not handling file uploads
    return "";
  }

  // Return empty string for any other case
  return "";
}

// Setup the web routes
async function webRoutes(fastify, options) {
  // Register the form body parser to ensure form submissions work
  await fastify.register(import("@fastify/formbody"));

  // Ensure the pages directory exists
  await fs.ensureDir(path.join(process.cwd(), "pages"));
  fastify.get(
    "/settings",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // List of common time zones
        const timeZones = [
          { value: "America/New_York", label: "Eastern Time (ET)" },
          { value: "America/Chicago", label: "Central Time (CT)" },
          { value: "America/Denver", label: "Mountain Time (MT)" },
          { value: "America/Los_Angeles", label: "Pacific Time (PT)" },
          { value: "America/Anchorage", label: "Alaska Time (AKT)" },
          { value: "Pacific/Honolulu", label: "Hawaii Time (HT)" },
          { value: "Europe/London", label: "Greenwich Mean Time (GMT)" },
          { value: "Europe/Paris", label: "Central European Time (CET)" },
          { value: "Europe/Helsinki", label: "Eastern European Time (EET)" },
          { value: "Asia/Tokyo", label: "Japan Standard Time (JST)" },
          { value: "Australia/Sydney", label: "Australian Eastern Time (AET)" },
        ];

        // Initialize socials object if it doesn't exist
        if (!user.socials) {
          user.socials = {};
        }

        // Render settings page
        return reply.view("settings.njk", {
          pageTitle: "User Settings",
          settingsActive: true,
          user,
          timeZones,
          success: request.query.success,
          error: request.query.error,
        });
      } catch (error) {
        logger.error("Web", `Error serving settings page: ${error.message}`);
        return reply.code(500).send("Error loading settings page");
      }
    }
  );

  // Profile settings update endpoint
  fastify.post(
    "/settings/profile",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Extract values from form data
        const displayName = getFieldValue(request.body.display_name);
        const userName = getFieldValue(request.body.user_name);
        const email = getFieldValue(request.body.email);
        const timeZone = getFieldValue(request.body.timeZone);

        // Update user parameters
        await updateUserParameter(user.user_id, "display_name", displayName);
        await updateUserParameter(user.user_id, "user_name", userName);

        if (email) {
          await updateUserParameter(user.user_id, "email", email);
        }

        if (timeZone) {
          await updateUserParameter(user.user_id, "timeZone", timeZone);
        }

        return reply.send({
          success: true,
          message: "Profile settings updated successfully",
        });
      } catch (error) {
        logger.error(
          "Web",
          `Error updating profile settings: ${error.message}`
        );
        return reply.code(500).send({
          success: false,
          error: "An error occurred while updating profile settings",
        });
      }
    }
  );

  // Social media settings update endpoint
  fastify.post(
    "/settings/socials",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Ensure socials object exists in user record
        if (!user.socials) {
          await updateUserParameter(user.user_id, "socials", {});
        }

        // Build the socials object
        const socials = {};

        // Process each social media platform
        const platforms = [
          "twitter",
          "tiktok",
          "youtube",
          "instagram",
          "twitch",
          "kick",
        ];

        for (const platform of platforms) {
          socials[platform] = getFieldValue(
            request.body[`socials[${platform}]`]
          );
        }

        // Update user parameter
        await updateUserParameter(user.user_id, "socials", socials);

        return reply.send({
          success: true,
          message: "Social media settings updated successfully",
        });
      } catch (error) {
        logger.error(
          "Web",
          `Error updating social media settings: ${error.message}`
        );
        return reply.code(500).send({
          success: false,
          error: "An error occurred while updating social media settings",
        });
      }
    }
  );
  // Password update endpoint
  fastify.post(
    "/settings/password",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Extract values from form data
        const currentPassword = getFieldValue(request.body.current_password);
        const newPassword = getFieldValue(request.body.new_password);
        const confirmPassword = getFieldValue(request.body.confirm_password);

        // Validate passwords
        if (newPassword !== confirmPassword) {
          return reply.code(400).send({
            success: false,
            error: "New passwords do not match",
          });
        }

        // Check if password is already set
        if (!user.webPasswordHash || !user.webPasswordSalt) {
          // No password set yet, just set the new one
          const passwordData = await hashPassword(newPassword);

          await updateUserParameter(
            user.user_id,
            "webPasswordHash",
            passwordData.hash
          );
          await updateUserParameter(
            user.user_id,
            "webPasswordSalt",
            passwordData.salt
          );
          await updateUserParameter(
            user.user_id,
            "webPasswordIterations",
            passwordData.iterations
          );

          return reply.send({
            success: true,
            message: "Password set successfully",
          });
        }

        // Verify current password
        const iterations = user.webPasswordIterations || 20480;
        const passwordCorrect = await isPasswordCorrect(
          user.webPasswordHash,
          user.webPasswordSalt,
          iterations,
          currentPassword
        );

        if (!passwordCorrect) {
          return reply.code(401).send({
            success: false,
            error: "Current password is incorrect",
          });
        }

        // Set new password
        const passwordData = await hashPassword(newPassword);

        await updateUserParameter(
          user.user_id,
          "webPasswordHash",
          passwordData.hash
        );
        await updateUserParameter(
          user.user_id,
          "webPasswordSalt",
          passwordData.salt
        );
        await updateUserParameter(
          user.user_id,
          "webPasswordIterations",
          passwordData.iterations
        );

        return reply.send({
          success: true,
          message: "Password updated successfully",
        });
      } catch (error) {
        logger.error("Web", `Error updating password: ${error.message}`);
        return reply.code(500).send({
          success: false,
          error: "An error occurred while updating password",
        });
      }
    }
  );
  // Dashboard route
  fastify.get(
    "/dashboard",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Ensure we have proper defaults for all values the template uses
        const streamerConnected = !!user?.twitch_tokens?.streamer?.access_token;
        const botConnected = !!user?.twitch_tokens?.bot?.access_token;
        const streamerName = streamerConnected
          ? user.twitch_tokens.streamer.twitch_display_name || "Unknown"
          : "";
        const botName = botConnected
          ? user.twitch_tokens.bot.twitch_display_name || "Unknown"
          : "";

        // Set default stats
        const stats = {
          chatMessages: 0,
        };

        // Try to get actual chat count
        try {
          const recentChats = await getChatCount(user.user_id);
          stats.chatMessages = recentChats || 0;
        } catch (error) {
          logger.error("Web", `Error fetching chat stats: ${error.message}`);
        }

        // Always initialize streamStatus with default values for all properties
        let streamStatus = {
          online: false,
          title: "",
          game: "",
          viewers: 0,
          duration: "",
          thumbnail: null,
        };

        let followerCount = user.current_followers || 0;
        let lastGame = user.current_game?.game || "None";

        if (user.twitch_tokens?.streamer?.twitch_user_id) {
          try {
            const { fetchStreamInfo } = await import(
              "../twitch-eventsub-manager.js"
            );
            const streamInfo = await fetchStreamInfo(user.user_id);

            if (streamInfo && streamInfo.success && streamInfo.isLive) {
              // Update streamStatus with actual values
              streamStatus = {
                online: true,
                title: streamInfo.data.title || "Untitled Stream",
                game: streamInfo.data.gameName || "Unknown Game",
                viewers: streamInfo.data.viewerCount || 0,
                duration: streamInfo.data.duration || "Just started",
                thumbnail: streamInfo.data.thumbnailUrl || null,
              };
            }

            followerCount = user.current_followers || 0;
          } catch (error) {
            logger.error("Web", `Error fetching stream info: ${error.message}`);
          }
        }

        // Log complete data being sent to template
        logger.log(
          "Web",
          `Rendering dashboard with streamStatus: ${JSON.stringify(streamStatus)}`
        );

        return reply.view("dashboard.njk", {
          pageTitle: "Dashboard",
          dashboardActive: true,
          user: {
            display_name: user.display_name || user.user_name,
          },
          streamerConnected,
          botConnected,
          streamerName,
          botName,
          stats,
          streamStatus,
          followerCount,
          lastGame,
        });
      } catch (error) {
        logger.error("Web", `Error serving dashboard: ${error.message}`);
        return reply.code(500).send("Error loading dashboard");
      }
    }
  );

  // Character editor route
  fastify.get(
    "/character",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Load character data from files
        const characterPersonality = await loadTextContent(
          user.user_id,
          "character_personality"
        );
        const characterDescription = await loadTextContent(
          user.user_id,
          "character_card"
        );
        const characterExamples = await loadTextContent(
          user.user_id,
          "examples"
        );

        return reply.view("character.njk", {
          pageTitle: "Character Editor",
          characterActive: true,
          user,
          character: user,
          characterPersonality,
          characterDescription,
          characterExamples,
        });
      } catch (error) {
        logger.error("Web", `Error serving character editor: ${error.message}`);
        return reply.code(500).send("Error loading character editor");
      }
    }
  );

  // World editor route
  fastify.get("/world", { preHandler: requireAuth }, async (request, reply) => {
    try {
      const user = request.user;

      // Load world data from files
      const worldInfo = await loadTextContent(user.user_id, "world_lore");
      const playerInfo = await loadTextContent(user.user_id, "player_info");
      const scenario = await loadTextContent(user.user_id, "scenario");

      // Format commands list and aux bots for textarea
      const commandsList = user.commands_list
        ? user.commands_list.join("\n")
        : "";
      const auxBots = user.aux_bots ? user.aux_bots.join("\n") : "";

      return reply.view("world.njk", {
        pageTitle: "World Editor",
        worldActive: true,
        user,
        character: user,
        worldInfo,
        playerInfo,
        scenario,
        commandsList,
        auxBots,
      });
    } catch (error) {
      logger.error("Web", `Error serving world editor: ${error.message}`);
      return reply.code(500).send("Error loading world editor");
    }
  });

  // Help page route
  fastify.get("/help", { preHandler: requireAuth }, async (request, reply) => {
    try {
      return reply.view("help.njk", {
        pageTitle: "Help & Documentation",
        helpActive: true,
      });
    } catch (error) {
      logger.error("Web", `Error serving help page: ${error.message}`);
      return reply.code(500).send(`Error loading help page: ${error.message}`);
    }
  });

  // Gallery route
  fastify.get(
    "/gallery",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Load all character presets
        const presets = await loadAllPresets();

        // Add placeholder images for presets that don't have one
        presets.forEach((preset) => {
          if (!preset.image) {
            preset.image = "/api/placeholder/200/200";
          }
        });

        return reply.view("gallery.njk", {
          pageTitle: "Character Gallery",
          galleryActive: true,
          presets,
          user,
        });
      } catch (error) {
        logger.error("Web", `Error serving gallery: ${error.message}`);
        return reply.code(500).send("Error loading character gallery");
      }
    }
  );

  fastify.get(
    "/gallery/:characterId",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;
        const { characterId } = request.params;

        // Load the character preset data
        const characterData = await loadPreset(characterId);

        if (!characterData) {
          logger.warn("Web", `Character preset '${characterId}' not found`);
          return reply.redirect("/web/gallery");
        }

        // Add placeholder image if missing
        if (!characterData.image) {
          characterData.image = "/api/placeholder/200/200";
        }

        return reply.view("character-details.njk", {
          pageTitle: characterData.name,
          galleryActive: true,
          character: characterData,
          user,
        });
      } catch (error) {
        logger.error(
          "Web",
          `Error serving character details: ${error.message}`
        );
        return reply.code(500).send("Error loading character details");
      }
    }
  );

  // Authentication routes
  fastify.get("/auth/login", async (request, reply) => {
    return reply.view("login.njk", {
      pageTitle: "Login",
      error: request.query.error || null,
    });
  });

  fastify.get("/auth/logout", async (request, reply) => {
    reply.clearCookie("enspira_session");
    return reply.redirect("/web/auth/login");
  });

  // Redirect root to dashboard
  fastify.get("/", (request, reply) => {
    return reply.redirect("/web/dashboard");
  });
  
  logger.log("Web", "Web routes registered successfully");
}

export default webRoutes;
</file>

<file path="api-helper.js">
import fs from "fs-extra";
import axios from "axios";
import cron from "node-cron";
import * as crypto from "crypto";
import path from "path";
import { 
  connectToMongoDB, 
  getUserById, 
  getAllUsers, 
  updateUserData,
  ensureUserPath,
  flushAllChanges
} from './mongodb-client.js';
import { retrieveConfigValue } from "./config-helper.js";
import { logger } from './create-global-logger.js';
let cachedAuthKeys = null;

const authFilePath = await retrieveConfigValue("server.authFilePath");

/**
 * Loads API keys from MongoDB
 * @returns {Promise<void>}
 */
async function loadAPIKeys() {
  try {
    // Connect to MongoDB
    const connected = await connectToMongoDB();
    
    if (!connected) {
      logger.error("API", "Could not connect to MongoDB, using empty user list");
      cachedAuthKeys = [];
      return;
    }
    
    // No need to cache here as getUserById handles caching
    logger.log("API", "MongoDB connection established");
  } catch (err) {
    logger.error("API", `Error initializing MongoDB: ${err.message}`);
    cachedAuthKeys = [];
  }
}

/**
 * Returns a copy of all users
 * @returns {Promise<object[]>} A promise that resolves to an array of user objects
 */
const returnAPIKeys = async () => {
  try {
    return await getAllUsers();
  } catch (error) {
    logger.error("API", `Error fetching all users: ${error.message}`);
    return [];
  }
};

/**
 * Returns the authentication object for a given user ID
 * @param {string} userId - The ID of the user
 * @returns {Promise<object|null>} A promise that resolves to the user's auth object or null if not found
 */
const returnAuthObject = async (userId) => {
  try {
    return await getUserById(userId);
  } catch (error) {
    logger.error("API", `Error fetching user ${userId}: ${error.message}`);
    return null;
  }
};

/**
 * Ensures a nested parameter path exists in the user object
 * @param {string} userId - The user ID
 * @param {string} parameterPath - The dot-notation path to ensure exists
 * @returns {Promise<boolean>} - True if successful, false otherwise
 */
export async function ensureParameterPath(userId, parameterPath) {
  try {
    return await ensureUserPath(userId, parameterPath);
  } catch (error) {
    logger.error("API", `Error ensuring parameter path: ${error.message}`);
    return false;
  }
}

/**
 * Updates a specific parameter for a user
 * @param {string} userId - The ID of the user to update
 * @param {string} parameter - Path to the parameter to update
 * @param {any} newValue - The new value for the parameter
 * @returns {Promise<boolean>} - True if successful, false otherwise
 */
async function updateUserParameter(userId, parameter, newValue) {
  try {
    return await updateUserData(userId, parameter, newValue);
  } catch (error) {
    logger.error("API", `Error updating user parameter: ${error.message}`);
    return false;
  }
}

async function getAndStoreLatLong(ipAddr, userId) {
  try {
    const response = await axios.get(
      new URL(
        `http://ip-api.com/json/${ipAddr}?fields=status,message,country,regionName,lat,lon,timezone`,
      ),
    );
    if (response.data.status === "fail") {
      if (response.data.message === "private range") {
        logger.log("API", "Request from local network determined.");
        return false;
      } else if (response.data.message === "reserved range") {
        logger.log("API", "Request from the feds (???) determined.");
        return false;
      } else {
        logger.log("API", "Bad request for IP information.");
        return false;
      }
    } else {
      const { lat, lon, timezone } = response.data; // FIXED: Changed request.data to response.data
      await updateUserParameter(userId, "latitude", lat);
      await updateUserParameter(userId, "longitude", lon);
      await updateUserParameter(userId, "timeZone", timezone);
      return { latitude: lat, longitude: lon, timezone: timezone };
    }
  } catch (error) {
    logger.log("API", `Error in getAndStoreLatLong: ${error.message}`);
    return false;
  }
}

/**
 * Saves all pending changes to disk
 * @returns {Promise<void>}
 */
async function saveAuthToDisk() {
  try {
    await flushAllChanges();
    logger.log("API", "All pending changes saved to MongoDB");
  } catch (error) {
    logger.error("API", `Error saving changes to MongoDB: ${error.message}`);
  }
}

async function fetchWeather() {
  try {
    const users = await returnAPIKeys();

    for (const user of users) {
      if (!user.weather || !user.lastIp || user.lastIp === "") {
        continue; // Skip users without weather or IP
      }

      let locData = null;

      // Only call getAndStoreLatLong if latitude is not already set
      if (!user.latitude || user.latitude === "") {
        try {
          locData = await getAndStoreLatLong(user.lastIp, user.user_id);
        } catch (error) {
          logger.log(
            "API",
            `Error getting or storing lat/long for user ${user.user_id}: ${error}`,
          );
          continue; // Skip to the next user on error
        }
      } else {
        // Use existing latitude and longitude if available
        locData = {
          latitude: user.latitude,
          longitude: user.longitude,
          timezone: user.timeZone,
        };
      }

      // Ensure locData is valid before proceeding
      if (!locData || !locData.latitude || !locData.longitude) {
        logger.log(
          "API",
          `Missing or invalid location data for user ${user.user_id}.`,
        );
        continue; // Skip to the next user
      }

      try {
        const url = new URL(`https://api.open-meteo.com/v1/forecast`);
        url.searchParams.append("latitude", locData.latitude);
        url.searchParams.append("longitude", locData.longitude);
        url.searchParams.append(
          "current",
          "temperature_2m,is_day,precipitation,rain,showers,snowfall,cloud_cover,wind_speed_10m",
        );
        url.searchParams.append("precipitation_unit", "inch");
        url.searchParams.append("temperature_unit", "fahrenheit");
        url.searchParams.append("wind_speed_unit", "mph");
        url.searchParams.append("models", "gfs_seamless");
        url.searchParams.append("timezone", locData.timezone);

        const response = await axios.get(url.toString());

        if (response.status === 200) {
          const current = response.data.current;
          const tempF = parseInt(current["temperature_2m"]).toFixed(0);
          const cloudCover = parseInt(current["cloud_cover"]);
          const rainAmt = current["rain"].toFixed(1);
          const snowAmt = current["snowfall"].toFixed(1);
          const windSpeed = current["wind_speed_10m"].toFixed(0);

          let rainString = "";
          let cloudString = "";
          let tempString = "";
          let snowString = "";
          let windString = "";

          cloudString =
            cloudCover === 0
              ? " There are clear skies with no clouds in sight."
              : cloudCover <= 20
                ? " There are very few clouds in the sky."
                : cloudCover <= 50
                  ? " There are a few clouds in the sky."
                  : cloudCover <= 75
                    ? " There are a lot of clouds in the sky."
                    : " The sky is full of clouds.";

          tempString =
            tempF <= 0
              ? ` It's way below freezing at ${tempF} degrees.`
              : tempF <= 31.9
                ? ` It's below freezing at ${tempF} degrees.`
                : tempF <= 59.9
                  ? ` It's quite chilly at ${tempF} degrees.`
                  : tempF <= 78.9
                    ? ` It's quite cozy outside at ${tempF} degrees.`
                    : tempF <= 94.9
                      ? ` It's pretty warm outside at ${tempF} degrees.`
                      : ` It's quite hot outside at ${tempF} degrees.`;

          rainString =
            rainAmt == 0
              ? ""
              : rainAmt <= 0.9
                ? " It's lightly rainy outside."
                : rainAmt <= 1.9
                  ? " It's raining outside."
                  : rainAmt <= 5
                    ? " It's very rainy outside."
                    : " It's extremely rainy outside, almost like a huge storm.";

          snowString =
            snowAmt == 0
              ? ""
              : snowAmt <= 1
                ? " There is a light snowfall outside."
                : snowAmt <= 4
                  ? " There is a pleasant amount of snow outside."
                  : snowAmt <= 9.9
                    ? " There is quite a bit of snow outside."
                    : " There is a whole lot of snow outside.";

          windString =
            windSpeed == 0
              ? ""
              : windSpeed <= 9.9
                ? ` It is lightly windy outside at ${windSpeed} miles per hour.`
                : windSpeed <= 25.9
                  ? ` It's fairly windy outside at ${windSpeed} miles per hour.`
                  : windSpeed <= 49.9
                    ? ` It's moderately windy outside at ${windSpeed} miles per hour.`
                    : windSpeed <= 74.9
                      ? ` It's severely windy outside at ${windSpeed} miles per hour.`
                      : ` It is extremely windy outside, almost like a hurricane, at ${windSpeed} miles per hour.`;

          const timeOfDay = `It is currently ${current["is_day"] ? "day time." : "night time."
            }`;
          const currWeather = `${timeOfDay}${tempString}${cloudString}${rainString}${snowString}${windString}`;

          const userDir = path.join("./world_info", user.user_id);
          if (!fs.existsSync(userDir)) {
            await fs.promises.mkdir(userDir, { recursive: true });
          }
          await fs.promises.writeFile(
            path.join(userDir, "weather.txt"),
            currWeather,
          );
        } else {
          logger.log("API", `Failed to fetch weather for ${user.user_id}.`);
        }
      } catch (error) {
        logger.log(
          "API",
          `Error fetching weather for ${user.user_id}: ${error.message}`,
          "err"
        );
      }
    }
  } catch (error) {
    logger.log("API", `Error reading user data: ${error.message}`);
  }
}

/**
 * Checks for authentication using a provided token.
 * @param {string} token - The authentication token.
 * @returns {Promise<object>} A promise that resolves to an object indicating validity and user details.
 */
async function checkForAuth(token) {
  const allTokens = await returnAPIKeys();
  if (!allTokens || allTokens.length === 0) {
    return { valid: false };
  }

  const validObject = allTokens.find(
    (object) => token.trim() === object.api_token,
  );
  return validObject ? { valid: true, ...validObject } : { valid: false };
}

const funFact = async () => {
  const pickOne = Math.floor(Math.random() * 5) + 1
  switch (pickOne) {
    case 1:
      logger.log("API", "Pulled fact from Black History API.")
      return await blackRandomFact()
    case 2:
      logger.log("API", "Pulled fact from MeowFacts.")
      return await randomCatFact()
    case 3:
      logger.log("API", "Pulled fact from Numbers API.")
      return await randomNumbersFact()
    case 4:
      logger.log("API", "Pulled fact from Kinduff.")
      return await randomDogFact()
    case 5:
      logger.log("API", "Pulled fact from UselessFacts.")
      return await randomUselessFact()
    default:
      return "One of the websites decided to take a break. Instead of sharing a provided fun fact from one of these sites, talk about your favorite safe-for-work and stream-appropriate fact about your favorite person."
  }
};

const blackRandomFact = async () => {
  try {
    const response = await axios.get(
      "https://rest.blackhistoryapi.io/fact/random", { headers: { "x-api-key": await retrieveConfigValue("funFacts.key") } }
    );
    return response.data.Results[0].text;
  } catch (err) {
    logger.log("System", "Unable to get random fact from BlackHistoryAPI")
  }

};

const randomCatFact = async () => {
  try {
    const response = await axios.get(
      "https://meowfacts.herokuapp.com/"
    );
    return response.data.data[0];
  } catch (err) {
    logger.log("System", "Unable to get random fact from UselessFacts")
  }
};

const randomUselessFact = async () => {
  try {
    const response = await axios.get(
      "https://uselessfacts.jsph.pl/api/v2/facts/random?language=en"
    );
    return response.data.text;
  } catch (err) {
    logger.log("System", "Unable to get random fact from MeowFacts")
  }
}

const randomDogFact = async () => {
  try {
    const response = await axios.get(
      "http://dog-api.kinduff.com/api/facts?number=1"
    );
    return response.data.facts[0];
  } catch (err) {
    logger.log("System", "Unable to get random fact from DogApi")
  }
};

const randomNumbersFact = async () => {
  try {
    const response = await axios.get(
      "http://numbersapi.com/random?json",
    );
    return response.data.text
  } catch (err) {
    logger.log("System", "Unable to get random fact from NumbersApi")
  }

}

async function initAllAPIs() {
  await fetchWeather();
  cron.schedule("*/10 * * * *", async () => {
    await fetchWeather();
  });
}

process.on('SIGTERM', async () => {
  await flushAllChanges();
});

process.on('SIGINT', async () => {
  await flushAllChanges();
});

export {
  initAllAPIs,
  funFact,
  returnAuthObject,
  checkForAuth,
  loadAPIKeys,
  returnAPIKeys,
  saveAuthToDisk,
  updateUserParameter,
};
</file>

<file path="twitch-eventsub-manager.js">
import crypto from "crypto";
import axios from "axios";
import {
  returnAPIKeys,
  returnAuthObject,
  updateUserParameter,
  ensureParameterPath,
} from "./api-helper.js";
import { retrieveConfigValue } from "./config-helper.js";
import { logger } from "./create-global-logger.js";
import cron from "node-cron";

class TwitchAPIManager {
  constructor() {
    // Rate limit buckets - track API call counts
    this.buckets = {
      helix: {
        // Core API
        points: 800,
        remaining: 800,
        resetAt: Date.now() + 60000,
        perMinute: 800,
      },
      auth: {
        // Auth API
        points: 120,
        remaining: 120,
        resetAt: Date.now() + 60000,
        perMinute: 120,
      },
    };

    // Track per-endpoint usage
    this.endpointCounts = new Map();

    // Default retry settings
    this.defaultRetryConfig = {
      maxRetries: 3,
      initialDelay: 500,
      maxDelay: 10000,
      factor: 2,
      jitter: true,
    };
  }

  /**
   * Make a rate-limited API call with automatic retries
   * @param {Object} config - Axios config object
   * @param {String} bucketType - API type ('helix' or 'auth')
   * @param {Object} retryOptions - Custom retry options
   * @returns {Promise<Object>} - API response
   */
  async makeRequest(config, bucketType = "helix", retryOptions = {}) {
    // Track this endpoint
    const endpoint = this.getEndpointFromUrl(config.url);
    this.trackEndpointUsage(endpoint);

    // Merge retry options
    const retryConfig = { ...this.defaultRetryConfig, ...retryOptions };

    // Check rate limits before proceeding
    await this.checkRateLimits(bucketType);

    // Try the request with retries
    let lastError;
    let delay = retryConfig.initialDelay;

    for (let attempt = 0; attempt < retryConfig.maxRetries; attempt++) {
      try {
        const response = await axios(config);

        // Update rate limit info from headers
        this.updateRateLimits(bucketType, response.headers);

        return response;
      } catch (error) {
        lastError = error;

        // Check if error is due to rate limiting
        if (error.response?.status === 429) {
          // Get retry-after header or use exponential backoff
          const retryAfter =
            parseInt(error.response.headers["retry-after"] || "0") * 1000;
          delay = Math.max(
            retryAfter,
            this.calculateBackoff(attempt, retryConfig)
          );

          logger.warn(
            "Twitch",
            `Rate limited on ${endpoint}. Retrying in ${delay}ms`
          );

          // Update our rate limit tracking
          this.buckets[bucketType].remaining = 0;
          this.buckets[bucketType].resetAt = Date.now() + retryAfter || delay;
        } else if (this.isRetryableError(error)) {
          // For other retryable errors, use exponential backoff
          delay = this.calculateBackoff(attempt, retryConfig);
          logger.warn(
            "Twitch",
            `Retryable error on ${endpoint}: ${error.message}. Retry ${attempt + 1}/${retryConfig.maxRetries} in ${delay}ms`
          );
        } else {
          // Non-retryable error
          throw error;
        }

        // Wait before retry
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }

    // If we've exhausted retries, throw the last error
    throw lastError;
  }

  /**
   * Calculate backoff delay with jitter
   */
  calculateBackoff(attempt, config) {
    const baseDelay = config.initialDelay * Math.pow(config.factor, attempt);
    const maxDelay = config.maxDelay;

    // Apply jitter if enabled (helps distribute retries)
    if (config.jitter) {
      return Math.min(maxDelay, Math.random() * baseDelay);
    }

    return Math.min(maxDelay, baseDelay);
  }

  /**
   * Check if we should attempt to retry this error
   */
  isRetryableError(error) {
    // Network errors
    if (
      error.code === "ECONNRESET" ||
      error.code === "ETIMEDOUT" ||
      error.code === "ECONNABORTED"
    ) {
      return true;
    }

    // Server errors (5xx)
    if (error.response && error.response.status >= 500) {
      return true;
    }

    // Rate limiting (429)
    if (error.response && error.response.status === 429) {
      return true;
    }

    return false;
  }

  /**
   * Update rate limit info from response headers
   */
  updateRateLimits(bucketType, headers) {
    if (!headers) return;

    const remaining = headers["ratelimit-remaining"];
    const reset = headers["ratelimit-reset"];
    const limit = headers["ratelimit-limit"];

    if (remaining) this.buckets[bucketType].remaining = parseInt(remaining);
    if (limit) this.buckets[bucketType].points = parseInt(limit);
    if (reset) this.buckets[bucketType].resetAt = parseInt(reset) * 1000; // Convert to ms
  }

  /**
   * Wait if we're close to hitting rate limits
   */
  async checkRateLimits(bucketType) {
    const bucket = this.buckets[bucketType];
    const now = Date.now();

    // Reset bucket if time has passed
    if (now > bucket.resetAt) {
      bucket.remaining = bucket.points;
      bucket.resetAt = now + 60000; // Default 1 minute
      return;
    }

    // If close to limit (less than 10% remaining), delay the request
    if (bucket.remaining < bucket.points * 0.1) {
      const timeToReset = Math.max(0, bucket.resetAt - now);
      logger.warn(
        "Twitch",
        `Approaching rate limit for ${bucketType}, delaying request by ${timeToReset}ms`
      );

      // Sleep until rate limit resets
      await new Promise((resolve) => setTimeout(resolve, timeToReset));

      // Reset the bucket
      bucket.remaining = bucket.points;
      bucket.resetAt = now + 60000;
    }

    // Decrement remaining points
    bucket.remaining--;
  }

  /**
   * Extract endpoint from URL for tracking
   */
  getEndpointFromUrl(url) {
    try {
      const parsedUrl = new URL(url);
      const path = parsedUrl.pathname;
      // Get first two path segments
      const segments = path.split("/").filter((s) => s);
      return segments.slice(0, 2).join("/");
    } catch (e) {
      return url;
    }
  }

  /**
   * Track usage per endpoint for analytics
   */
  trackEndpointUsage(endpoint) {
    const count = this.endpointCounts.get(endpoint) || 0;
    this.endpointCounts.set(endpoint, count + 1);
  }

  /**
   * Get usage statistics
   */
  getUsageStats() {
    return {
      buckets: this.buckets,
      endpoints: Object.fromEntries(this.endpointCounts),
    };
  }
}

// EventSub subscription definitions with accurate condition requirements
const SUBSCRIPTION_TYPES = [
  // Version 1 endpoints - Standard events
  {
    type: "channel.update",
    version: "1",
    condition: (broadcasterId) => ({ broadcaster_user_id: broadcasterId }),
    requiredScopes: ["channel:read:stream_key"],
    tokenType: "app",
  },
  {
    type: "channel.chat.message",
    version: "1",
    condition: (broadcasterId) => ({
      broadcaster_user_id: broadcasterId,
      user_id: broadcasterId,
    }),
    requiredScopes: ["channel:moderate"],
    tokenType: "app",
  },
  {
    type: "channel.subscribe",
    version: "1",
    condition: (broadcasterId) => ({ broadcaster_user_id: broadcasterId }),
    requiredScopes: ["channel:read:subscriptions"],
    tokenType: "app",
  },
  {
    type: "channel.subscription.gift",
    version: "1",
    condition: (broadcasterId) => ({ broadcaster_user_id: broadcasterId }),
    requiredScopes: ["channel:read:subscriptions"],
    tokenType: "app",
  },
  {
    type: "channel.subscription.message",
    version: "1",
    condition: (broadcasterId) => ({ broadcaster_user_id: broadcasterId }),
    requiredScopes: ["channel:read:subscriptions"],
    tokenType: "app",
  },
  {
    type: "channel.cheer",
    version: "1",
    condition: (broadcasterId) => ({ broadcaster_user_id: broadcasterId }),
    requiredScopes: ["bits:read"],
    tokenType: "app",
  },
  {
    type: "channel.raid",
    version: "1",
    condition: (broadcasterId) => ({ to_broadcaster_user_id: broadcasterId }),
    requiredScopes: [],
    tokenType: "app",
  },
  {
    type: "channel.channel_points_custom_reward_redemption.add",
    version: "1",
    condition: (broadcasterId) => ({ broadcaster_user_id: broadcasterId }),
    requiredScopes: ["channel:read:redemptions"],
    tokenType: "app",
  },
  {
    type: "channel.charity_campaign.donate",
    version: "1",
    condition: (broadcasterId) => ({ broadcaster_user_id: broadcasterId }),
    requiredScopes: ["channel:read:charity"],
    tokenType: "app",
  },
  {
    type: "channel.charity_campaign.progress",
    version: "1",
    condition: (broadcasterId) => ({ broadcaster_user_id: broadcasterId }),
    requiredScopes: ["channel:read:charity"],
    tokenType: "app",
  },
  {
    type: "channel.hype_train.begin",
    version: "1",
    condition: (broadcasterId) => ({ broadcaster_user_id: broadcasterId }),
    requiredScopes: ["channel:read:hype_train"],
    tokenType: "app",
  },
  {
    type: "channel.hype_train.progress",
    version: "1",
    condition: (broadcasterId) => ({ broadcaster_user_id: broadcasterId }),
    requiredScopes: ["channel:read:hype_train"],
    tokenType: "app",
  },
  {
    type: "channel.hype_train.end",
    version: "1",
    condition: (broadcasterId) => ({ broadcaster_user_id: broadcasterId }),
    requiredScopes: ["channel:read:hype_train"],
    tokenType: "app",
  },
  {
    type: "stream.online",
    version: "1",
    condition: (broadcasterId) => ({ broadcaster_user_id: broadcasterId }),
    requiredScopes: [],
    tokenType: "app",
  },
  {
    type: "stream.offline",
    version: "1",
    condition: (broadcasterId) => ({ broadcaster_user_id: broadcasterId }),
    requiredScopes: [],
    tokenType: "app",
  },

  // Version 2 endpoints
  {
    type: "channel.follow",
    version: "2",
    condition: (broadcasterId) => ({
      broadcaster_user_id: broadcasterId,
      moderator_user_id: broadcasterId, // Using broadcaster as moderator for simplicity
    }),
    requiredScopes: ["moderator:read:followers"],
    tokenType: "app",
  },
  {
    type: "channel.update",
    version: "2",
    condition: (broadcasterId) => ({
      broadcaster_user_id: broadcasterId,
      moderator_user_id: broadcasterId,
    }),
    requiredScopes: ["channel:read:stream_key"],
    tokenType: "app",
  },

  // Beta endpoints - Only include if broadcaster has appropriate permissions
  {
    type: "channel.guest_star_session.begin",
    version: "beta",
    condition: (broadcasterId) => ({
      broadcaster_user_id: broadcasterId,
      moderator_user_id: broadcasterId,
    }),
    requiredScopes: [
      "moderator:read:guest_star",
      "moderator:manage:guest_star",
    ],
    tokenType: "app",
    optional: true,
  },
  {
    type: "channel.guest_star_guest.update",
    version: "beta",
    condition: (broadcasterId) => ({
      broadcaster_user_id: broadcasterId,
      moderator_user_id: broadcasterId,
    }),
    requiredScopes: ["moderator:read:guest_star"],
    tokenType: "app",
    optional: true,
  },
];

/**
 * Get an app access token for Twitch API calls that require it
 * @returns {Promise<string>} The app access token
 */
export async function getAppAccessToken() {
  try {
    // Check for cached token first
    if (
      global.twitchAppToken &&
      global.twitchAppTokenExpiry &&
      Date.now() < global.twitchAppTokenExpiry
    ) {
      return global.twitchAppToken;
    }

    logger.log("Twitch", "Getting new app access token");

    const clientId = await retrieveConfigValue("twitch.clientId");
    const clientSecret = await retrieveConfigValue("twitch.clientSecret");

    if (!clientId || !clientSecret) {
      throw new Error("Missing Twitch client ID or secret in configuration");
    }

    const axios = (await import("axios")).default;
    const response = await axios.post(
      "https://id.twitch.tv/oauth2/token",
      new URLSearchParams({
        client_id: clientId,
        client_secret: clientSecret,
        grant_type: "client_credentials",
      }),
      {
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
        },
      }
    );

    const { access_token, expires_in } = response.data;

    // Cache the token with a safety margin
    global.twitchAppToken = access_token;
    global.twitchAppTokenExpiry = Date.now() + expires_in * 900; // 90% of expiry time

    logger.log("Twitch", "Successfully obtained app access token");
    return access_token;
  } catch (error) {
    logger.error("Twitch", `Failed to get app access token: ${error.message}`);
    throw error;
  }
}

async function fetchCurrentTwitchSubscriptions(userId) {
  try {
    const user = await returnAuthObject(userId);
    
    // We need an app access token for this request
    const appToken = await getAppAccessToken();
    
    if (!appToken) {
      logger.error("Twitch", "Failed to get app access token for subscription check");
      return [];
    }
    
    const response = await axios.get("https://api.twitch.tv/helix/eventsub/subscriptions", {
      headers: {
        "Client-ID": await retrieveConfigValue("twitch.clientId"),
        "Authorization": `Bearer ${appToken}`
      }
    });
    
    if (response.data && response.data.data) {
      // Filter to subscriptions for this user's callback URL
      const callbackUrl = `${await retrieveConfigValue("server.endpoints.external")}/api/v1/twitch/eventsub/${userId}`;
      
      return response.data.data.filter(sub => 
        sub.transport && 
        sub.transport.callback === callbackUrl
      );
    }
    
    return [];
  } catch (error) {
    logger.error("Twitch", `Error fetching current subscriptions: ${error.message}`);
    return [];
  }
}

/**
 * Enhanced function to register chat message subscription with better error handling
 * @param {string} userId - The user ID
 * @returns {Promise<{success: boolean, created?: boolean, error?: string}>}
 */
async function registerChatMessageSubscription(userId) {
  try {
    const user = await returnAuthObject(userId);
    
    // Ensure we have the required data
    if (!user.twitch_tokens?.streamer?.twitch_user_id) {
      logger.error("Twitch", `Missing streamer ID for user ${userId}, can't register chat events`);
      return { success: false, error: "Missing streamer data" };
    }

    // Check if token is valid and has the right scope
    const streamerScopes = await getUserScopes(userId, "streamer");
    if (!streamerScopes.includes("channel:moderate")) {
      logger.error("Twitch", `User ${userId} is missing channel:moderate scope required for chat events`);
      return { 
        success: false, 
        error: "Missing required scopes. Please reconnect your Twitch account with chat reading permissions." 
      };
    }

    // Find chat subscription config
    const chatSubConfig = SUBSCRIPTION_TYPES.find(
      sub => sub.type === "channel.chat.message" && sub.version === "1"
    );
    
    if (!chatSubConfig) {
      return { success: false, error: "Chat subscription config not found" };
    }

    // Get broadcaster ID
    const broadcasterId = user.twitch_tokens.streamer.twitch_user_id;
    
    // Do we already have this subscription?
    if (user.twitch_tokens.streamer.subscriptions) {
      const existingSub = user.twitch_tokens.streamer.subscriptions.find(
        sub => sub.type === "channel.chat.message" && sub.version === "1"
      );
      
      if (existingSub) {
        logger.log("Twitch", `Chat subscription already exists for ${userId}`);
        return { success: true, created: false };
      }
    }
    
    // Create the subscription
    const result = await createSubscription(
      userId, 
      chatSubConfig, 
      broadcasterId
    );
    
    if (result.success) {
      logger.log("Twitch", `Successfully registered chat subscription for ${userId}`);
      return { success: true, created: true };
    } else {
      logger.error("Twitch", `Failed to create chat subscription: ${result.error}`);
      return { success: false, error: result.error };
    }
  } catch (error) {
    logger.error("Twitch", `Error in registerChatMessageSubscription: ${error.message}`);
    return { success: false, error: error.message };
  }
}

/**
 * Main function to register EventSub for all users
 * @returns {Promise<{success: number, failures: number}>}
 */
export async function registerAllUsersEventSub() {
  try {
    logger.log(
      "Twitch",
      "Starting automatic EventSub registration for all users"
    );

    // Get all users from auth system
    const users = await returnAPIKeys();
    let successCount = 0;
    let failureCount = 0;
    const chatResult = await registerChatMessageSubscription(user.user_id);
    if (!chatResult.success) {
      logger.error("Twitch", `Failed to register chat subscription for ${user.user_id}: ${chatResult.error}`);
    }
    // Process each user sequentially to avoid rate limits
    
    for (const user of users) {
      try {
        // Skip users without any Twitch tokens
        if (!user.twitch_tokens) {
          logger.log(
            "Twitch",
            `Skipping EventSub for ${user.user_id}: No Twitch integration`
          );
          continue;
        }

        // We need the streamer account for EventSub
        if (
          !user.twitch_tokens.streamer ||
          !user.twitch_tokens.streamer.access_token
        ) {
          logger.log(
            "Twitch",
            `Skipping EventSub for ${user.user_id}: No streamer account connected`
          );
          continue;
        }

        // Check if we need to refresh the token
        const validToken = await ensureValidToken(user.user_id, "streamer");
        if (!validToken) {
          logger.log(
            "Twitch",
            `Skipping EventSub for ${user.user_id}: Token refresh failed`
          );
          failureCount++;
          continue;
        }

        // Get Twitch user ID if we don't have it yet
        if (!user.twitch_tokens.streamer.twitch_user_id) {
          const twitchUserId = await fetchTwitchUserId(
            user.user_id,
            "streamer"
          );
          if (!twitchUserId) {
            logger.log(
              "Twitch",
              `Skipping EventSub for ${user.user_id}: Couldn't get Twitch user ID`
            );
            failureCount++;
            continue;
          }
        }

        // Register all subscription types
        const results = await registerUserSubscriptions(user.user_id);

        if (results.success) {
          successCount++;
          logger.log(
            "Twitch",
            `Successfully registered EventSub for ${user.user_id}`
          );
        } else {
          failureCount++;
          logger.log(
            "Twitch",
            `Failed to register EventSub for ${user.user_id}: ${results.error}`
          );
        }
      } catch (userError) {
        failureCount++;
        logger.error(
          "Twitch",
          `Error processing user ${user.user_id}: ${userError.message}`
        );
      }

      // Add a small delay between users to avoid rate limits
      await new Promise((resolve) => setTimeout(resolve, 1000));
    }

    logger.log(
      "Twitch",
      `EventSub registration complete. Success: ${successCount}, Failures: ${failureCount}`
    );
    return { success: successCount, failures: failureCount };
  } catch (error) {
    logger.error(
      "Twitch",
      `Error in registerAllUsersEventSub: ${error.message}`
    );
    throw error;
  }
}

// Create singleton instance
const twitchAPI = new TwitchAPIManager();

// Export a wrapper function for all Twitch API calls
export async function callTwitchAPI(
  config,
  bucketType = "helix",
  retryOptions = {}
) {
  return twitchAPI.makeRequest(config, bucketType, retryOptions);
}

/**
 * Register all subscription types for a single user
 * @param {string} userId - The user ID
 * @returns {Promise<{success: boolean, created: string[], skipped: string[], error: string|null}>}
 */
export async function registerUserSubscriptions(userId) {
  try {
    const user = await returnAuthObject(userId);

    // Check if streamer account is connected
    if (
      !user.twitch_tokens ||
      !user.twitch_tokens.streamer ||
      !user.twitch_tokens.streamer.access_token
    ) {
      return {
        success: false,
        created: [],
        skipped: [],
        error: "No streamer account connected",
      };
    }

    // Check if we have the Twitch user ID
    if (!user.twitch_tokens.streamer.twitch_user_id) {
      logger.log(
        "Twitch",
        `No Twitch user ID found for user ${userId}, fetching it now`
      );

      try {
        const twitchUserId = await fetchTwitchUserId(userId, "streamer");
        if (!twitchUserId) {
          logger.error(
            "Twitch",
            `Failed to fetch Twitch user ID for ${userId}`
          );
          return {
            success: false,
            created: [],
            skipped: [],
            error: "Failed to fetch Twitch user ID",
          };
        }

        // Should be saved by fetchTwitchUserId, but double-check
        if (!user.twitch_tokens.streamer.twitch_user_id) {
          await updateUserParameter(
            userId,
            "twitch_tokens.streamer.twitch_user_id",
            twitchUserId
          );
        }
      } catch (err) {
        logger.error("Twitch", `Error fetching Twitch user ID: ${err.message}`);
        return {
          success: false,
          created: [],
          skipped: [],
          error: `Error fetching Twitch user ID: ${err.message}`,
        };
      }
    }

    // Make sure the webhook_secret path exists
    await ensureParameterPath(userId, "twitch_tokens.streamer.subscriptions");

    // Generate webhook secret if it doesn't exist
    if (!user.twitch_tokens.streamer.webhook_secret) {
      const newSecret = crypto.randomBytes(32).toString("hex");
      await updateUserParameter(
        userId,
        "twitch_tokens.streamer.webhook_secret",
        newSecret
      );
      logger.log("Twitch", `Generated new webhook secret for user ${userId}`);
    }

    // Refresh the user object to make sure we have the latest data
    const updatedUser = await returnAuthObject(userId);

    // Verify we have the broadcaster_user_id
    if (!updatedUser.twitch_tokens.streamer.twitch_user_id) {
      logger.error(
        "Twitch",
        `No Twitch user ID found for user ${userId} after refresh`
      );
      return {
        success: false,
        created: [],
        skipped: [],
        error: "Missing Twitch user ID",
      };
    }

    // Check if the bot account is connected for subscriptions that need it
    const hasBotAccount = updatedUser.twitch_tokens?.bot?.access_token
      ? true
      : false;

    // Track existing subscriptions to avoid duplicates
    const existingSubscriptions = new Map();
    if (updatedUser.twitch_tokens.streamer.subscriptions) {
      updatedUser.twitch_tokens.streamer.subscriptions.forEach((sub) => {
        // Create key from type and version
        const key = `${sub.type}:${sub.version || "1"}`;
        existingSubscriptions.set(key, sub);
      });
    }

    const results = {
      success: true,
      created: [],
      skipped: [],
      errors: [],
      error: null,
    };

    const broadcasterId = updatedUser.twitch_tokens.streamer.twitch_user_id;

    // Check which scopes the user has
    const streamerScopes = await getUserScopes(userId, "streamer");
    const botScopes = hasBotAccount ? await getUserScopes(userId, "bot") : [];

    // Process each subscription type
    for (const subscriptionConfig of SUBSCRIPTION_TYPES) {
      try {
        // Create key for checking existing subscriptions
        const subKey = `${subscriptionConfig.type}:${subscriptionConfig.version}`;

        // Skip if we already have this subscription
        if (existingSubscriptions.has(subKey)) {
          results.skipped.push(
            `${subscriptionConfig.type} (v${subscriptionConfig.version})`
          );
          continue;
        }

        // Skip optional subscriptions if conditions aren't met (like beta features)
        if (subscriptionConfig.optional) {
          // Skip beta features if not explicitly allowed
          if (
            subscriptionConfig.version === "beta" &&
            !user.allow_beta_features
          ) {
            results.skipped.push(
              `${subscriptionConfig.type} (v${subscriptionConfig.version}) - beta feature not enabled`
            );
            continue;
          }
        }

        // Verify the user has the required scopes
        if (subscriptionConfig.requiredScopes.length > 0) {
          const accountType = subscriptionConfig.tokenType;
          const userScopes = accountType === "bot" ? botScopes : streamerScopes;

          // Skip if using bot token but no bot account is connected
          if (accountType === "bot" && !hasBotAccount) {
            results.skipped.push(
              `${subscriptionConfig.type} (v${subscriptionConfig.version}) - requires bot account`
            );
            continue;
          }

          // Check if user has all required scopes
          const missingScopes = subscriptionConfig.requiredScopes.filter(
            (scope) => !userScopes.includes(scope)
          );

          if (missingScopes.length > 0) {
            logger.log(
              "Twitch",
              `Skipping ${subscriptionConfig.type} - missing scopes: ${missingScopes.join(", ")}`
            );
            results.skipped.push(
              `${subscriptionConfig.type} (v${subscriptionConfig.version}) - missing scopes`
            );
            continue;
          }
        }

        // Create the subscription
        const subResult = await createSubscription(
          userId,
          subscriptionConfig,
          broadcasterId
        );

        if (subResult.success) {
          results.created.push(
            `${subscriptionConfig.type} (v${subscriptionConfig.version})`
          );
        } else {
          // Track errors but continue with other subscriptions
          results.errors.push(
            `${subscriptionConfig.type} (v${subscriptionConfig.version}): ${subResult.error}`
          );
          logger.error(
            "Twitch",
            `Failed to create subscription for ${subscriptionConfig.type} (v${subscriptionConfig.version}): ${subResult.error}`
          );
        }

        // Add a small delay between requests to avoid rate limits
        await new Promise((resolve) => setTimeout(resolve, 500));
      } catch (error) {
        // Handle individual subscription errors
        results.errors.push(
          `${subscriptionConfig.type} (v${subscriptionConfig.version}): ${error.message}`
        );
        logger.error(
          "Twitch",
          `Error creating subscription for ${subscriptionConfig.type} (v${subscriptionConfig.version}): ${error.message}`
        );
      }
    }

    // Overall success is true if we created at least one subscription without errors
    // or if we skipped all because they already exist
    results.success =
      results.created.length > 0 ||
      results.skipped.length === SUBSCRIPTION_TYPES.length;

    // Add summary of errors if any occurred
    if (results.errors.length > 0) {
      results.error = `Some subscriptions failed: ${results.errors.length} errors`;
      logger.warn(
        "Twitch",
        `Completed EventSub registration for ${userId} with ${results.errors.length} errors`
      );
    } else {
      logger.log(
        "Twitch",
        `Successfully registered all EventSub subscriptions for ${userId}`
      );
    }

    return results;
  } catch (error) {
    logger.error(
      "Twitch",
      `Error in registerUserSubscriptions: ${error.message}`
    );
    return {
      success: false,
      created: [],
      skipped: [],
      error: error.message,
    };
  }
}

/**
 * Process channel update events to extract game information
 * @param {object} event - The event data
 * @param {string} userId - The user ID
 * @returns {Promise<void>}
 */
async function handleChannelUpdate(event, userId) {
  try {
    // Extract game name, title, and category_id
    const { title, category_name, category_id } = event;

    // Update user's current game info with improved structure
    await updateUserParameter(userId, "current_game", {
      title: title || "No Title",
      game: category_name || "none", // Use "none" as fallback
      game_id: category_id || "0",
      updated_at: new Date().toISOString(),
    });

    logger.log(
      "Twitch",
      `Updated game info for ${userId}: ${category_name || "none"}`
    );

    // After updating game info, fetch current viewer count
    await fetchViewerCount(userId);
  } catch (error) {
    logger.error("Twitch", `Error handling channel update: ${error.message}`);
  }
}

/**
 * Process stream state change events (online/offline)
 * @param {string} eventType - The event type (stream.online or stream.offline)
 * @param {object} event - The event data
 * @param {string} userId - The user ID
 * @returns {Promise<void>}
 */
async function handleStreamStateChange(eventType, event, userId) {
  try {
    const isOnline = eventType === "stream.online";

    // Update user's stream status
    await updateUserParameter(userId, "stream_status", {
      online: isOnline,
      started_at: isOnline ? event.started_at : null,
      type: isOnline ? event.type : null,
      updated_at: new Date().toISOString(),
    });

    logger.log(
      "Twitch",
      `Stream ${isOnline ? "started" : "ended"} for ${userId}`
    );

    // Reset viewer count to 0 when stream goes offline
    if (!isOnline) {
      await updateUserParameter(userId, "current_viewers", 0);
    } else {
      // If stream just went online, fetch current viewer count after a short delay
      // This gives Twitch API time to update with the new stream data
      setTimeout(() => fetchViewerCount(userId), 30000); // 30 seconds delay
    }
  } catch (error) {
    logger.error(
      "Twitch",
      `Error handling stream state change: ${error.message}`
    );
  }
}

/**
 * Fetches current stream information and updates user parameters
 * @param {string} userId - The user ID
 * @returns {Promise<object>} - Stream info object with status and data
 */
export async function fetchStreamInfo(userId) {
  try {
    const user = await returnAuthObject(userId);

    // Check if streamer token exists and channel ID is available
    if (!user?.twitch_tokens?.streamer?.twitch_user_id) {
      logger.log(
        "Twitch",
        `No Twitch user ID for ${userId}, can't fetch stream info`
      );
      return { success: false, isLive: false, error: "Missing Twitch user ID" };
    }

    // Get app access token for API call
    const appToken = await getAppAccessToken();
    const channelId = user.twitch_tokens.streamer.twitch_user_id;

    // Import axios
    const axios = (await import("axios")).default;

    // Get stream information
    const streamResponse = await axios.get(
      `https://api.twitch.tv/helix/streams?user_id=${channelId}`,
      {
        headers: {
          "Client-ID": await retrieveConfigValue("twitch.clientId"),
          Authorization: `Bearer ${appToken}`,
        },
      }
    );

    // Prepare result object
    const result = {
      success: true,
      isLive: false,
      data: {},
    };

    // Check if stream is live
    if (streamResponse.data.data && streamResponse.data.data.length > 0) {
      const streamData = streamResponse.data.data[0];
      result.isLive = true;

      // Extract stream details
      result.data = {
        viewerCount: streamData.viewer_count || 0,
        startedAt: streamData.started_at || null,
        title: streamData.title || "",
        gameId: streamData.game_id || "",
        gameName: streamData.game_name || "Unknown Game",
        thumbnailUrl:
          streamData.thumbnail_url
            ?.replace("{width}", "320")
            .replace("{height}", "180") || null,
      };

      // Calculate stream duration
      if (streamData.started_at) {
        const startTime = new Date(streamData.started_at);
        const currentTime = new Date();
        const durationMs = currentTime - startTime;

        // Format duration
        const hours = Math.floor(durationMs / (1000 * 60 * 60));
        const minutes = Math.floor(
          (durationMs % (1000 * 60 * 60)) / (1000 * 60)
        );
        result.data.duration = `${hours}h ${minutes}m`;
        result.data.durationMs = durationMs;
      }

      // Update user parameters with stream data
      await updateUserParameter(userId, "current_game", {
        title: streamData.title || "No Title",
        game: streamData.game_name || "none",
        game_id: streamData.game_id || "0",
        thumbnail_url: streamData.thumbnail_url || null,
        updated_at: new Date().toISOString(),
      });

      await updateUserParameter(
        userId,
        "current_viewers",
        streamData.viewer_count || 0
      );

      // Update stream status
      await updateUserParameter(userId, "stream_status", {
        online: true,
        started_at: streamData.started_at || null,
        type: streamData.type || "live",
        title: streamData.title || "",
        viewer_count: streamData.viewer_count || 0,
        updated_at: new Date().toISOString(),
      });

      logger.log(
        "Twitch",
        `Updated stream info for ${userId}: ${streamData.viewer_count} viewers, playing ${streamData.game_name}`
      );
    } else {
      // Stream is offline
      await updateUserParameter(userId, "stream_status", {
        online: false,
        updated_at: new Date().toISOString(),
      });

      // Keep the current game info but mark as offline
      const currentGameInfo = user.current_game || {};
      await updateUserParameter(userId, "current_game", {
        ...currentGameInfo,
        online: false,
        updated_at: new Date().toISOString(),
      });

      await updateUserParameter(userId, "current_viewers", 0);
    }

    // Always fetch follower count regardless of stream status
    await fetchFollowerCount(userId, channelId, appToken);

    return result;
  } catch (error) {
    logger.error("Twitch", `Error fetching stream info: ${error.message}`);
    return { success: false, isLive: false, error: error.message };
  }
}

/**
 * Fetches follower count for a channel
 * @param {string} userId - The user ID
 * @param {string} channelId - The Twitch channel ID
 * @param {string} appToken - The app access token
 * @returns {Promise<number>} - The follower count
 */
async function fetchFollowerCount(userId, channelId, appToken) {
  try {
    // Import axios
    const axios = (await import("axios")).default;

    // Get follower information
    const followerResponse = await axios.get(
      `https://api.twitch.tv/helix/channels/followers?broadcaster_id=${channelId}`,
      {
        headers: {
          "Client-ID": await retrieveConfigValue("twitch.clientId"),
          Authorization: `Bearer ${appToken}`,
        },
      }
    );

    const followerCount = followerResponse.data.total || 0;

    // Update user parameter with follower count
    await updateUserParameter(userId, "current_followers", followerCount);
    logger.log(
      "Twitch",
      `Updated follower count for ${userId}: ${followerCount}`
    );

    return followerCount;
  } catch (error) {
    logger.error("Twitch", `Error fetching follower count: ${error.message}`);
    return 0;
  }
}

/**
 * Fetch current viewer count for a user's channel
 * @param {string} userId - The user ID
 * @returns {Promise<number>} - The viewer count, or 0 if unavailable
 */
async function fetchViewerCount(userId) {
  try {
    const user = await returnAuthObject(userId);

    // Check if streamer token exists and channel ID is available
    if (!user.twitch_tokens?.streamer?.twitch_user_id) {
      logger.log(
        "Twitch",
        `No Twitch user ID for ${userId}, can't fetch viewer count`
      );
      await updateUserParameter(userId, "current_viewers", 0);
      return 0;
    }

    // Get app access token for API call
    const appToken = await getAppAccessToken();
    const channelId = user.twitch_tokens.streamer.twitch_user_id;

    // Import axios
    const axios = (await import("axios")).default;

    // Get stream information
    const response = await axios.get(
      `https://api.twitch.tv/helix/streams?user_id=${channelId}`,
      {
        headers: {
          "Client-ID": await retrieveConfigValue("twitch.clientId"),
          Authorization: `Bearer ${appToken}`,
        },
      }
    );

    // Check if stream is live
    if (response.data.data && response.data.data.length > 0) {
      const viewerCount = response.data.data[0].viewer_count || 0;

      // Update user parameter with viewer count
      await updateUserParameter(userId, "current_viewers", viewerCount);
      logger.log(
        "Twitch",
        `Updated viewer count for ${userId}: ${viewerCount}`
      );

      return viewerCount;
    } else {
      // Stream is not live, set viewer count to 0
      await updateUserParameter(userId, "current_viewers", 0);
      return 0;
    }
  } catch (error) {
    logger.error("Twitch", `Error fetching viewer count: ${error.message}`);
    await updateUserParameter(userId, "current_viewers", 0);
    return 0;
  }
}

/**
 * Processes real-time chat messages from Twitch EventSub
 * @param {object} chatEvent - The chat event data from EventSub
 * @param {string} userId - The user ID
 * @returns {Promise<object>} - The processing result
 */
export async function processChatMessage(chatEvent, userId) {
  try {
    // Import the new chat handler
    const { handleChatMessage, normalizeMessageFormat } = await import(
      "./chat-handler.js"
    );

    // Normalize the EventSub message format
    const normalizedChat = normalizeMessageFormat(chatEvent);

    // Process through the central handler with autoRespond=true to enable Twitch chat responses
    return await handleChatMessage(normalizedChat, userId, true);
  } catch (error) {
    logger.error("Twitch", `Error processing chat message: ${error.message}`);
    return { success: false, error: error.message };
  }
}

/**
 * Sends a chat message to a Twitch channel using the bot account
 * @param {string} message - The message to send
 * @param {string} userId - The user ID
 * @returns {Promise<object>} - Result of the operation
 */
export async function sendChatMessage(message, userId) {
  try {
    const user = await returnAuthObject(userId);

    // Check if bot account is connected
    if (!user.twitch_tokens?.bot?.access_token) {
      logger.error(
        "Twitch",
        `No bot token for user ${userId}, can't send chat message`
      );
      return { success: false, error: "No bot token available" };
    }

    // Make sure we have a valid token
    const botToken = await refreshTwitchToken(userId, "bot");
    if (!botToken) {
      logger.error("Twitch", `Failed to refresh bot token for ${userId}`);
      return { success: false, error: "Failed to refresh bot token" };
    }

    // Check if we have the channel ID
    if (!user.twitch_tokens?.streamer?.twitch_user_id) {
      logger.error(
        "Twitch",
        `No streamer ID for ${userId}, can't determine chat channel`
      );
      return { success: false, error: "No streamer ID available" };
    }

    const channelId = user.twitch_tokens.streamer.twitch_user_id;

    // Import axios
    const axios = (await import("axios")).default;

    // Send chat message via Twitch API
    const response = await axios.post(
      `https://api.twitch.tv/helix/chat/messages`,
      {
        broadcaster_id: channelId,
        sender_id: user.twitch_tokens.bot.twitch_user_id,
        message: message,
      },
      {
        headers: {
          "Client-ID": await retrieveConfigValue("twitch.clientId"),
          Authorization: `Bearer ${botToken}`,
        },
      }
    );

    if (response.status === 200) {
      logger.log(
        "Twitch",
        `Sent chat message to ${user.twitch_name || user.user_name}'s channel`
      );
      return { success: true, message_id: response.data.message_id };
    } else {
      logger.error(
        "Twitch",
        `Failed to send chat message: ${response.status} ${response.statusText}`
      );
      return { success: false, error: `API returned ${response.status}` };
    }
  } catch (error) {
    logger.error("Twitch", `Error sending chat message: ${error.message}`);
    return { success: false, error: error.message };
  }
}

/**
 * Get the scopes associated with a user's token
 * @param {string} userId - The user ID
 * @param {string} tokenType - The token type (bot or streamer)
 * @returns {Promise<string[]>} - Array of scopes
 */
async function getUserScopes(userId, tokenType) {
  try {
    const user = await returnAuthObject(userId);

    // Check if token exists
    if (!user.twitch_tokens?.[tokenType]?.access_token) {
      logger.log(
        "Twitch",
        `No ${tokenType} access token found for user ${userId}`
      );
      return [];
    }

    // If we already have cached scopes, return them
    if (
      user.twitch_tokens[tokenType].scopes &&
      Array.isArray(user.twitch_tokens[tokenType].scopes)
    ) {
      return user.twitch_tokens[tokenType].scopes;
    }

    // Otherwise validate the token to get scopes
    const axios = (await import("axios")).default;

    try {
      const response = await axios.get("https://id.twitch.tv/oauth2/validate", {
        headers: {
          Authorization: `OAuth ${user.twitch_tokens[tokenType].access_token}`,
        },
      });

      if (response.data && response.data.scopes) {
        // Cache the scopes
        await updateUserParameter(
          userId,
          `twitch_tokens.${tokenType}.scopes`,
          response.data.scopes
        );
        return response.data.scopes;
      }

      return [];
    } catch (validationError) {
      // If we get a 401 error, the token is likely expired
      if (validationError.response && validationError.response.status === 401) {
        logger.log(
          "Twitch",
          `Token for ${userId} (${tokenType}) is invalid or expired. Attempting refresh...`
        );

        // Try to refresh the token
        if (user.twitch_tokens[tokenType].refresh_token) {
          try {
            const newToken = await refreshTwitchToken(userId, tokenType);

            if (newToken) {
              // Try validation again with the new token
              const freshUser = await returnAuthObject(userId);

              const retryResponse = await axios.get(
                "https://id.twitch.tv/oauth2/validate",
                {
                  headers: {
                    Authorization: `OAuth ${freshUser.twitch_tokens[tokenType].access_token}`,
                  },
                }
              );

              if (retryResponse.data && retryResponse.data.scopes) {
                // Cache the scopes
                await updateUserParameter(
                  userId,
                  `twitch_tokens.${tokenType}.scopes`,
                  retryResponse.data.scopes
                );
                return retryResponse.data.scopes;
              }
            }
          } catch (refreshError) {
            logger.error(
              "Twitch",
              `Failed to refresh token: ${refreshError.message}`
            );
          }
        }
      }

      // Log detailed error information
      if (validationError.response) {
        logger.error(
          "Twitch",
          `Token validation error: Status ${validationError.response.status}, Data: ${JSON.stringify(validationError.response.data)}`
        );
      } else {
        logger.error(
          "Twitch",
          `Token validation error: ${validationError.message}`
        );
      }

      return [];
    }
  } catch (error) {
    logger.error("Twitch", `Error getting user scopes: ${error.message}`);
    return [];
  }
}

/**
 * Create a single EventSub subscription
 * @param {string} userId - The user ID
 * @param {object} subscriptionConfig - The subscription configuration
 * @param {string} broadcasterId - The Twitch broadcaster ID
 * @returns {Promise<{success: boolean, id?: string, error?: string}>}
 */
async function createSubscription(userId, subscriptionConfig, broadcasterId) {
  try {
    const user = await returnAuthObject(userId);

    // All the existing validation...
    
    // Let's add better subscription checking using Twitch API
    const currentTwitchSubscriptions = await fetchCurrentTwitchSubscriptions(userId);
    
    // Check if we already have this subscription on Twitch's side
    const existingSubscription = currentTwitchSubscriptions.find(sub => 
      sub.type === subscriptionConfig.type && 
      sub.version === subscriptionConfig.version &&
      JSON.stringify(sub.condition) === JSON.stringify(subscriptionConfig.condition(broadcasterId))
    );
    
    if (existingSubscription) {
      logger.log("Twitch", `Subscription for ${subscriptionConfig.type} already exists on Twitch side, skipping creation`);
      
      // Make sure it's in our database as well
      const subscriptions = user.twitch_tokens?.streamer?.subscriptions || [];
      const exists = subscriptions.some(sub => 
        sub.id === existingSubscription.id && 
        sub.type === existingSubscription.type &&
        sub.version === existingSubscription.version
      );
      
      if (!exists) {
        // Update our local subscriptions list with the Twitch-side data
        subscriptions.push({
          id: existingSubscription.id,
          type: existingSubscription.type,
          version: existingSubscription.version,
          created_at: existingSubscription.created_at
        });
        
        await updateUserParameter(
          userId,
          "twitch_tokens.streamer.subscriptions",
          subscriptions
        );
        
        logger.log("Twitch", `Updated local subscription records for ${subscriptionConfig.type}`);
      }
      
      return {
        success: true,
        id: existingSubscription.id,
        version: existingSubscription.version,
        alreadyExists: true
      };
    }

    // If we're here, we need to create the subscription
    try {
      // Use app access token
      const accessToken = await getAppAccessToken();
      
      // Generate the condition
      const condition = subscriptionConfig.condition(broadcasterId);
      
      const callbackUrl = `${await retrieveConfigValue("server.endpoints.external")}/api/v1/twitch/eventsub/${userId}`;
      
      const subscriptionBody = {
        type: subscriptionConfig.type,
        version: subscriptionConfig.version,
        condition: condition,
        transport: {
          method: "webhook",
          callback: callbackUrl,
          secret: user.twitch_tokens.streamer.webhook_secret,
        },
      };
      
      const response = await axios.post(
        "https://api.twitch.tv/helix/eventsub/subscriptions",
        subscriptionBody,
        {
          headers: {
            "Client-ID": await retrieveConfigValue("twitch.clientId"),
            Authorization: `Bearer ${accessToken}`,
            "Content-Type": "application/json",
          },
        }
      );
      
      // Make sure subscriptions array exists
      if (!user.twitch_tokens.streamer.subscriptions) {
        await updateUserParameter(
          userId,
          "twitch_tokens.streamer.subscriptions",
          []
        );
      }
      
      // Save subscription ID
      const subscriptionId = response.data.data[0].id;
      
      // Get the current subscriptions array
      const currentUser = await returnAuthObject(userId);
      const subscriptions = currentUser.twitch_tokens.streamer.subscriptions || [];
      
      // Add new subscription and update
      subscriptions.push({
        id: subscriptionId,
        type: subscriptionConfig.type,
        version: subscriptionConfig.version,
        created_at: new Date().toISOString(),
      });
      
      await updateUserParameter(
        userId,
        "twitch_tokens.streamer.subscriptions",
        subscriptions
      );
      
      return {
        success: true,
        id: subscriptionId,
        version: subscriptionConfig.version,
      };
    } catch (error) {
      // Special handling for 409 conflict errors
      if (error.response && error.response.status === 409) {
        logger.log("Twitch", `409 Conflict creating subscription for ${subscriptionConfig.type}. Subscription likely exists.`);
        
        // Try to fetch again to get the current status
        const refreshedSubs = await fetchCurrentTwitchSubscriptions(userId);
        const matchingSub = refreshedSubs.find(sub => 
          sub.type === subscriptionConfig.type && 
          sub.version === subscriptionConfig.version
        );
        
        if (matchingSub) {
          // Update our local record to match Twitch's record
          const subscriptions = user.twitch_tokens?.streamer?.subscriptions || [];
          
          // Check if we already have this subscription
          const existingIndex = subscriptions.findIndex(sub => 
            sub.id === matchingSub.id
          );
          
          if (existingIndex >= 0) {
            // Update existing record
            subscriptions[existingIndex] = {
              id: matchingSub.id,
              type: matchingSub.type,
              version: matchingSub.version,
              created_at: matchingSub.created_at
            };
          } else {
            // Add new record
            subscriptions.push({
              id: matchingSub.id,
              type: matchingSub.type,
              version: matchingSub.version,
              created_at: matchingSub.created_at
            });
          }
          
          await updateUserParameter(
            userId,
            "twitch_tokens.streamer.subscriptions",
            subscriptions
          );
          
          return {
            success: true,
            id: matchingSub.id,
            version: matchingSub.version,
            alreadyExists: true
          };
        }
      }
      
      // Handle other errors
      logger.error(
        "Twitch",
        `Error creating subscription ${subscriptionConfig.type}: ${error.message}`
      );
      
      return { success: false, error: error.message };
    }
  } catch (error) {
    logger.error(
      "Twitch",
      `Error in createSubscription for ${subscriptionConfig.type}: ${error.message}`
    );
    return { success: false, error: error.message };
  }
}

/**
 * Ensure token is valid and refresh if needed
 * @param {string} userId - The user ID
 * @param {string} tokenType - Either 'bot' or 'streamer'
 * @returns {Promise<boolean>}
 */
async function ensureValidToken(userId, tokenType) {
  try {
    const user = await returnAuthObject(userId);
    
    if (!user?.twitch_tokens?.[tokenType]?.refresh_token) {
      return false;
    }
    
    const tokenData = user.twitch_tokens[tokenType];
    const now = Date.now();
    const tokenExpiry = tokenData.expires_at || 0;
    const bufferTime = 5 * 60 * 1000; // 5 minutes buffer
    
    // If token is valid and not close to expiry, return it
    if (tokenData.access_token && now < tokenExpiry - bufferTime) {
      return tokenData.access_token;
    }
    
    // Token needs refresh
    const response = await axios.post(
      "https://id.twitch.tv/oauth2/token",
      new URLSearchParams({
        client_id: await retrieveConfigValue("twitch.clientId"),
        client_secret: await retrieveConfigValue("twitch.clientSecret"),
        grant_type: "refresh_token",
        refresh_token: tokenData.refresh_token
      }),
      { headers: { "Content-Type": "application/x-www-form-urlencoded" } }
    );
    
    const { access_token, refresh_token, expires_in } = response.data;
    
    // Update token in user record with a single operation
    await updateUserParameter(userId, `twitch_tokens.${tokenType}`, {
      ...tokenData,
      access_token,
      refresh_token,
      expires_at: Date.now() + expires_in * 1000,
      scopes: null // Clear cached scopes as they might change
    });
    
    logger.log("Twitch", `Refreshed ${tokenType} token for user ${userId}`);
    return access_token;
  } catch (error) {
    logger.error("Twitch", `Failed to refresh ${tokenType} token: ${error.message}`);
    return false;
  }
}

/**
 * Refresh an expired token
 * @param {string} userId - The user ID
 * @param {string} tokenType - Either 'bot' or 'streamer'
 * @returns {Promise<boolean>}
 */
async function refreshToken(userId, tokenType) {
  try {
    const user = await returnAuthObject(userId);

    const response = await axios.post(
      "https://id.twitch.tv/oauth2/token",
      new URLSearchParams({
        client_id: await retrieveConfigValue("twitch.clientId"),
        client_secret: await retrieveConfigValue("twitch.clientSecret"),
        grant_type: "refresh_token",
        refresh_token: user.twitch_tokens[tokenType].refresh_token,
      }),
      {
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
        },
      }
    );

    const { access_token, refresh_token, expires_in } = response.data;

    // Update token data
    await updateUserParameter(
      userId,
      `twitch_tokens.${tokenType}.access_token`,
      access_token
    );
    await updateUserParameter(
      userId,
      `twitch_tokens.${tokenType}.refresh_token`,
      refresh_token
    );
    await updateUserParameter(
      userId,
      `twitch_tokens.${tokenType}.expires_at`,
      Date.now() + expires_in * 1000
    );

    // Clear cached scopes as they might change with the new token
    await updateUserParameter(
      userId,
      `twitch_tokens.${tokenType}.scopes`,
      null
    );

    return true;
  } catch (error) {
    logger.error(
      "Twitch",
      `Error refreshing token for ${userId}: ${error.message}`
    );
    return false;
  }
}

/**
 * Get Twitch user ID for a user
 * @param {string} userId - The user ID
 * @param {string} tokenType - Either 'bot' or 'streamer'
 * @returns {Promise<string|null>}
 */
async function fetchTwitchUserId(userId, tokenType) {
  try {
    const user = await returnAuthObject(userId);

    // If we already have the ID, return it
    if (user.twitch_tokens?.[tokenType]?.twitch_user_id) {
      logger.log(
        "Twitch",
        `Using existing Twitch user ID for ${userId} (${tokenType}): ${user.twitch_tokens[tokenType].twitch_user_id}`
      );
      return user.twitch_tokens[tokenType].twitch_user_id;
    }

    // Check if we have an access token
    if (!user.twitch_tokens?.[tokenType]?.access_token) {
      logger.error(
        "Twitch",
        `No access token available for ${userId} (${tokenType})`
      );
      return null;
    }

    // Determine which username to use
    let twitchUsername;
    if (tokenType === "bot") {
      if (user.bot_twitch) {
        // Remove @ if present
        twitchUsername = user.bot_twitch.replace(/^@/, "");
      } else {
        logger.error("Twitch", `No bot_twitch username set for user ${userId}`);

        // Try to get user info without a login parameter (gets the authenticated user)
        logger.log(
          "Twitch",
          `Attempting to get authenticated user info for ${userId} (${tokenType})`
        );
        const axios = (await import("axios")).default;

        const response = await axios.get(`https://api.twitch.tv/helix/users`, {
          headers: {
            "Client-ID": await retrieveConfigValue("twitch.clientId"),
            Authorization: `Bearer ${user.twitch_tokens[tokenType].access_token}`,
          },
        });

        if (response.data.data && response.data.data.length > 0) {
          const twitchUserId = response.data.data[0].id;
          const twitchLogin = response.data.data[0].login;
          const twitchDisplayName = response.data.data[0].display_name;

          // Save all the Twitch user info
          await ensureParameterPath(userId, `twitch_tokens.${tokenType}`);
          await updateUserParameter(
            userId,
            `twitch_tokens.${tokenType}.twitch_user_id`,
            twitchUserId
          );
          await updateUserParameter(
            userId,
            `twitch_tokens.${tokenType}.twitch_login`,
            twitchLogin
          );
          await updateUserParameter(
            userId,
            `twitch_tokens.${tokenType}.twitch_display_name`,
            twitchDisplayName
          );

          logger.log(
            "Twitch",
            `Retrieved and saved Twitch user ID for ${userId} (${tokenType}): ${twitchUserId}`
          );
          return twitchUserId;
        }

        logger.error(
          "Twitch",
          `Failed to get user info without login parameter for ${userId} (${tokenType})`
        );
        return null;
      }
    } else {
      // tokenType === 'streamer'
      if (user.twitch_name) {
        twitchUsername = user.twitch_name;
      } else {
        logger.error(
          "Twitch",
          `No twitch_name username set for user ${userId}`
        );

        // Try to get user info without a login parameter (gets the authenticated user)
        logger.log(
          "Twitch",
          `Attempting to get authenticated user info for ${userId} (${tokenType})`
        );
        const axios = (await import("axios")).default;

        const response = await axios.get(`https://api.twitch.tv/helix/users`, {
          headers: {
            "Client-ID": await retrieveConfigValue("twitch.clientId"),
            Authorization: `Bearer ${user.twitch_tokens[tokenType].access_token}`,
          },
        });

        if (response.data.data && response.data.data.length > 0) {
          const twitchUserId = response.data.data[0].id;
          const twitchLogin = response.data.data[0].login;
          const twitchDisplayName = response.data.data[0].display_name;

          // Save all the Twitch user info
          await ensureParameterPath(userId, `twitch_tokens.${tokenType}`);
          await updateUserParameter(
            userId,
            `twitch_tokens.${tokenType}.twitch_user_id`,
            twitchUserId
          );
          await updateUserParameter(
            userId,
            `twitch_tokens.${tokenType}.twitch_login`,
            twitchLogin
          );
          await updateUserParameter(
            userId,
            `twitch_tokens.${tokenType}.twitch_display_name`,
            twitchDisplayName
          );

          logger.log(
            "Twitch",
            `Retrieved and saved Twitch user ID for ${userId} (${tokenType}): ${twitchUserId}`
          );
          return twitchUserId;
        }

        logger.error(
          "Twitch",
          `Failed to get user info without login parameter for ${userId} (${tokenType})`
        );
        return null;
      }
    }

    logger.log(
      "Twitch",
      `Looking up Twitch user ID for ${twitchUsername} (${userId}, ${tokenType})`
    );

    // Import axios if needed
    const axios = (await import("axios")).default;

    const response = await axios.get(
      `https://api.twitch.tv/helix/users?login=${twitchUsername}`,
      {
        headers: {
          "Client-ID": await retrieveConfigValue("twitch.clientId"),
          Authorization: `Bearer ${user.twitch_tokens[tokenType].access_token}`,
        },
      }
    );

    if (response.data.data && response.data.data.length > 0) {
      const twitchUserId = response.data.data[0].id;
      const twitchLogin = response.data.data[0].login;
      const twitchDisplayName = response.data.data[0].display_name;

      // Save all the Twitch user info
      await ensureParameterPath(userId, `twitch_tokens.${tokenType}`);
      await updateUserParameter(
        userId,
        `twitch_tokens.${tokenType}.twitch_user_id`,
        twitchUserId
      );
      await updateUserParameter(
        userId,
        `twitch_tokens.${tokenType}.twitch_login`,
        twitchLogin
      );
      await updateUserParameter(
        userId,
        `twitch_tokens.${tokenType}.twitch_display_name`,
        twitchDisplayName
      );

      logger.log(
        "Twitch",
        `Retrieved and saved Twitch user ID for ${userId} (${tokenType}): ${twitchUserId}`
      );
      return twitchUserId;
    } else {
      logger.error(
        "Twitch",
        `No user found for username ${twitchUsername} (${userId}, ${tokenType})`
      );
      return null;
    }
  } catch (error) {
    logger.error(
      "Twitch",
      `Error fetching Twitch user ID for ${userId} (${tokenType}): ${error.message}`
    );

    // Log response error details if available
    if (error.response) {
      logger.error(
        "Twitch",
        `Response status: ${error.response.status}, data: ${JSON.stringify(error.response.data)}`
      );

      // Handle token issues
      if (error.response.status === 401) {
        logger.log(
          "Twitch",
          `Attempting to refresh token for ${userId} (${tokenType})`
        );
        const refreshed = await refreshToken(userId, tokenType);
        if (refreshed) {
          logger.log("Twitch", `Token refreshed, retrying user ID lookup`);

          // Get fresh user object with new token
          const refreshedUser = await returnAuthObject(userId);

          // Try the request again with the fresh token
          try {
            const axios = (await import("axios")).default;
            const retryResponse = await axios.get(
              `https://api.twitch.tv/helix/users`,
              {
                headers: {
                  "Client-ID": await retrieveConfigValue("twitch.clientId"),
                  Authorization: `Bearer ${refreshedUser.twitch_tokens[tokenType].access_token}`,
                },
              }
            );

            if (retryResponse.data.data && retryResponse.data.data.length > 0) {
              const twitchUserId = retryResponse.data.data[0].id;
              const twitchLogin = retryResponse.data.data[0].login;
              const twitchDisplayName = retryResponse.data.data[0].display_name;

              // Save all the Twitch user info
              await updateUserParameter(
                userId,
                `twitch_tokens.${tokenType}.twitch_user_id`,
                twitchUserId
              );
              await updateUserParameter(
                userId,
                `twitch_tokens.${tokenType}.twitch_login`,
                twitchLogin
              );
              await updateUserParameter(
                userId,
                `twitch_tokens.${tokenType}.twitch_display_name`,
                twitchDisplayName
              );

              logger.log(
                "Twitch",
                `Successfully retrieved Twitch user ID after token refresh: ${twitchUserId}`
              );
              return twitchUserId;
            }
          } catch (retryError) {
            logger.error(
              "Twitch",
              `Failed retry attempt after token refresh: ${retryError.message}`
            );
          }
        }
      }
    }

    return null;
  }
}

/**
 * Process an EventSub notification and map it to our internal format
 * @param {string} eventType - The EventSub event type
 * @param {object} eventData - The event data from Twitch
 * @param {string} userId - The user ID
 * @param {string} eventVersion - The version of the event
 * @returns {Promise<object>} - The processed event
 */
export async function processEventSubNotification(
  eventType,
  eventData,
  userId,
  eventVersion = "1"
) {
  try {
    // Import the existing event handling system
    const { respondToEvent } = await import("./ai-logic.js");

    // Map EventSub event format to internal format
    const mappedEvent = mapEventSubToInternalFormat(
      eventType,
      eventData,
      eventVersion
    );

    // Log the processing
    logger.log(
      "Twitch",
      `Processing ${eventType} (v${eventVersion}) event for user ${userId}`
    );

    // Get response from AI system
    const aiResponse = await respondToEvent(mappedEvent, userId);

    // Check if we have a valid response
    if (aiResponse && aiResponse.response) {
      // Send the response to Twitch chat
      const chatResult = await sendChatMessage(aiResponse.response, userId);

      if (chatResult.success) {
        logger.log(
          "Twitch",
          `Sent response to ${eventType} event to chat: ${aiResponse.response.substring(0, 50)}...`
        );
      } else {
        logger.error(
          "Twitch",
          `Failed to send ${eventType} response to chat: ${chatResult.error}`
        );
      }

      // Return both AI response and chat sending result
      return {
        ...aiResponse,
        chatMessageSent: chatResult.success,
        chatMessageId: chatResult.message_id,
      };
    }

    return aiResponse;
  } catch (error) {
    logger.error("Twitch", `Error processing notification: ${error.message}`);
    throw error;
  }
}

/**
 * Enriches EventSub data with additional broadcaster information
 * @param {string} eventType - The type of event
 * @param {object} eventData - The basic EventSub data
 * @param {string} userId - Enspira user ID
 * @returns {Promise<object>} - Enriched event data
 */
export async function enrichEventData(eventType, eventData, userId) {
  try {
    // Get app access token for API calls
    const appToken = await getAppAccessToken();
    const user = await returnAuthObject(userId);

    // Determine which broadcaster ID we need to fetch data for
    let targetId;
    if (eventType === "channel.raid") {
      targetId = eventData.from_broadcaster_user_id;
    } else if (eventType === "channel.shoutout.create") {
      targetId = eventData.to_broadcaster_user_id;
    } else {
      return eventData; // No enrichment needed
    }

    // Prepare API call configurations
    const channelConfig = {
      method: "get",
      url: `https://api.twitch.tv/helix/channels?broadcaster_id=${targetId}`,
      headers: {
        "Client-ID": await retrieveConfigValue("twitch.clientId"),
        Authorization: `Bearer ${appToken}`,
      },
    };

    const streamConfig = {
      method: "get",
      url: `https://api.twitch.tv/helix/streams?user_id=${targetId}`,
      headers: {
        "Client-ID": await retrieveConfigValue("twitch.clientId"),
        Authorization: `Bearer ${appToken}`,
      },
    };

    const userConfig = {
      method: "get",
      url: `https://api.twitch.tv/helix/users?id=${targetId}`,
      headers: {
        "Client-ID": await retrieveConfigValue("twitch.clientId"),
        Authorization: `Bearer ${appToken}`,
      },
    };

    const followConfig = {
      method: "get",
      url: `https://api.twitch.tv/helix/channels/followers?broadcaster_id=${user.twitch_tokens?.streamer?.twitch_user_id}&user_id=${targetId}`,
      headers: {
        "Client-ID": await retrieveConfigValue("twitch.clientId"),
        Authorization: `Bearer ${appToken}`,
      },
    };

    // Execute API calls in parallel with rate limiting
    const [channelInfo, streamInfo, userData, followData] = await Promise.all([
      callTwitchAPI(channelConfig),
      callTwitchAPI(streamConfig),
      callTwitchAPI(userConfig),
      callTwitchAPI(followConfig).catch((e) => ({ data: { total: 0 } })),
    ]);

    // Check for affiliate/partner status (based on badges)
    if (userData.data.data[0]?.broadcaster_type === "affiliate") {
      enriched.isAffiliate = true; // enriched is undefined here
      enriched.isPartner = false;
    } else if (userData.data.data[0]?.broadcaster_type === "partner") {
      enriched.isAffiliate = false;
      enriched.isPartner = true;
    } else {
      enriched.isAffiliate = false;
      enriched.isPartner = false;
    }

    // Check if target is subbed or is a mod (requires specific API calls with user tokens)
    if (user.twitch_tokens?.streamer?.access_token) {
      try {
        // Check if target is a moderator
        const modResponse = await axios.get(
          `https://api.twitch.tv/helix/moderation/moderators?broadcaster_id=${user.twitch_tokens.streamer.twitch_user_id}&user_id=${targetId}`,
          {
            headers: {
              "Client-ID": await retrieveConfigValue("twitch.clientId"),
              Authorization: `Bearer ${user.twitch_tokens.streamer.access_token}`,
            },
          }
        );

        enriched.isMod = modResponse.data.data.length > 0;

        // Check subscription status (if the shoutout target is subscribed to the streamer)
        const subResponse = await axios
          .get(
            `https://api.twitch.tv/helix/subscriptions?broadcaster_id=${user.twitch_tokens.streamer.twitch_user_id}&user_id=${targetId}`,
            {
              headers: {
                "Client-ID": await retrieveConfigValue("twitch.clientId"),
                Authorization: `Bearer ${user.twitch_tokens.streamer.access_token}`,
              },
            }
          )
          .catch((e) => ({ data: { data: [] } }));

        enriched.isSubbed = subResponse.data.data.length > 0;
      } catch (error) {
        enriched.isMod = false;
        enriched.isSubbed = false;
      }
    }

    return enriched;
  } catch (error) {
    logger.error("Twitch", `Error enriching data: ${error.message}`);
    return {}; // Return empty object on error
  }
}

/**
 * Convert EventSub format to our internal format used by the AI
 * @param {string} eventType - The EventSub event type
 * @param {object} eventData - The event data from Twitch
 * @param {string} version - The version of the event
 * @returns {object} - The mapped event in our internal format
 */
function mapEventSubToInternalFormat(eventType, eventData, version = "1") {
  // Create base event object
  let mappedEvent = { eventType: null, eventData: {} };

  // Map based on event type and version
  switch (eventType) {
    case "channel.update":
      mappedEvent.eventType = "game_change";
      mappedEvent.eventData = {
        game: eventData.category_name || "",
        title: eventData.title || "",
      };
      break;
    case "channel.chat.message":
      mappedEvent.eventType = "chat";
      mappedEvent.eventData = {
        user: eventData.chatter.user_name,
        user_id: eventData.chatter.user_id,
        message: eventData.message.text,
        is_first: eventData.message.is_first || false,
        chatter_is_broadcaster:
          eventData.chatter.user_id === eventData.broadcaster_user_id,
        chatter_is_moderator:
          eventData.chatter.badges?.some(
            (badge) => badge.set_id === "moderator"
          ) || false,
        chatter_is_subscriber:
          eventData.chatter.badges?.some(
            (badge) => badge.set_id === "subscriber"
          ) || false,
        fragments: eventData.message.fragments || [],
        emotes:
          eventData.message.fragments
            ?.filter((frag) => frag.type === "emote")
            .map((emote) => ({
              id: emote.id,
              name: emote.text,
            })) || [],
      };
      break;
    case "channel.follow":
      mappedEvent.eventType = "follow";

      // Handle different versions
      if (version === "2") {
        // v2 format has different fields
        mappedEvent.eventData = {
          username: eventData.user_name || "",
          userId: eventData.user_id || "",
          followed_at: eventData.followed_at || new Date().toISOString(),
        };
      } else {
        // v1 format (legacy)
        mappedEvent.eventData = {
          username: eventData.user_name || "",
          userId: eventData.user_id || "",
          followed_at: eventData.followed_at || new Date().toISOString(),
        };
      }
      break;

    case "channel.subscribe":
      mappedEvent.eventType = "sub";
      mappedEvent.eventData = {
        subType: "sub",
        user: eventData.user_name || "",
        subTier: mapTier(eventData.tier || "1000"),
        isGift: eventData.is_gift || false,
      };
      break;

    case "channel.subscription.gift":
      mappedEvent.eventType = "sub";
      mappedEvent.eventData = {
        subType: "gift_sub",
        user: eventData.is_anonymous ? "Anonymous" : eventData.user_name || "",
        anonymous: eventData.is_anonymous || false,
        subTier: mapTier(eventData.tier || "1000"),
        recipientUserName: eventData.recipient_user_name || "a viewer",
      };
      break;

    case "channel.subscription.message":
      mappedEvent.eventType = "sub";
      mappedEvent.eventData = {
        subType: "resub",
        user: eventData.user_name || "",
        subTier: mapTier(eventData.tier || "1000"),
        streak: eventData.streak_months || 1,
        tenure: eventData.cumulative_months || 1,
        sharedChat: eventData.message ? eventData.message.text : "",
      };
      break;

    case "channel.cheer":
      mappedEvent.eventType = "dono";
      mappedEvent.eventData = {
        donoType: "bits",
        donoFrom: eventData.is_anonymous
          ? "Anonymous"
          : eventData.user_name || "",
        donoAmt: eventData.bits || 0,
        donoMessage: eventData.message || "",
      };
      break;

    case "channel.hype_train.begin":
      mappedEvent.eventType = "hype_start";
      mappedEvent.eventData = {
        level: eventData.level || 1,
        total: eventData.total || 0,
        startedAt: eventData.started_at || new Date().toISOString(),
        expiresAt: eventData.expires_at || "",
        percent: eventData.goal ? eventData.progress / eventData.goal : 0,
        topBitsUser:
          getTopContributor(eventData, "BITS")?.user_name || "Unknown",
        topBitsAmt: getTopContributor(eventData, "BITS")?.total || 0,
        topSubUser:
          getTopContributor(eventData, "SUBSCRIPTION")?.user_name || "Unknown",
        topSubTotal: getTopContributor(eventData, "SUBSCRIPTION")?.total || 0,
      };
      break;

    case "channel.hype_train.progress":
      mappedEvent.eventType = "hype_update";
      mappedEvent.eventData = {
        level: eventData.level || 1,
        total: eventData.total || 0,
        startedAt: eventData.started_at || new Date().toISOString(),
        expiresAt: eventData.expires_at || "",
        percent: eventData.goal ? eventData.progress / eventData.goal : 0,
        contributors: eventData.total_users || 0,
        isGolden: false, // EventSub doesn't have this info
        topBitsUser:
          getTopContributor(eventData, "BITS")?.user_name || "Unknown",
        topBitsAmt: getTopContributor(eventData, "BITS")?.total || 0,
        topSubUser:
          getTopContributor(eventData, "SUBSCRIPTION")?.user_name || "Unknown",
        topSubTotal: getTopContributor(eventData, "SUBSCRIPTION")?.total || 0,
      };
      break;

    case "channel.hype_train.end":
      mappedEvent.eventType = "hype_end";
      mappedEvent.eventData = {
        level: eventData.level || 1,
        total: eventData.total || 0,
        startedAt: eventData.started_at || new Date().toISOString(),
        percent: eventData.goal ? eventData.progress / eventData.goal : 0,
        contributors: eventData.total_users || 0,
        isGolden: false, // EventSub doesn't have this info
        topBitsUser:
          getTopContributor(eventData, "BITS")?.user_name || "Unknown",
        topBitsAmt: getTopContributor(eventData, "BITS")?.total || 0,
        topSubUser:
          getTopContributor(eventData, "SUBSCRIPTION")?.user_name || "Unknown",
        topSubTotal: getTopContributor(eventData, "SUBSCRIPTION")?.total || 0,
      };
      break;

    case "stream.online":
      mappedEvent.eventType = "stream_online";
      mappedEvent.eventData = {
        startTime: eventData.started_at || new Date().toISOString(),
        type: eventData.type || "live", // 'live' or 'playlist' or 'watch_party' or 'premiere' or 'rerun'
      };
      break;

    case "stream.offline":
      mappedEvent.eventType = "stream_offline";
      mappedEvent.eventData = {
        endTime: new Date().toISOString(), // EventSub doesn't provide this, so use current time
      };
      break;
    case "channel.raid":
      mappedEvent.eventType = "raid";
      mappedEvent.eventData = {
        username: eventData.from_broadcaster_user_name || "",
        viewers: eventData.viewers || 0,
        accountAge: "Unknown", // Will need separate API call
        isFollowing: false, // Will need separate API call
        lastGame: "Unknown", // Will need separate API call
      };
      break;

    case "channel.charity_campaign.donate":
      mappedEvent.eventType = "dono";
      mappedEvent.eventData = {
        donoType: "charity",
        donoFrom: eventData.user_name || "Anonymous",
        donoAmt: eventData.amount.value || 0,
        forCharity: eventData.charity_name || "Unknown Charity",
        donoMessage: eventData.message || "",
      };
      break;

    case "channel.channel_points_custom_reward_redemption.add":
      mappedEvent.eventType = "reward";
      mappedEvent.eventData = {
        username: eventData.user_name || "",
        rewardTitle: eventData.reward.title || "Unknown Reward",
        rewardCost: eventData.reward.cost || 0,
        userInput: eventData.user_input || "",
      };
      break;

    case "channel.commercial.begin":
      mappedEvent.eventType = "ad";
      mappedEvent.eventData = {
        minutesLeft: eventData.duration / 60 || 0,
      };
      break;

    case "channel.shoutout.create":
      mappedEvent.eventType = "shoutout";
      mappedEvent.eventData = {
        user: eventData.to_broadcaster_user_name || "",
        user_id: eventData.to_broadcaster_user_id || "",
        accountAge: "Unknown", // Requires separate API call
        game: "Unknown", // Requires separate API call
        lastActive: "Unknown", // Requires separate API call
        streamTitle: "Unknown", // Requires separate API call
        isMod: false,
        isAffiliate: false,
        isPartner: false,
        isSubbed: false,
      };
      break;

    case "channel.chat.notification":
      // For summary and trivia events that come through chat
      if (
        eventData.message.text &&
        eventData.message.text.startsWith("!summary")
      ) {
        mappedEvent.eventType = "summary";
      } else if (
        eventData.message.text &&
        eventData.message.text.startsWith("!trivia")
      ) {
        mappedEvent.eventType = "trivia";
      }
      break;

    default:
      // Direct passthrough for unmapped types
      mappedEvent.eventType = eventType
        .replace("channel.", "")
        .replace("stream.", "");
      mappedEvent.eventData = JSON.parse(JSON.stringify(eventData)); // Create a safe copy
  }

  return mappedEvent;
}

/**
 * Helper function to get top contributor from hype train events
 * @param {object} eventData - The hype train event data
 * @param {string} type - The contribution type to look for
 * @returns {object|null} - The top contributor or null
 */
function getTopContributor(eventData, type) {
  if (
    !eventData ||
    !eventData.top_contributions ||
    !Array.isArray(eventData.top_contributions)
  ) {
    return null;
  }

  return eventData.top_contributions.find(
    (contributor) => contributor.type === type
  );
}

/**
 * Updates stream information for all users
 * @returns {Promise<{updated: number, errors: number}>}
 */
export async function updateAllStreamInfo() {
  try {
    // Get all users
    const users = await returnAPIKeys();
    let updatedCount = 0;
    let errorCount = 0;

    // Process each user
    for (const user of users) {
      try {
        // Skip users without Twitch integration
        if (!user.twitch_tokens?.streamer?.twitch_user_id) {
          continue;
        }

        // Update stream info
        await fetchStreamInfo(user.user_id);
        updatedCount++;
      } catch (userError) {
        errorCount++;
        logger.error(
          "Twitch",
          `Error updating stream info for ${user.user_id}: ${userError.message}`
        );
      }

      // Add a small delay between API calls to avoid rate limits
      await new Promise((resolve) => setTimeout(resolve, 500));
    }

    logger.log(
      "Twitch",
      `Updated stream info for ${updatedCount} users, with ${errorCount} errors`
    );
    return { updated: updatedCount, errors: errorCount };
  } catch (error) {
    logger.error("Twitch", `Error in updateAllStreamInfo: ${error.message}`);
    return { updated: 0, errors: 1 };
  }
}

export function setupTwitchCronJobs() {
  // Update stream info (includes viewer count) every minute
  cron.schedule("*/1 * * * *", async () => {
    try {
      await updateAllStreamInfo();
    } catch (error) {
      logger.error("Cron", `Error in stream info update job: ${error.message}`);
    }
  });

  // Update follower count every 5 minutes even for offline streams
  cron.schedule("*/5 * * * *", async () => {
    try {
      const users = await returnAPIKeys();

      for (const user of users) {
        try {
          // Skip users without Twitch integration
          if (!user.twitch_tokens?.streamer?.twitch_user_id) {
            continue;
          }

          const channelId = user.twitch_tokens.streamer.twitch_user_id;
          const appToken = await getAppAccessToken();

          // Just update follower count
          await fetchFollowerCount(user.user_id, channelId, appToken);
        } catch (userError) {
          logger.error(
            "Twitch",
            `Error updating follower count for ${user.user_id}: ${userError.message}`
          );
        }

        // Add a small delay between API calls to avoid rate limits
        await new Promise((resolve) => setTimeout(resolve, 500));
      }

      logger.log("Twitch", "Completed follower count update for all users");
    } catch (error) {
      logger.error(
        "Cron",
        `Error in follower count update job: ${error.message}`
      );
    }
  });
  cron.schedule("* * * * *", async () => {
    try {
      const users = await returnAPIKeys();

      for (const user of users) {
        try {
          // Skip users without Twitch integration or bot account
          if (!user.twitch_tokens?.bot?.access_token) {
            continue;
          }

          // Skip streams that aren't live (multiple checks for robustness)
          const isStreamLive =
            user.stream_status?.online === true ||
            (user.current_viewers && user.current_viewers > 0);

          if (!isStreamLive) {
            continue;
          }

          // Check if it's time for a fun fact
          const { shouldGenerateFunFact } = await import("./twitch-helper.js");
          const shouldSendFunFact = await shouldGenerateFunFact(user.user_id);

          if (shouldSendFunFact) {
            // Get a random fun fact
            const { funFact } = await import("./api-helper.js");
            const fact = await funFact();

            if (fact) {
              // Send to Twitch chat
              await sendChatMessage(`Fun Fact: ${fact}`, user.user_id);

              logger.log(
                "Twitch",
                `Sent fun fact to ${user.twitch_name || user.user_name}'s channel (currently live with ${user.current_viewers || "unknown"} viewers)`
              );
            }
          }
        } catch (userError) {
          logger.error(
            "Twitch",
            `Error sending fun fact for ${user.user_id}: ${userError.message}`
          );
        }

        // Add a small delay between users
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
    } catch (error) {
      logger.error("Cron", `Error in fun fact job: ${error.message}`);
    }
  });
  logger.log("System", "Twitch cron jobs initialized");
}

async function refreshTwitchToken(userId, tokenType = "streamer") {
  try {
    const user = await returnAuthObject(userId);

    // Validate token type
    if (tokenType !== "bot" && tokenType !== "streamer") {
      logger.log("Twitch", `Invalid token type: ${tokenType}`);
      return false;
    }

    // Get the tokens for the specified type
    const tokens = user.twitch_tokens?.[tokenType];

    if (!tokens || !tokens.refresh_token) {
      logger.log(
        "Twitch",
        `No refresh token found for ${tokenType} account of user ${userId}`
      );
      return false;
    }

    // Check if token is expired or close to expiring (within 10 minutes)
    const isExpired =
      !tokens.expires_at || Date.now() > tokens.expires_at - 10 * 60 * 1000;

    if (!isExpired) {
      return tokens.access_token; // Return existing token if still valid
    }

    // Import axios if needed
    const axios = (await import("axios")).default;

    // Refresh the token
    const response = await axios.post("https://id.twitch.tv/oauth2/token", {
      client_id: await retrieveConfigValue("twitch.clientId"),
      client_secret: await retrieveConfigValue("twitch.clientSecret"),
      grant_type: "refresh_token",
      refresh_token: tokens.refresh_token,
    });

    const { access_token, refresh_token, expires_in } = response.data;

    // Update token in user record
    await updateUserParameter(userId, `twitch_tokens.${tokenType}`, {
      ...tokens, // Keep existing data like user_id
      access_token,
      refresh_token,
      expires_at: Date.now() + expires_in * 1000,
    });

    logger.log("Twitch", `Refreshed ${tokenType} token for user ${userId}`);
    return access_token;
  } catch (error) {
    logger.log(
      "Twitch",
      `Failed to refresh ${tokenType} token: ${error.message}`
    );
    return false;
  }
}

/**
 * Helper for tier mapping
 * @param {string} tier - The Twitch tier string
 * @returns {string} - Our internal tier format
 */
function mapTier(tier) {
  switch (tier) {
    case "1000":
      return "tier 1";
    case "2000":
      return "tier 2";
    case "3000":
      return "tier 3";
    default:
      return "prime";
  }
}
</file>

<file path="prompt-helper.js">
import fs from "fs-extra";
import moment from "moment";
import { socialMedias } from "./twitch-helper.js";
import { interpretEmotions } from "./data-helper.js";
import { returnAuthObject } from "./api-helper.js";
import { tokenizedFromRemote, promptTokenizedFromRemote } from "./token-helper.js";
import { retrieveConfigValue } from "./config-helper.js";
import { returnRecentChats } from "./ai-logic.js";
import { ChatRequestBody, ChatRequestBodyCoT, ToolRequestBody, QueryRequestBody, ModerationRequestBody, SummaryRequestBody } from "./oai-requests.js";
import { jsonrepair } from 'jsonrepair'
import OpenAI from "openai";
import { performance } from "node:perf_hooks";
import { logger } from './create-global-logger.js';
import { utils } from './utils/index.js';

const { getTemplate } = utils.file;
const { replacePlaceholders } = utils.string
const { withErrorHandling } = utils.error

const templateCache = {};

/**
 * Helper function to extract all social media replacements for templates.
 * Gets both the full socials string and individual platform entries.
 *
 * @param {string} userId - The user ID
 * @returns {Promise<object>} - Object containing all social media replacements
 */
async function getSocialMediaReplacements(userId) {
  try {
    // Get the complete socials string for {{socials}} replacement
    const allSocials = await socialMedias(userId);
    
    // Create the base replacements object
    const replacements = {
      "{{socials}}": allSocials || ""
    };
    
    // Get all available platforms for the user
    const socialPlatforms = await socialMedias(userId, "all");
    
    // Add individual platform replacements
    for (const [platform, value] of Object.entries(socialPlatforms)) {
      if (value && value.trim() !== "") {
        replacements[`{{socials.${platform}}}`] = value;
      }
    }
    
    // Add specific commonly used platform shortcuts
    // These are kept for backward compatibility
    replacements["{{soc_tiktok}}"] = await socialMedias(userId, "tiktok") || "";
    replacements["{{soc_youtube}}"] = await socialMedias(userId, "youtube") || "";
    replacements["{{soc_twitter}}"] = await socialMedias(userId, "twitter") || "";
    replacements["{{soc_instagram}}"] = await socialMedias(userId, "instagram") || "";
    
    return replacements;
  } catch (error) {
    logger.log("System", `Error getting social media replacements: ${error.message}`);
    return { "{{socials}}": "" };
  }
}

/**
 * Sends a chat completion request for tool tasks like query writing and reranking.
 * Simplified version without reasoning or chain-of-thought features.
 * 
 * @param {object} requestBody - The request body for the completion.
 * @param {object} modelConfig - Configuration for the model.
 * @returns {Promise<object>} - The completion response.
 */
export async function sendToolCompletionRequest(requestBody, modelConfig) {
  const openai = new OpenAI({
    baseURL: modelConfig.endpoint,
    apiKey: modelConfig.apiKey,
  });

  const startTime = performance.now();
  let fullResponse = "";
  const MAX_RESPONSE_SIZE = 50000; // 50KB limit for tool responses

  try {
    const stream = await openai.chat.completions.create({
      ...requestBody,
      stream: true,
    });

    for await (const part of stream) {
      const content = part.choices[0]?.delta?.content;
      if (content) {
        // Add content to full response, but check size limit
        fullResponse += content;
        
        // If exceeded max size, stop processing stream
        if (fullResponse.length > MAX_RESPONSE_SIZE) {
          logger.log("API", `Tool response exceeded ${MAX_RESPONSE_SIZE/1000}KB limit, truncating`);
          break; // Exit the loop to stop processing more tokens
        }
      }
    }
    
    // Calculate total processing time
    const totalTime = (performance.now() - startTime) / 1000;
    
    // For JSON responses, make sure we have valid JSON
    if (requestBody.response_format?.type === "json_schema") {
      // Check if the response is already an object
      if (typeof fullResponse === 'object' && fullResponse !== null) {
        return {
          response: fullResponse,
          rawResponse: JSON.stringify(fullResponse),
          processingTime: totalTime.toFixed(3)
        };
      }
      
      try {
        // Try parsing the JSON response
        const jsonResponse = JSON.parse(fullResponse);
        return {
          response: jsonResponse,
          rawResponse: fullResponse,
          processingTime: totalTime.toFixed(3)
        };
      } catch (jsonError) {
        // If JSON parsing fails, try to fix it using jsonrepair
        try {
          const fixedResponse = jsonrepair(fullResponse);
          const jsonResponse = JSON.parse(fixedResponse);
          
          logger.log("API", "Fixed malformed JSON in tool response");
          
          return {
            response: jsonResponse,
            rawResponse: fixedResponse,
            processingTime: totalTime.toFixed(3),
            jsonFixed: true
          };
        } catch (repairError) {
          // If repair also fails, return error
          logger.log("API", `Failed to parse JSON response: ${jsonError.message}`);
          return { 
            error: "JSON parsing failed", 
            rawResponse: fullResponse.substring(0, 1000),
            processingTime: totalTime.toFixed(3)
          };
        }
      }
    }
    
    // For non-JSON responses, just return the content
    return {
      response: fullResponse,
      processingTime: totalTime.toFixed(3)
    };
  } catch (error) {
    logger.log(
      "API",
      `Tool completion error: ${error}; Model: ${modelConfig.model}`
    );
    return { error: error.message };
  }
}
export async function sendChatCompletionRequest(requestBody, modelConfig, userObj) {
  const openai = new OpenAI({
    baseURL: modelConfig.endpoint,
    apiKey: modelConfig.apiKey,
  });

  const startTime = performance.now();
  let firstTokenTimeElapsed = null;
  let backendStartTime;
  let fullResponse = "";
  const MAX_RESPONSE_SIZE = 100000; // 100KB limit, adjust as needed
  await fs.writeJSON('./chat-request.json', requestBody)
  try {
    const stream = await openai.chat.completions.create({
      ...requestBody,
      stream: true,
    });

    for await (const part of stream) {
      const content = part.choices[0]?.delta?.content;
      if (content) {
        if (firstTokenTimeElapsed === null) {
          // Calculate time to first token in seconds
          firstTokenTimeElapsed = (performance.now() - startTime) / 1000;
          // Start backend timer after first token arrives
          backendStartTime = performance.now();
        }

        // Add content to full response, but check size limit
        fullResponse += content;

        // Check if response is getting too large (warn at 50KB)
        if (fullResponse.length > 50000 && fullResponse.length < 51000) {
          logger.log("API", "Response size over 50KB, approaching limits");
        }

        // If exceeded max size, stop processing stream - prevents memory issues
        if (fullResponse.length > MAX_RESPONSE_SIZE) {
          logger.log("API", `Response exceeded ${MAX_RESPONSE_SIZE / 1000}KB limit, truncating`);
          fullResponse += "\n\n[Response truncated due to length limits]";
          break; // Exit the loop to stop processing more tokens
        }
      }
    }

    // Calculate backend processing time in seconds
    const backendTimeElapsed = (performance.now() - backendStartTime) / 1000;

    // Tokenize the full response (use simpler calculation if tokenization fails)
    let generatedTokens;
    try {
      generatedTokens = await tokenizedFromRemote(fullResponse);
    } catch (tokenizationError) {
      // Fallback to character-based estimation
      generatedTokens = Math.ceil(fullResponse.length / 4);
    }

    let backendTokensPerSecond = 0;
    if (backendTimeElapsed > 0 && generatedTokens > 0) {
      backendTokensPerSecond = (generatedTokens / backendTimeElapsed).toFixed(2);
    }

    // Enhanced thought process extraction
    let thoughtProcess = "";
    let finalResponse = "";

    // Check for thought tags and determine pattern
    const startTag = "<think>";
    const endTag = "</think>";
    const startTagIndex = fullResponse.indexOf(startTag);
    const endTagIndex = fullResponse.indexOf(endTag);

    // Case 1: Standard format with both <think> and </think>
    if (startTagIndex !== -1 && endTagIndex !== -1 && endTagIndex > startTagIndex) {
      thoughtProcess = fullResponse.substring(startTagIndex + startTag.length, endTagIndex).trim();
      finalResponse = fullResponse.substring(endTagIndex + endTag.length).trim();
    }
    // Case 2: Only </think> exists (no opening tag)
    else if (startTagIndex === -1 && endTagIndex !== -1) {
      thoughtProcess = fullResponse.substring(0, endTagIndex).trim();
      finalResponse = fullResponse.substring(endTagIndex + endTag.length).trim();
    }
    // Case 3: Multiple thought segments or complex pattern
    else if (fullResponse.includes("</think>")) {
      // Initialize markers
      let currentPos = 0;
      let thoughts = [];
      let lastEndTagPos = -1;
      
      // Iterate through finding all segments
      while (true) {
        const nextStartTag = fullResponse.indexOf(startTag, currentPos);
        const nextEndTag = fullResponse.indexOf(endTag, currentPos);
        
        // No more tags found
        if (nextEndTag === -1) break;
        
        // Found a new segment
        lastEndTagPos = nextEndTag;
        
        // If we found a start tag and it comes before the end tag
        if (nextStartTag !== -1 && nextStartTag < nextEndTag) {
          thoughts.push(fullResponse.substring(nextStartTag + startTag.length, nextEndTag).trim());
          currentPos = nextEndTag + endTag.length;
        } 
        // If we only found an end tag (or the end tag comes first)
        else {
          // If this is the first segment and there's no start tag, capture from beginning
          if (thoughts.length === 0 && nextStartTag === -1) {
            thoughts.push(fullResponse.substring(0, nextEndTag).trim());
          } else {
            // Otherwise capture from current position to end tag
            thoughts.push(fullResponse.substring(currentPos, nextEndTag).trim());
          }
          currentPos = nextEndTag + endTag.length;
        }
      }
      
      // Combine all thought segments
      thoughtProcess = thoughts.join("\n");
      
      // Final response is everything after the last </think>
      if (lastEndTagPos !== -1) {
        finalResponse = fullResponse.substring(lastEndTagPos + endTag.length).trim();
      } else {
        finalResponse = fullResponse; // Fallback to full response
      }
    } 
    // Case 4: No think tags found
    else {
      finalResponse = fullResponse.trim();
    }
    
    return {
      response: finalResponse,
      thoughtProcess,
      timeToFirstToken: firstTokenTimeElapsed ? firstTokenTimeElapsed.toFixed(3) : null,
      tokensPerSecond: backendTokensPerSecond,
    };
  } catch (error) {
    logger.log(
      "API",
      `OpenAI chat completion error: ${error}; Model: ${modelConfig.model}`
    );
    return { error: error.message };
  }
}

export async function sendChatCompletionRequestCoT(requestBody, modelConfig) {
  const openai = new OpenAI({
    baseURL: modelConfig.endpoint,
    apiKey: modelConfig.apiKey,
  });

  const startTime = performance.now();
  let firstTokenTimeElapsed = null;
  let backendStartTime;
  let fullResponse = "";

  try {
    const stream = await openai.chat.completions.create({
      ...requestBody,
      stream: true
    });

    for await (const part of stream) {
      const content = part.choices[0]?.delta?.content;
      if (content) {
        if (firstTokenTimeElapsed === null) {
          firstTokenTimeElapsed = (performance.now() - startTime) / 1000;
          backendStartTime = performance.now();
        }
        fullResponse += content;

        // Early warning for large responses
        if (fullResponse.length > 50000) {
          logger.log("API", "CoT response is becoming very large, may cause issues with API returns");
        }
      }
    }

    const backendTimeElapsed = (performance.now() - backendStartTime) / 1000;

    // Tokenize the full response
    let generatedTokens;
    try {
      generatedTokens = await tokenizedFromRemote(fullResponse, modelConfig.modelType);
    } catch (tokenizationError) {
      logger.log("API", `Error tokenizing CoT response: ${tokenizationError}. Using character-based estimate.`);
      generatedTokens = Math.ceil(fullResponse.length / 4); // Rough estimate
    }

    let backendTokensPerSecond = 0;
    if (backendTimeElapsed > 0 && generatedTokens > 0) {
      backendTokensPerSecond = (generatedTokens / backendTimeElapsed).toFixed(2);
    }

    // Attempt to parse the JSON response with multiple fallback mechanisms
    let formattedResponse;
    let thoughtsArray = [];
    let fullOutput = null;

    try {
      // First attempt with regular JSON.parse
      try {
        formattedResponse = JSON.parse(fullResponse);
      } catch (initialParseError) {
        // If that fails, try jsonrepair
        logger.log("API", `Initial JSON parse failed, trying jsonrepair: ${initialParseError.message}`);
        const fixedResponse = jsonrepair(fullResponse);
        formattedResponse = JSON.parse(fixedResponse);
      }

      // Process thoughts array safely
      if (formattedResponse.thoughts) {
        // If thoughts is already an array of strings
        if (Array.isArray(formattedResponse.thoughts)) {
          thoughtsArray = formattedResponse.thoughts.filter(thought => thought && thought !== "");
        }
        // If thoughts is an array of objects with 'thought' property
        else if (Array.isArray(formattedResponse.thoughts) &&
          formattedResponse.thoughts.length > 0 &&
          formattedResponse.thoughts[0].thought) {
          thoughtsArray = formattedResponse.thoughts
            .map(t => t.thought)
            .filter(thought => thought && thought !== "");
        } else {
          // Invalid format for thoughts, create a default
          logger.log("API", "Invalid thoughts format in response, using empty array");
          thoughtsArray = [];
        }
      }

      // Extract final response safely
      fullOutput = formattedResponse.final_response || formattedResponse.response || "";

      // Truncate if too long
      if (fullOutput && fullOutput.length > 100000) {
        logger.log("API", `CoT response too large (${fullOutput.length} bytes), truncating`);
        fullOutput = fullOutput.substring(0, 100000) + "\n[Response truncated due to length...]";
      }

    } catch (parseError) {
      logger.log(
        "API",
        `Error parsing JSON response: ${parseError}; Response: ${fullResponse.substring(0, 500)}...`,
        "error"
      );

      // Last resort emergency parsing attempt
      try {
        // Try to extract anything that looks like a final response
        const finalResponseMatch = fullResponse.match(/"final_response"\s*:\s*"([^"]+)"/);
        if (finalResponseMatch && finalResponseMatch[1]) {
          fullOutput = finalResponseMatch[1];
        } else {
          fullOutput = "I apologize, but I encountered an error processing your message.";
        }

        // Log the parse failure
        logger.error("API", `All JSON parsing attempts failed. Constructed basic response.`);
        thoughtsArray = ["Error parsing JSON response"];
      } catch (emergencyError) {
        logger.error("API", `Emergency parsing also failed: ${emergencyError.message}`);
        return {
          error: `Error parsing JSON: ${parseError.message}`,
          rawResponse: fullResponse.substring(0, 1000)
        };
      }
    }

    return {
      response: fullOutput,
      thoughtProcess: thoughtsArray,
      timeToFirstToken: firstTokenTimeElapsed ? firstTokenTimeElapsed.toFixed(2) : null,
      tokensPerSecond: backendTokensPerSecond,
    };
  } catch (error) {
    logger.log(
      "API",
      `OpenAI chat completion error: ${error}; Model Config: ${JSON.stringify(modelConfig)}`,
      "error"
    );
    return { error: error.message };
  }
}

const moderatorPrompt = async (message, userId) => {
  const userObject = await returnAuthObject(userId);
  const instructTemplate = await withErrorHandling(
    () => getTemplate(`./instructs/helpers/moderation.prompt`),
    { 
      context: 'Templates', 
      defaultValue: '', 
      logError: true 
    }
  ); 
  // Get social media replacements with enhanced platform-specific support
  const socialReplacements = await getSocialMediaReplacements(userId);

  const replacements = {
    "{{user}}": userObject.user_name,
    "{{char}}": userObject.bot_name,
    "{{twitch}}": userObject.twitch_name,
    "{{modlist}}": userObject.mod_list.join("\n- "),
    "{{sites}}": userObject.approved_sites.join("\n- "),
    ...socialReplacements
  };

  const instructionTemplate = replacePlaceholders(instructTemplate, replacements);
  const promptWithSamplers = await ModerationRequestBody.create(
    instructionTemplate,
    await retrieveConfigValue("models.moderator.model"),
    message
  );
  
  logger.log(
    "LLM",
    `Moderation prompt is using ${await promptTokenizedFromRemote(
      promptWithSamplers.messages,
    )} of your available ${await retrieveConfigValue("models.moderator.maxTokens")} tokens.`
  );
  return promptWithSamplers;
};

/**
 * Generates a chat completion body with context, instructions, and message.
 * Enhanced with better support for social media templating.
 *
 * @param {object} promptData - Data containing relevant context, chats, and voice interactions.
 * @param {string} message - The user message.
 * @param {string} userID - The user ID.
 * @returns {Promise<object>} - The chat completion body.
 */
const contextPromptChat = async (promptData, message, userID) => {
  const currentAuthObject = await returnAuthObject(userID);
  const instructTemplate = await withErrorHandling(
    () => getTemplate(`./instructs/system.prompt`),
    { 
      context: 'Templates', 
      defaultValue: '', 
      logError: true 
    }
  );  
  
  const timeStamp = moment().format("dddd, MMMM Do YYYY, [at] hh:mm A");

  // Load all necessary files in parallel for better performance
  const fileContents = await readPromptFiles(userID, [
    "character_personality",
    "world_lore",
    "scenario",
    "character_card",
    "weather",
    "twitch_chat",
    "player_info",
    "voice_messages",
  ]);

  const sentiment = await interpretEmotions(message);
  logger.log("LLM", `Analysis of emotions: ${sentiment}`);
  const user = promptData.chat_user;

  // Get social media replacements with enhanced platform-specific support
  const socialReplacements = await getSocialMediaReplacements(userID);

  // Common replacements for preprocessing text
  const commonReplacements = {
    "{{user}}": currentAuthObject.user_name,
    "{{char}}": currentAuthObject.bot_name,
    "{{char_limit}}": await retrieveConfigValue("twitch.maxCharLimit"),
    "{{chat_user}}": user,
    "{{model_author}}": await retrieveConfigValue("models.chat.author"),
    "{{model_org}}": await retrieveConfigValue("models.chat.organization"),
    // Add all social media replacements
    ...socialReplacements
  };

  // Process system prompt
  const systemPrompt = replacePlaceholders(instructTemplate, commonReplacements);

  // Structure the prompt data in the format expected by the new ChatRequestBody
  const structuredPromptData = {
    systemPrompt: systemPrompt,
    
    // Character information
    characterDescription: fileContents.character_card ? 
      `# ${currentAuthObject.bot_name}'s Description:\n${replacePlaceholders(fileContents.character_card, commonReplacements)}` : null,
      
    characterPersonality: fileContents.character_personality ? 
      `# ${currentAuthObject.bot_name}'s Personality:\n${replacePlaceholders(fileContents.character_personality, commonReplacements)}` : null,
    
    // World information
    worldInfo: fileContents.world_lore ? 
      `# World Information:\nUse this information to reflect the world and context around ${currentAuthObject.bot_name}:\n${replacePlaceholders(fileContents.world_lore, commonReplacements)}` : null,
    
    // Scenario
    scenario: fileContents.scenario ? 
      `# Scenario:\n${replacePlaceholders(fileContents.scenario, commonReplacements)}` : null,
    
    // Player information
    playerInfo: fileContents.player_info ? 
      `# Information about ${currentAuthObject.user_name}:\nThis is pertinent information regarding ${currentAuthObject.user_name} that you should always remember.\n${replacePlaceholders(fileContents.player_info, commonReplacements)}` : null,
    
    // Current chat messages
    recentChat: `# Current Messages from Chat:\nUp to the last ${await retrieveConfigValue("twitch.maxChatsToSave")} messages are provided to you from ${currentAuthObject.user_name}'s Twitch chat. Use these messages to keep up with the current conversation:\n${await returnRecentChats(userID)}`,
    
    // Weather information
    weatherInfo: currentAuthObject.weather && fileContents.weather ? 
      `# Current Weather:\n${replacePlaceholders(fileContents.weather, commonReplacements)}` : null,
    
    // Additional context elements
    additionalContext: {
      // Relevant context search results if available
      contextResults: promptData.relContext ? 
        `# Additional Information:\nExternal context relevant to the conversation:\n${promptData.relContext}` : null,
      
      // Relevant chat history if available
      chatHistory: promptData.relChats ? 
        `# Other Relevant Chat Context:\nBelow are potentially relevant chat messages sent previously, that may be relevant to the conversation:\n${promptData.relChats}` : null,
      
      // Voice interactions if available
      voiceInteractions: promptData.relVoice ? 
        `# Previous Voice Interactions:\nNon-exhaustive list of prior vocal interactions you've had with ${currentAuthObject.user_name}:\n${promptData.relVoice}` : null,
      
      // Recent voice messages if available
      recentVoice: fileContents.voice_messages ? 
        `# Current Voice Conversations with ${currentAuthObject.user_name}:\nUp to the last ${await retrieveConfigValue("twitch.maxChatsToSave")} voice messages are provided to you. Use these voice messages to help you keep up with the current conversation:\n${fileContents.voice_messages}` : null,
      
      // Emotional assessment
      emotionalAssessment: sentiment ? 
        `# Current Emotional Assessment of Message:\n- ${sentiment}` : null,
      
      // Current date/time
      dateTime: `# Current Date and Time:\n- The date and time where you and ${currentAuthObject.user_name} live is currently: ${timeStamp}`
    },
    
    // The actual user message
    userMessage: `${promptData.chat_user} says: "${message}"`
  };

  // Create the chat request body with our structured prompt data
  const promptWithSamplers = await ChatRequestBody.create(structuredPromptData);

  logger.log(
    "LLM",
    `Chat prompt is using ${await promptTokenizedFromRemote(
      promptWithSamplers.messages
    )} of your available ${await retrieveConfigValue(
      "models.chat.maxTokens"
    )} tokens.`
  );
  
  return promptWithSamplers;
};


const contextPromptChatCoT = async (promptData, message, userID) => {
  const currentAuthObject = await returnAuthObject(userID);
  const instructTemplate = await withErrorHandling(
    () => getTemplate(`./instructs/system_cot.prompt`),
    { 
      context: 'Templates', 
      defaultValue: '', 
      logError: true 
    }
  );    const timeStamp = moment().format("dddd, MMMM Do YYYY, [at] hh:mm A");

  // Load all necessary files in parallel for better performance
  const fileContents = await readPromptFiles(userID, [
    "character_personality",
    "world_lore",
    "scenario",
    "character_card",
    "weather",
    "twitch_chat",
    "player_info",
    "voice_messages",
  ]);

  const sentiment = await interpretEmotions(message);
  logger.log("LLM", `Analysis of emotions: ${sentiment}`);

  // Get social media replacements with enhanced platform-specific support
  const socialReplacements = await getSocialMediaReplacements(userID);

  // Common replacements for preprocessing text
  const commonReplacements = {
    "{{user}}": currentAuthObject.user_name,
    "{{char}}": currentAuthObject.bot_name,
    "{{char_limit}}": await retrieveConfigValue("twitch.maxCharLimit"),
    "{{chat_user}}": promptData.user,
    "{{model_author}}": await retrieveConfigValue("models.chat.author"),
    "{{model_org}}": await retrieveConfigValue("models.chat.organization"),
    // Add all social media replacements
    ...socialReplacements
  };

  // Process system prompt and add CoT instructions
  let systemPrompt = replacePlaceholders(instructTemplate, commonReplacements);

  // Structure the prompt data in the format expected by the ChatRequestBodyCoT
  const structuredPromptData = {
    systemPrompt: systemPrompt,
    
    // Character information
    characterDescription: fileContents.character_card ? 
      `# ${currentAuthObject.bot_name}'s Description:\n${replacePlaceholders(fileContents.character_card, commonReplacements)}` : null,
      
    characterPersonality: fileContents.character_personality ? 
      `# ${currentAuthObject.bot_name}'s Personality:\n${replacePlaceholders(fileContents.character_personality, commonReplacements)}` : null,
    
    // World information
    worldInfo: fileContents.world_lore ? 
      `# World Information:\nUse this information to reflect the world and context around ${currentAuthObject.bot_name}:\n${replacePlaceholders(fileContents.world_lore, commonReplacements)}` : null,
    
    // Scenario
    scenario: fileContents.scenario ? 
      `# Scenario:\n${replacePlaceholders(fileContents.scenario, commonReplacements)}` : null,
    
    // Player information
    playerInfo: fileContents.player_info ? 
      `# Information about ${currentAuthObject.user_name}:\nThis is pertinent information regarding ${currentAuthObject.user_name} that you should always remember.\n${replacePlaceholders(fileContents.player_info, commonReplacements)}` : null,
    
    // Current chat messages
    recentChat: `# Current Messages from Chat:\nUp to the last ${await retrieveConfigValue("twitch.maxChatsToSave")} messages are provided to you from ${currentAuthObject.user_name}'s Twitch chat. Use these messages to keep up with the current conversation:\n${await returnRecentChats(userID)}`,
    
    // Weather information
    weatherInfo: currentAuthObject.weather && fileContents.weather ? 
      `# Current Weather:\n${replacePlaceholders(fileContents.weather, commonReplacements)}` : null,
    
    // Additional context elements
    additionalContext: {
      // Relevant context search results if available
      contextResults: promptData.relContext ? 
        `# Additional Information:\nExternal context relevant to the conversation:\n${promptData.relContext}` : null,
      
      // Relevant chat history if available
      chatHistory: promptData.relChats ? 
        `# Other Relevant Chat Context:\nBelow are potentially relevant chat messages sent previously, that may be relevant to the conversation:\n${promptData.relChats}` : null,
      
      // Voice interactions if available
      voiceInteractions: promptData.relVoice ? 
        `# Previous Voice Interactions:\nNon-exhaustive list of prior vocal interactions you've had with ${currentAuthObject.user_name}:\n${promptData.relVoice}` : null,
      
      // Recent voice messages if available
      recentVoice: fileContents.voice_messages ? 
        `# Current Voice Conversations with ${currentAuthObject.user_name}:\nUp to the last ${await retrieveConfigValue("twitch.maxChatsToSave")} voice messages are provided to you. Use these voice messages to help you keep up with the current conversation:\n${fileContents.voice_messages}` : null,
      
      // Emotional assessment
      emotionalAssessment: sentiment ? 
        `# Current Emotional Assessment of Message:\n- ${sentiment}` : null,
      
      // Current date/time
      dateTime: `# Current Date and Time:\n- The date and time where you and ${currentAuthObject.user_name} live is currently: ${timeStamp}`
    },
    
    // The actual user message
    userMessage: `${promptData.chat_user} says: "message"`,
    
    // Flag for chain-of-thought processing
    isChainOfThought: true
  };

  // Create the chat request body with our structured prompt data
  const promptWithSamplers = await ChatRequestBodyCoT.create(structuredPromptData);

  logger.log(
    "LLM",
    `Thoughtful chat prompt is using ${await promptTokenizedFromRemote(
      promptWithSamplers.messages
    )} of your available ${await retrieveConfigValue(
      "models.chat.maxTokens"
    )} tokens.`
  );
  
  return promptWithSamplers;
};

/**
 * Generates a chat completion body for event-based interactions.
 * Enhanced with better support for social media templating.
 *
 * @param {string} message - The event message.
 * @param {string} userId - The user ID.
 * @returns {Promise<object>} - The chat completion body.
 */
const eventPromptChat = async (message, userId) => {
  const userObject = await returnAuthObject(userId);
  logger.log(
    "System",
    `Doing eventing stuff for: ${userObject.user_name} and ${userId}`
  );

  const instructTemplate = await withErrorHandling(
    () => getTemplate(`./instructs/system.prompt`),
    { 
      context: 'Templates', 
      defaultValue: '', 
      logError: true 
    }
  );    
  
  const timeStamp = moment().format("dddd, MMMM Do YYYY, [at] hh:mm A");

  // Load all necessary files in parallel for better performance
  const fileContents = await readPromptFiles(userId, [
    "character_personality",
    "world_lore",
    "scenario",
    "character_card",
    "weather",
    "player_info",
  ]);

  // Get social media replacements with enhanced platform-specific support
  const socialReplacements = await getSocialMediaReplacements(userId);

  // Common replacements for preprocessing text
  const commonReplacements = {
    "{{user}}": userObject.user_name,
    "{{char}}": userObject.bot_name,
    "{{char_limit}}": await retrieveConfigValue("twitch.maxCharLimit"),
    "{{model_author}}": await retrieveConfigValue("models.chat.author"),
    "{{model_org}}": await retrieveConfigValue("models.chat.organization"),
    // Add all social media replacements
    ...socialReplacements
  };

  // Process system prompt
  const systemPrompt = replacePlaceholders(instructTemplate, commonReplacements);

  // Structure the prompt data in the format expected by the new ChatRequestBody
  const structuredPromptData = {
    systemPrompt: systemPrompt,
    
    // Character information
    characterDescription: fileContents.character_card ? 
      `# ${userObject.bot_name}'s Description:\n${replacePlaceholders(fileContents.character_card, commonReplacements)}` : null,
      
    characterPersonality: fileContents.character_personality ? 
      `# ${userObject.bot_name}'s Personality:\n${replacePlaceholders(fileContents.character_personality, commonReplacements)}` : null,
    
    // World information
    worldInfo: fileContents.world_lore ? 
      `# World Information:\nUse this information to reflect the world and context around ${userObject.bot_name}:\n${replacePlaceholders(fileContents.world_lore, commonReplacements)}` : null,
    
    // Scenario
    scenario: fileContents.scenario ? 
      `# Scenario:\n${replacePlaceholders(fileContents.scenario, commonReplacements)}` : null,
    
    // Player information
    playerInfo: fileContents.player_info ? 
      `# Information about ${userObject.user_name}:\nThis is pertinent information regarding ${userObject.user_name} that you should always remember.\n${replacePlaceholders(fileContents.player_info, commonReplacements)}` : null,
    
    // Current chat messages
    recentChat: `# Current Messages from Chat:\nUp to the last ${await retrieveConfigValue("twitch.maxChatsToSave")} messages are provided to you from ${userObject.user_name}'s Twitch chat. Use these messages to keep up with the current conversation:\n${await returnRecentChats(userId)}`,
    
    // Weather information
    weatherInfo: userObject.weather && fileContents.weather ? 
      `# Current Weather:\n${replacePlaceholders(fileContents.weather, commonReplacements)}` : null,

    // Additional context elements
    additionalContext: {
      // Current date/time
      dateTime: `# Current Date and Time:\n- The date and time where you and ${userObject.user_name} live is currently: ${timeStamp}`
    },
    
    // The actual user message
    userMessage: message
  };

  // Create the chat request body with our structured prompt data
  const promptWithSamplers = await ChatRequestBody.create(structuredPromptData);

  logger.log(
    "LLM",
    `Event handler prompt is using ${await promptTokenizedFromRemote(
      promptWithSamplers.messages
    )} of your available ${await retrieveConfigValue(
      "models.chat.maxTokens"
    )} tokens.`
  );
  
  return promptWithSamplers;
};

/**
 * Generates a prompt for querying information with specific parameters.
 *
 * @param {string} message - The query message.
 * @param {string} userId - The user ID.
 * @returns {Promise<object>} - The prompt with samplers for querying.
 */
const queryPrompt = async (message, userId) => {
  const userObject = await returnAuthObject(userId);
  const instructTemplate = await withErrorHandling(
    () => getTemplate(`./instructs/helpers/query.prompt`),
    { 
      context: 'Templates', 
      defaultValue: '', 
      logError: true 
    }
  );   const timeStamp = moment().format("MM/DD/YY [at] HH:mm");
  const [dateString, timeString] = timeStamp.split(" at ");

  // Get social media replacements with enhanced platform-specific support
  const socialReplacements = await getSocialMediaReplacements(userId);

  const replacements = {
    "{{datetime}}": `${dateString}. The current time is ${timeString}`,
    "{{query}}": message,
    "{{user}}": userObject.user_name,
    "{{char}}": userObject.bot_name,
    ...socialReplacements
  };

  const instructionTemplate = replacePlaceholders(instructTemplate, replacements);
  const promptWithSamplers = await QueryRequestBody.create(
    instructionTemplate,
    await retrieveConfigValue("models.query.model"),
    message
  )

  logger.log(
    "LLM",
    `Search query prompt is using ${await promptTokenizedFromRemote(
      promptWithSamplers.messages
    )} of your available ${await retrieveConfigValue("models.query.maxTokens")} tokens.`
  );
  return promptWithSamplers;
};

/**
 * Generates a prompt for reranking search results based on a message.
 *
 * @param {string} message - The message for reranking.
 * @param {string} userId - The user ID.
 * @returns {Promise<object>} - The prompt with samplers for reranking.
 */
const rerankPrompt = async (message, userId) => {
  logger.log("Rerank", `Received message ${message}`);
  const userObject = await returnAuthObject(userId);
  const instructTemplate = await withErrorHandling(
    () => getTemplate(`./instructs/helpers/rerank.prompt`),
    { 
      context: 'Templates', 
      defaultValue: '', 
      logError: true 
    }
  ); 
  // Get social media replacements with enhanced platform-specific support
  const socialReplacements = await getSocialMediaReplacements(userId);

  const replacements = {
    "{{user}}": userObject.user_name,
    ...socialReplacements
  };

  const instructionTemplate = replacePlaceholders(instructTemplate, replacements);
  const promptWithSamplers = await ToolRequestBody.create(
    instructionTemplate,
    await retrieveConfigValue("models.rerankTransform.model"),
    message
  )

  logger.log(
    "LLM",
    `Reranking prompt is using ${await promptTokenizedFromRemote(
      promptWithSamplers.messages
    )} of your available ${await retrieveConfigValue("models.rerankTransform.maxTokens")} tokens.`
  );
  return promptWithSamplers;
};

const summaryPrompt = async (textContent) => {
  const instructTemplate = await withErrorHandling(
    () => getTemplate(`./instructs/helpers/summary.prompt`),
    { 
      context: 'Templates', 
      defaultValue: '', 
      logError: true 
    }
  ); 
  const promptWithSamplers = await SummaryRequestBody.create(
    instructTemplate,
    await retrieveConfigValue("models.summary.model"),
    textContent
  )

  logger.log(
    "LLM",
    `Summary prompt is using ${await promptTokenizedFromRemote(
      promptWithSamplers.messages
    )} of your available ${await retrieveConfigValue("models.summary.maxTokens")} tokens.`
  );
  return promptWithSamplers;
};

/**
 * Reads multiple files and returns their contents in an object.
 *
 * @param {string} userId - The user ID.
 * @param {string[]} fileNames - An array of file names to read.
 * @returns {Promise<object>} - An object containing file names as keys and their contents as values.
 */
async function readPromptFiles(userId, fileNames) {
  const fileContents = {};
  await Promise.all(
    fileNames.map(async (fileName) => {
      const filePath = `./world_info/${userId}/${fileName}.txt`;
      try {
        fileContents[fileName] = await fs.readFile(filePath, "utf-8");
      } catch (error) {
        logger.log("Files", `Error reading file ${filePath}: ${error}`);
        fileContents[fileName] = ""; // Provide a default value or handle the error as needed
      }
    })
  );
  return fileContents;
}

/**
 * Strips specific patterns and extra whitespace from a message.
 *
 * @param {string} message - The message to be stripped.
 * @param {string} userId - The user ID.
 * @returns {Promise<string>} - The stripped message.
 */
const replyStripped = async (message, userId) => {
  const userObj = await returnAuthObject(userId);
  let formatted = message
    .replace(/(\r\n|\n|\r)/gm, " ") // Replace newlines with spaces
    .replace(new RegExp(`${userObj.bot_name}:\\s?`, "g"), "") // Remove bot's name followed by a colon and optional space
    .replace(/\(500 characters\)/g, "") // Remove (500 characters)
    .replace(/\\/g, "") // Remove backslashes
    .replace(/\p{Emoji_Presentation}|\p{Extended_Pictographic}/gu, "") // Remove only graphical emojis
    .replace(/\s+/g, " ") // Replace multiple spaces with a single space
    .replace("shoutout", "shout out")
  // Remove unmatched quotes ONLY at the beginning or end of the string
  formatted = formatted.replace(/^['"]|['"]$/g, ""); // Trim unmatched quotes at start and end

  return formatted.trim(); // Trim leading and trailing whitespace
};

/**
 * Transforms a string by replacing acronyms and specific file extensions with a modified format.
 *
 * @param {string} inputString - The string to transform.
 * @returns {Promise<object>} - An object containing the transformed string and the counts of acronyms and specific patterns found.
 */
const fixTTSString = async (inputString) => {
  const acronymRegex = /\b([A-Z]{2,})(?!\w)/g;
  const jsRegex = /\.js\b/gi;

  const exceptions = ["GOATs", "LOL", "LMAO"];

  let acronymCount = 0;
  let jsCount = 0;

  let transformedString = inputString.replace(acronymRegex, (match) => {
    if (exceptions.includes(match)) {
      return match; // Skip transformation for exceptions
    }

    acronymCount++;
    let transformed =
      match.slice(0, -1).split("").join(".") + "." + match.slice(-1);
    if (match.endsWith("S") && match.length > 2) {
      const base = match.slice(0, -1).split("").join(".");
      transformed = `${base}'s`;
    }
    return transformed;
  });

  transformedString = transformedString.replace(jsRegex, (match) => {
    jsCount++;
    return ".J.S";
  });

  return { fixedString: transformedString, acronymCount, jsCount };
};


/**
 * Filters out character names from a message based on a regular expression.
 *
 * @param {string} str - The message string.
 * @param {string} userId - The user ID.
 * @returns {Promise<string>} - The filtered message.
 */
const filterCharacterFromMessage = async (str, userId) => {
  const userObject = await returnAuthObject(userId);
  const twitchRegex = new RegExp(`@?${userObject.bot_twitch}`, "i");
  const nameRegex = new RegExp(
    `,?\\s*\\b(?:${userObject.bot_name}|hey ${userObject.bot_name})\\b,?\\s*`,
    "i"
  );

  let result = str.replace(twitchRegex, "").trim();
  result = result.replace(nameRegex, "").trim();

  return result;
};

/**
 * Checks if a message contains the character's name or Twitch username.
 *
 * @param {string} message - The message to check.
 * @param {string} userId - The user ID.
 * @returns {Promise<boolean>} - True if the message contains the character's name or Twitch username, false otherwise.
 */
async function containsCharacterName(message, userId) {
  const userObj = await returnAuthObject(userId);
  const characterName = userObj.bot_name;
  const characterTwitchUser = userObj.bot_twitch;

  const nameRegex = new RegExp(characterName, "i");

  const twitchHandle = characterTwitchUser.startsWith("@")
    ? characterTwitchUser.slice(1)
    : characterTwitchUser;
  const twitchHandleRegex = new RegExp(twitchHandle, "i");

  return nameRegex.test(message) || twitchHandleRegex.test(message);
}

/**
 * Checks if a message contains the player's social media identifiers.
 *
 * @param {string} message - The message to check.
 * @param {string} userId - The user ID.
 * @returns {Promise<boolean>} - True if the message contains the player's social media identifiers, false otherwise.
 */
async function containsPlayerSocials(message, userId) {
  const userObj = await returnAuthObject(userId);
  const nameRegex = new RegExp(userObj.twitch_name, "i");
  return nameRegex.test(message);
}

/**
 * Checks if a message contains any of the auxiliary bot names.
 *
 * @param {string} message - The message to check.
 * @param {string} userId - The user ID.
 * @returns {Promise<boolean>} - True if the message contains any of the auxiliary bot names, false otherwise.
 */
async function containsAuxBotName(message, userId) {
  const userObj = await returnAuthObject(userId);
  const auxBots = [...userObj.aux_bots];
  if (typeof message !== "string" || !Array.isArray(auxBots)) {

  }

  const lowerCaseMessage = message.toLowerCase();
  for (const username of auxBots) {
    if (lowerCaseMessage.includes(username.toLowerCase())) {
      return true;
    }
  }
  return false;
}

export {
  replyStripped,
  moderatorPrompt,
  containsAuxBotName,
  containsPlayerSocials,
  summaryPrompt,
  filterCharacterFromMessage,
  queryPrompt,
  contextPromptChat,
  contextPromptChatCoT,
  fixTTSString,
  rerankPrompt,
  eventPromptChat,
  containsCharacterName
};
</file>

<file path="ai-logic.js">
import axios from "axios";
import fs from "fs-extra";
import path from "path";
import fetch from "node-fetch";
import https from "https";
import { performance } from "node:perf_hooks";
import { processAudio } from "./audio-processor.js";
import {
  MilvusClient,
  DataType,
  MetricType,
  IndexType,
  ConsistencyLevelEnum,
  LoadState,
  buildSearchParams,
} from "@zilliz/milvus2-sdk-node";
import OpenAI from "openai";
import FormData from "form-data";
import {
  replyStripped,
  queryPrompt,
  contextPromptChat,
  eventPromptChat,
  rerankPrompt,
  fixTTSString,
  sendChatCompletionRequest,
  sendToolCompletionRequest,
} from "./prompt-helper.js";
import { SummaryRequestBody } from "./oai-requests.js";
import { returnTwitchEvent } from "./twitch-helper.js";
import {
  resultsReranked,
  createRagError,
  pullFromWebScraper,
} from "./data-helper.js";
import { returnAuthObject } from "./api-helper.js";
import { retrieveConfigValue } from "./config-helper.js";
import { fileURLToPath } from "url";

const queryCache = new Map();
const collectionLoadStatus = new Map();
const pendingVectors = new Map();
const MAX_BATCH_SIZE = 100;
const MAX_CACHE_SIZE = 150;
const DEFAULT_TTL = 60000;
const MAX_WAIT_MS = 500;

/**
 * Get a cached result if available and not expired
 * @param {string} key - Unique cache key
 * @returns {any} - The cached result or null if not found/expired
 */
function getCachedResult(key) {
  if (!queryCache.has(key)) return null;

  const { result, expiry } = queryCache.get(key);
  if (Date.now() > expiry) {
    // Expired entry
    queryCache.delete(key);
    return null;
  }

  logger.log("Milvus", `Cache hit for query: ${key}`);
  return result;
}

/**
 * Store a result in the query cache
 * @param {string} key - Unique cache key
 * @param {any} result - Result to cache
 * @param {number} ttl - Time to live in milliseconds
 */
function setCachedResult(key, result, ttl = DEFAULT_TTL) {
  // Implement LRU eviction if cache gets too large
  if (queryCache.size >= MAX_CACHE_SIZE) {
    // Find and delete oldest entry
    let oldestKey = null;
    let oldestTime = Infinity;

    for (const [cachedKey, value] of queryCache.entries()) {
      if (value.expiry < oldestTime) {
        oldestTime = value.expiry;
        oldestKey = cachedKey;
      }
    }

    if (oldestKey) {
      queryCache.delete(oldestKey);
    }
  }

  // Add new entry to cache
  queryCache.set(key, {
    result,
    expiry: Date.now() + ttl,
  });
}

/**
 * Clear the entire query cache or entries matching a pattern
 * @param {string} [pattern] - Optional pattern to match keys for selective clearing
 */
function clearQueryCache(pattern = null) {
  if (!pattern) {
    queryCache.clear();
    logger.log("Milvus", "Query cache cleared");
    return;
  }

  // Selective clearing based on pattern
  for (const key of queryCache.keys()) {
    if (key.includes(pattern)) {
      queryCache.delete(key);
    }
  }

  logger.log("Milvus", `Query cache entries matching '${pattern}' cleared`);
}

async function retryMilvusOperation(
  operation,
  maxRetries = 3,
  initialDelay = 100
) {
  let lastError;
  let delay = initialDelay;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error;

      // Determine if error is retryable
      const isRetryable =
        error.message?.includes("connection") ||
        error.message?.includes("timeout") ||
        error.message?.includes("busy") ||
        error.code === "NetworkError" ||
        error.status?.code === "Unavailable";

      if (isRetryable && attempt < maxRetries) {
        logger.log(
          "Milvus",
          `Retrying operation, attempt ${attempt}/${maxRetries} after ${delay}ms delay. Error: ${error.message}`
        );
        await new Promise((resolve) => setTimeout(resolve, delay));
        delay *= 2; // Exponential backoff
      } else {
        // Non-retryable error or max retries reached
      }
    }
  }

  throw lastError; // Should not reach here normally
}

async function ensureCollectionLoaded(collectionName, userId) {
  const key = `${collectionName}_${userId}`;
  const cacheExpiry = 60 * 60 * 1000; // 1 hour

  // Check cache first
  const cached = collectionLoadStatus.get(key);
  if (cached && cached.loaded && Date.now() - cached.timestamp < cacheExpiry) {
    return true;
  }

  // Not in cache or expired, need to check/load
  try {
    const collectionStatus = await client.getLoadState({
      collection_name: key,
    });

    if (collectionStatus.state === LoadState.LoadStateNotExist) {
      logger.log("Milvus", `Collection ${key} does not exist`);
      return false;
    }

    if (collectionStatus.state === LoadState.LoadStateNotLoad) {
      await client.loadCollection({
        collection_name: key,
      });
      logger.log("Milvus", `Collection ${key} loaded successfully.`);
    }

    // Update cache
    collectionLoadStatus.set(key, { loaded: true, timestamp: Date.now() });
    return true;
  } catch (error) {
    logger.log("Milvus", `Error loading collection: ${error}`);
    collectionLoadStatus.set(key, { loaded: false, timestamp: Date.now() });
    return false;
  }
}

async function scheduleVectorInsertion(collectionType, userId, vector) {
  const key = `${collectionType}_${userId}`;

  if (!pendingVectors.has(key)) {
    pendingVectors.set(key, []);

    // Schedule processing
    setTimeout(() => processVectorBatch(collectionType, userId), MAX_WAIT_MS);
  }

  const batch = pendingVectors.get(key);
  batch.push(vector);

  // If batch is full, process immediately
  if (batch.length >= MAX_BATCH_SIZE) {
    processVectorBatch(collectionType, userId);
  }
}

async function processVectorBatch(collectionType, userId) {
  const key = `${collectionType}_${userId}`;
  if (!pendingVectors.has(key)) return;

  const vectors = pendingVectors.get(key);
  pendingVectors.delete(key);

  if (vectors.length === 0) return;

  try {
    // Perform batch insertion
    await client.insert({
      collection_name: `${await retrieveConfigValue(`milvus.collections.${collectionType}`)}_${userId}`,
      fields_data: vectors,
    });

    logger.log(
      "Milvus",
      `Batch inserted ${vectors.length} vectors into ${collectionType}_${userId}`
    );
  } catch (error) {
    logger.log("Milvus", `Error batch inserting vectors: ${error}`);
    // Implement retry logic here
  }
}

async function getOptimizedSearchParams(
  collectionName,
  userId,
  queryEmbedding,
  limit,
  textParam,
  options = {}
) {
  // Get collection info to determine appropriate parameters
  const collStats = await client.getCollectionStatistics({
    collection_name: `${collectionName}_${userId}`,
  });

  const rowCount = parseInt(collStats.stats.row_count);

  // Default parameters
  let nprobe = 16; // Starting with a more reasonable default
  let consistencyLevel = ConsistencyLevelEnum.Session; // Less strict for most searches

  // Adjust nprobe based on collection size
  if (rowCount < 1000) {
    nprobe = 8;
  } else if (rowCount > 100000) {
    nprobe = 32;
  }

  // Override with passed options
  if (options.requireStrongConsistency) {
    consistencyLevel = ConsistencyLevelEnum.Strong;
  }

  // For critical searches, use stronger consistency
  if (options.criticalSearch) {
    nprobe = Math.min(rowCount / 10, 64); // More thorough search but capped
    consistencyLevel = ConsistencyLevelEnum.Strong;
  }

  return {
    collection_name: `${collectionName}_${userId}`,
    data: queryEmbedding,
    topk: limit,
    metric_type: MetricType.JACCARD,
    output_fields: textParam instanceof Array ? textParam : [textParam],
    vector_type: DataType.BinaryVector,
    search_params: buildSearchParams({
      nprobe: nprobe,
      limit: limit,
    }),
    consistency_level: consistencyLevel,
  };
}

const intelligenceSchema = async (userId) => {
  return {
    collection_name: `${await retrieveConfigValue("milvus.collections.intelligence")}_${userId}`,
    consistency_level: ConsistencyLevelEnum.Strong,
    schema: [
      {
        name: "embedding",
        data_type: DataType.BinaryVector,
        dim: 1024,
        is_primary_key: false,
      },
      {
        name: "relation",
        data_type: DataType.VarChar,
        max_length: 512,
        is_primary_key: true,
        auto_id: true,
      },
      {
        name: "text_content",
        data_type: DataType.VarChar,
        max_length: 8192,
        is_primary_key: false,
      },
    ],
    index_params: [
      {
        field_name: "embedding",
        index_name: "emb_doc_lookup",
        index_type: IndexType.BIN_IVF_FLAT,
        metric_type: MetricType.JACCARD,
        params: { nlist: 2048 },
      },
    ],
  };
};

const chatSchema = async (userId) => {
  return {
    collection_name: `${await retrieveConfigValue("milvus.collections.chat")}_${userId}`,
    consistency_level: ConsistencyLevelEnum.Strong,
    schema: [
      {
        name: "embedding",
        data_type: DataType.BinaryVector,
        dim: 1024,
        is_primary_key: false,
        auto_id: false,
      },
      {
        name: "username",
        data_type: DataType.VarChar,
        max_length: 256,
        is_primary_key: true,
        auto_id: false,
      },
      {
        name: "text_content",
        data_type: DataType.VarChar,
        max_length: 4096,
        is_primary_key: false,
        auto_id: false,
      },
      {
        name: "raw_msg",
        data_type: DataType.VarChar,
        max_length: 1024,
        is_primary_key: false,
        auto_id: false,
      },
      {
        name: "ai_message",
        data_type: DataType.VarChar,
        max_length: 1024,
        is_primary_key: false,
        auto_id: false,
      },
      {
        name: "time_stamp",
        data_type: DataType.Int64,
        is_primary_key: false,
        auto_id: false,
      },
    ],
    index_params: [
      {
        field_name: "embedding",
        index_name: "emb_chat_lookup",
        index_type: IndexType.BIN_IVF_FLAT,
        metric_type: MetricType.JACCARD,
        params: { nlist: 2048 },
      },
      {
        field_name: "time_stamp",
        index_name: "idx_time_stamp",
        index_type: IndexType.RANGE,
      },
    ],
  };
};

const voiceSchema = async (userId) => {
  return {
    collection_name: `${await retrieveConfigValue("milvus.collections.voice")}_${userId}`,
    consistency_level: ConsistencyLevelEnum.Strong,
    schema: [
      {
        name: "embedding",
        data_type: DataType.BinaryVector,
        dim: 1024,
        is_primary_key: false,
        auto_id: false,
      },
      {
        name: "username",
        data_type: DataType.VarChar,
        max_length: 32,
        is_primary_key: false,
        auto_id: false,
      },
      {
        name: "user_message",
        data_type: DataType.VarChar,
        max_length: 256,
        is_primary_key: true,
        auto_id: false,
      },
      {
        name: "ai_resp",
        data_type: DataType.VarChar,
        max_length: 4096,
        is_primary_key: false,
        auto_id: false,
      },
      {
        name: "summary",
        data_type: DataType.VarChar,
        max_length: 4096,
        is_primary_key: false,
        auto_id: false,
      },
      {
        name: "date_time",
        data_type: DataType.VarChar,
        max_length: 1024,
        is_primary_key: false,
        auto_id: false,
      },
    ],
    index_params: [
      {
        field_name: "embedding",
        index_name: "emb_voice_lookup",
        index_type: IndexType.BIN_IVF_FLAT,
        metric_type: MetricType.JACCARD,
        params: { nlist: 2048 },
      },
    ],
  };
};

const userSchema = async (userId) => {
  return {
    collection_name: `${await retrieveConfigValue("milvus.collections.user")}_${userId}`,
    consistency_level: ConsistencyLevelEnum.Strong,
    schema: [
      {
        name: "embedding",
        data_type: DataType.BinaryVector,
        dim: 1024,
        is_primary_key: false,
        auto_id: false,
      },
      {
        name: "username",
        data_type: DataType.VarChar,
        max_length: 256,
        is_primary_key: true,
        auto_id: false,
      },
      {
        name: "gender",
        data_type: DataType.VarChar,
        max_length: 256,
        is_primary_key: false,
        auto_id: false,
      },
      {
        name: "age",
        data_type: DataType.Int64,
        is_primary_key: false,
        auto_id: false,
      },
      {
        name: "residence",
        data_type: DataType.VarChar,
        max_length: 256,
        is_primary_key: false,
        auto_id: false,
      },
    ],
    index_params: [
      {
        field_name: "embedding",
        index_name: "emb_user_lookup",
        index_type: IndexType.BIN_IVF_FLAT,
        metric_type: MetricType.JACCARD,
        params: { nlist: 2048 },
      },
    ],
  };
};

const milvusDatabaseUrl = await retrieveConfigValue("milvus.endpoint");
const client = new MilvusClient({
  address: milvusDatabaseUrl,
});

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Returns the appropriate schema for a given collection and user ID.
 * @param {string} collection - The name of the collection.
 * @param {string} userId - The user ID.
 * @returns {object} - The schema for the specified collection.
 */
async function returnCollectionSchema(collection, userId) {
  switch (collection) {
    case "users":
      return userSchema(userId);
    case "intelligence":
      return intelligenceSchema(userId);
    case "twitch_chat":
      return chatSchema(userId);
    case "vocal":
      return voiceSchema(userId);
    default:
      logger.log("Milvus", `No schema defined for collection ${collection}`);
      return null; // Return null to indicate no schema found
  }
}

/**
 * Creates a collection in Milvus.
 * @param {string} collection - The name of the collection to create.
 * @param {string} userId - The user ID.
 * @returns {Promise<void>}
 */
/**
 * Creates a collection in Milvus if it doesn't exist.
 * @param {string} collection - The name of the collection to create.
 * @param {string} userId - The user ID.
 * @returns {Promise<void>}
 */
async function createCollection(collection, userId) {
  try {
    const schema = await returnCollectionSchema(collection, userId);
    if (!schema) {
      logger.log(
        "Milvus",
        `Error: No schema found for collection ${collection}.`
      );
      return; // Exit if no schema is found
    }

    // Check if the collection already exists
    const exists = await client.hasCollection({
      collection_name: `${collection}_${userId}`,
    });

    if (!exists.value) {
      const response = await client.createCollection(schema);
      if (response.error_code === "Success") {
        logger.log(
          "Milvus",
          `Collection '${collection}_${userId}' created successfully.`
        );
      } else {
        logger.log(
          "Milvus",
          `Failed to create collection '${collection}_${userId}'. Reason: ${response.reason}`
        );
      }
    } else {
      logger.log(
        "Milvus",
        `Collection '${collection}_${userId}' already exists.`
      );
    }
  } catch (error) {
    logger.log("Milvus", `Error in createCollection: ${error}`);
  }
}

/**
 * Retrieves the schema of a collection in Milvus.
 * @param {string} collection - The name of the collection.
 * @param {string} userId - The user ID.
 * @returns {Promise<object>} - The schema of the collection.
 */
async function getCollectionSchema(collection, userId) {
  try {
    const schemaResponse = await client.describeCollection({
      collection_name: `${collection}_${userId}`,
    });
    return schemaResponse.schema;
  } catch (error) {
    logger.log("Milvus", `Error fetching schema: ${error}`);
  }
}

/**
 * Loads a collection in Milvus if it's not already loaded.
 * @param {string} collectionName - The name of the collection.
 * @param {string} userId - The user ID.
 * @returns {Promise<boolean>} - True if the collection is loaded or already exists, false otherwise.
 */
async function loadCollectionIfNeeded(collectionName, userId) {
  try {
    const collectionStatus = await client.getLoadState({
      collection_name: `${collectionName}_${userId}`,
    });
    if (collectionStatus.state === LoadState.LoadStateNotExist) {
      logger.log(
        "Milvus",
        `Collection ${collectionName}_${userId} does not exist`
      );
      return false;
    } else if (collectionStatus.state === LoadState.LoadStateNotLoad) {
      await client.loadCollection({
        collection_name: `${collectionName}_${userId}`,
      });
      logger.log(
        "Milvus",
        `Collection ${collectionName}_${userId} loaded successfully.`
      );
      return true;
    } else {
      return true;
    }
  } catch (error) {
    logger.log("Milvus", `Error loading collection: ${error}`);
  }
}

export function validateEmbeddingDimension(embedding, expectedDim) {
  const requiredBytes = expectedDim / 8; // assuming embedding is a Buffer of bytes
  if (embedding.length !== requiredBytes) {
    throw new Error(
      `Dimension mismatch: expected ${expectedDim} bits (${requiredBytes} bytes), but got ${embedding.length} bytes.`
    );
  }
}

export async function axiosRequestWithRetry(
  config,
  attempts = 3,
  initialDelay = 1000
) {
  let delay = initialDelay;
  for (let i = 0; i < attempts; i++) {
    try {
      return await axios(config);
    } catch (error) {
      if (i === attempts - 1) {
      }
      await new Promise((resolve) => setTimeout(resolve, delay));
      delay *= 2; // Exponential backoff
    }
  }
}

export async function getMessageEmbedding(message) {
  const embeddingData = {
    input: Array.isArray(message) ? message : [message],
    model: await retrieveConfigValue("models.embedding.model"),
  };
  try {
    const config = {
      method: "post",
      url: `${await retrieveConfigValue("models.embedding.endpoint")}/embeddings`,
      data: embeddingData,
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${await retrieveConfigValue("models.embedding.apiKey")}`,
      },
      timeout: 30000,
    };
    const response = await axiosRequestWithRetry(config, 3, 1000);
    const embeddingResp = response.data.data;
    return embeddingResp.length > 1
      ? embeddingResp.map((item) => item.embedding)
      : embeddingResp[0].embedding;
  } catch (error) {
    logger.log("System", `Error generating embedding: ${error}`);
  }
}

async function searchDocumentsInMilvus(
  queryEmbedding,
  collectionName,
  textParam,
  limit,
  userId,
  options = {}
) {
  if (!queryEmbedding || queryEmbedding.length === 0) {
    logger.log("Milvus", "Query embedding is empty.");
    return { results: [] };
  }

  try {
    // Ensure collection is loaded using our new cache system
    const isLoaded = await ensureCollectionLoaded(collectionName, userId);
    if (!isLoaded) {
      logger.log(
        "Milvus",
        `Collection ${collectionName}_${userId} not available for search.`
      );
      return { results: [] };
    }

    // Get optimized search parameters
    const startTime = performance.now();
    const searchParams = await getOptimizedSearchParams(
      collectionName,
      userId,
      queryEmbedding,
      limit,
      textParam,
      options
    );

    // Execute search with retry capability
    const searchResponse = await retryMilvusOperation(
      () => client.search(searchParams),
      options.maxRetries || 3
    );

    const timeElapsed = (performance.now() - startTime) / 1000;
    logger.log(
      "DB Metrics",
      `Vector search took ${timeElapsed.toFixed(3)} seconds for query in collection "${collectionName}".`
    );

    return searchResponse;
  } catch (error) {
    logger.log("Milvus", `Error searching in Milvus: ${error}`);
    return { results: [] };
  }
}

/**
 * Finds relevant chats in a Milvus collection based on a message.
 * @param {string} message - The message to search for.
 * @param {string} user - The username.
 * @param {string} userId - The user ID.
 * @param {number} topK - The number of top results to return.
 * @returns {Promise<object[]|boolean>} - An array of relevant chat results or false if the collection doesn't exist.
 */
async function findRelevantChats(message, user, userId, topK = 10) {
  // Check cache for identical queries
  const cacheKey = `chats_${userId}_${message}`;
  const cachedResult = getCachedResult(cacheKey);
  if (cachedResult) return cachedResult;

  try {
    // Import MongoDB search function
    const { findRelevantChatContext } = await import("./mongodb-client.js");

    // Use the hybrid search function
    const results = await findRelevantChatContext(userId, message, user, topK, {
      useVectors: true,
      simpleTextSearch: true,
    });

    // Cache the results
    setCachedResult(cacheKey, results, 30000); // 30 second TTL
    return results;
  } catch (error) {
    logger.log("Chat", `Error in findRelevantChats: ${error.message}`);

    try {
      // Verify collection exists (using our optimized collection check)
      const created = await checkAndCreateCollection(
        await retrieveConfigValue("milvus.collections.chat"),
        userId
      );
      if (!created) {
        return false;
      }

      // Get embedding
      const messageEmbedding = await getMessageEmbedding(message);
      const binaryEmbedding = Buffer.from(messageEmbedding);

      // Get collection schema to validate embedding dimensions
      const collectionSchema = await getCollectionSchema(
        await retrieveConfigValue("milvus.collections.chat"),
        userId
      );

      const embeddingField = collectionSchema.fields.find(
        (field) => field.name === "embedding"
      );
      const expectedDim = parseInt(
        embeddingField?.type_params.find((param) => param.key === "dim")?.value
      );
      validateEmbeddingDimension(binaryEmbedding, expectedDim);

      // Use optimized search
      const chatSearchResponse = await searchDocumentsInMilvus(
        binaryEmbedding,
        await retrieveConfigValue("milvus.collections.chat"),
        ["text_content", "username", "raw_msg", "ai_message"], // Get more fields in one query
        topK,
        userId,
        { requireStrongConsistency: false } // Use session consistency for chat queries
      );

      // Cache the results
      setCachedResult(cacheKey, chatSearchResponse.results, 30000); // 30 second TTL
      return chatSearchResponse.results;
    } catch (error) {
      logger.log("Milvus", `Error in Milvus fallback: ${error.message}`);
      return []; // Return empty array on error
    }
  }
}

async function returnRecentChats(
  userId,
  fromConsole = false,
  allChats = false
) {
  try {
    const userObj = await returnAuthObject(userId);

    // Import MongoDB functions
    const { getRecentChats } = await import("./mongodb-client.js");

    const startTime = performance.now();

    // Get chat limit from user settings
    const limit = allChats ? 1000 : userObj.max_chats || 25;

    // Get messages from MongoDB
    const messages = await getRecentChats(userId, limit);

    // Sort messages by timestamp
    const sortedResults = messages.sort((a, b) => a.time_stamp - b.time_stamp);

    // Format results as before
    const formattedResults = sortedResults
      .map(
        (item) =>
          `- ${item.username} sent the following message in ${userObj.user_name}'s Twitch channel: ${item.raw_msg}`
      )
      .join("\n");

    const timeElapsed = (performance.now() - startTime) / 1000;
    logger.log(
      "DB Metrics",
      `Recent chats took ${timeElapsed.toFixed(3)} seconds for query.`
    );

    if (fromConsole) {
      return { chatList: formattedResults, executionTime: timeElapsed };
    } else {
      return formattedResults;
    }
  } catch (error) {
    logger.log("MongoDB", `Error in findRecentChats: ${error.message}`);
    try {
      const startTime = performance.now();
      let queryResult;
      if (allChats) {
        queryResult = await client.query({
          collection_name: collection,
          output_fields: ["raw_msg", "username", "time_stamp"],
          limit: 1001,
          consistency_level: "Strong",
        });
      } else {
        queryResult = await client.query({
          collection_name: collection,
          output_fields: ["raw_msg", "username", "time_stamp"],
          limit: userObj.max_chats,
          consistency_level: "Strong",
        });
      }

      const sortedResults = queryResult.data.sort(
        (a, b) => a.time_stamp - b.time_stamp
      );
      const formattedResults = sortedResults
        .map(
          (item) =>
            `- ${item.username} sent the following message in ${userObj.user_name}'s Twitch channel: ${item.raw_msg}`
        )
        .join("\n");
      const timeElapsed = (performance.now() - startTime) / 1000;
      logger.log(
        "DB Metrics",
        `Recent chats took ${timeElapsed.toFixed(3)} seconds for query.`
      );
      if (fromConsole) {
        return { chatList: formattedResults, executionTime: timeElapsed };
      } else {
        return formattedResults;
      }
    } catch (error) {
      logger.log("Milvus", `Error in findRecentChats: ${error}`);
      return [];
    }
  }
}

/**
 * Finds relevant documents in a Milvus collection based on a message.
 * @param {string} message - The message to search for.
 * @param {string} userId - The user ID.
 * @param {number} topK - The number of top results to return.
 * @returns {Promise<object[]|boolean>} - An array of relevant document results or false if the collection doesn't exist.
 */
async function findRelevantDocuments(message, userId, topK = 10) {
  // Check cache first
  const cacheKey = `docs_${userId}_${message}`;
  const cachedResult = getCachedResult(cacheKey);
  if (cachedResult) return cachedResult;

  try {
    // Ensure collection exists and is loaded
    const collExists = await checkAndCreateCollection(
      await retrieveConfigValue("milvus.collections.intelligence"),
      userId
    );

    if (!collExists) {
      return [];
    }

    // Get and validate embedding
    const messageEmbedding = await getMessageEmbedding(message);
    const binaryEmbedding = Buffer.from(messageEmbedding);
    const collectionSchema = await getCollectionSchema(
      await retrieveConfigValue("milvus.collections.intelligence"),
      userId
    );

    const embeddingField = collectionSchema.fields.find(
      (field) => field.name === "embedding"
    );
    const expectedDim = parseInt(
      embeddingField?.type_params.find((param) => param.key === "dim")?.value
    );
    validateEmbeddingDimension(binaryEmbedding, expectedDim);

    // Use optimized search with higher nprobe for documents (more accurate)
    const searchResponse = await searchDocumentsInMilvus(
      binaryEmbedding,
      await retrieveConfigValue("milvus.collections.intelligence"),
      ["text_content", "relation"],
      topK,
      userId,
      {
        criticalSearch: true, // Higher importance search
        maxRetries: 3,
      }
    );

    // Cache results for longer period
    setCachedResult(cacheKey, searchResponse.results, 300000); // 5 minute TTL for documents
    return searchResponse.results;
  } catch (error) {
    logger.log("Milvus", `Error in findRelevantDocuments: ${error}`);
    return [];
  }
}

/**
 * Finds relevant voice interactions in a Milvus collection based on a message.
 * @param {string} message - The message to search for.
 * @param {string} userId - The user ID.
 * @param {number} topK - The number of top results to return.
 * @returns {Promise<object[]|boolean>} - An array of relevant voice interaction results or false if the collection doesn't exist.
 */
async function findRelevantVoiceInMilvus(message, userId, topK = 5) {
  // Check cache
  const cacheKey = `voice_${userId}_${message}`;
  const cachedResult = getCachedResult(cacheKey);
  if (cachedResult) return cachedResult;

  try {
    // Ensure collection exists and is loaded
    const created = await checkAndCreateCollection(
      await retrieveConfigValue("milvus.collections.voice"),
      userId
    );

    if (!created) {
      return [];
    }

    // Get and validate embedding
    const messageEmbedding = await getMessageEmbedding(message);
    const binaryEmbedding = Buffer.from(messageEmbedding);
    const collectionSchema = await getCollectionSchema(
      await retrieveConfigValue("milvus.collections.voice"),
      userId
    );

    const embeddingField = collectionSchema.fields.find(
      (field) => field.name === "embedding"
    );
    const expectedDim = parseInt(
      embeddingField?.type_params.find((param) => param.key === "dim")?.value
    );
    validateEmbeddingDimension(binaryEmbedding, expectedDim);

    // Use optimized search
    const voiceResponse = await searchDocumentsInMilvus(
      binaryEmbedding,
      await retrieveConfigValue("milvus.collections.voice"),
      ["summary", "username", "user_message", "ai_resp", "date_time"],
      topK,
      userId,
      { requireStrongConsistency: false }
    );

    // Cache results
    setCachedResult(cacheKey, voiceResponse.results, 60000); // 1 minute TTL
    return voiceResponse.results;
  } catch (error) {
    logger.log("Milvus", `Error in findRelevantVoiceInMilvus: ${error}`);
    return [];
  }
}

/**
 * Inserts or updates user information in the user_info collection using upsert.
 *
 * @param {string} userId - The ID of the user associated with the collection.
 * @param {object} userInfo - The user information object.
 * @returns {Promise<void>}
 */
async function upsertUserInfo(userId, userInfo) {
  try {
    const collectionName = `${await retrieveConfigValue("milvus.collections.user")}_${userId}`;
    const userEmbedding = await getMessageEmbedding(userInfo.username);

    const fieldsData = [
      {
        embedding: userEmbedding,
        username: userInfo.username,
        gender: userInfo.gender || "",
        age: userInfo.age || 0,
        residence: userInfo.residence || "",
      },
    ];

    await client.upsert({
      collection_name: collectionName,
      fields_data: fieldsData,
    });

    logger.log(
      "Milvus",
      `User info for ${userInfo.username} upserted in collection ${collectionName}.`
    );
  } catch (error) {
    logger.log("Milvus", `Error upserting user info: ${error}`);
  }
}

async function findUserInMilvus(username, userId) {
  try {
    const collectionName = `${await retrieveConfigValue("milvus.collections.user")}_${userId}`; // Add _${userId} to the collection name

    // Check if the collection exists and load it if necessary
    const collectionExists = await client.hasCollection({
      collection_name: collectionName,
    });

    if (!collectionExists.value) {
      logger.log("Milvus", `Collection ${collectionName} does not exist.`);
      return null;
    } else {
      const isLoaded = await loadCollectionIfNeeded(collectionName, userId);
      if (!isLoaded) {
        logger.log("Milvus", `Collection ${collectionName} is not loaded.`);
        return null;
      }
    }

    // Generate embedding for the username
    const usernameEmbedding = await getMessageEmbedding(username);
    const binaryEmbedding = Buffer.from(usernameEmbedding);

    // Perform the search
    const searchParams = {
      collection_name: collectionName,
      data: binaryEmbedding,
      search_params: buildSearchParams({
        anns_field: "embedding",
        topk: 1,
        metric_type: MetricType.JACCARD,
        params: JSON.stringify({ nprobe: 128 }),
      }),
      vector_type: DataType.BinaryVector,
      output_fields: ["gender", "age", "residence"],
    };

    const searchResponse = await client.search(searchParams);

    if (searchResponse.results.length > 0) {
      const user = searchResponse.results[0];
      return user;
    } else {
      logger.log(
        "Milvus",
        `User ${username} not found in collection ${collectionName}.`
      );
      return null;
    }
  } catch (error) {
    logger.log("Milvus", `Error searching for user: ${error}`);
    return null;
  }
}

/**
 * Upserts intelligence vectors into a Milvus collection.
 *
 * @param {object[]} data - An array of objects, where each object represents a document to upsert.
 * @param {string} collection - The name of the collection.
 * @param {string} userId - The user ID.
 * @returns {Promise<void>}
 */
async function upsertIntelligenceToMilvus(data, collection, userId) {
  if (!data || data.length === 0) {
    logger.log("Milvus", "No data to upsert.");
    return;
  }

  try {
    const upsertResponse = await client.upsert({
      collection_name: `${collection}_${userId}`,
      fields_data: data,
    });

    if (upsertResponse.status.error_code === "Success") {
      logger.log(
        "Milvus",
        `Upserted ${data.length} items into ${collection}_${userId}`
      );
      return true;
    } else {
      logger.log(
        "Milvus",
        `Failed to upsert data into ${collection}_${userId}. Reason: ${upsertResponse.status.reason}`
      );
      return false;
    }
  } catch (error) {
    logger.log("Milvus", `Error upserting data: ${error}`);
  }
}

async function deleteVectorsFromMilvus(relations, collection, userId) {
  try {
    for (const relation of relations) {
      // Assuming 'relation' is the name of the primary key field
      const deleteResponse = await client.deleteEntities({
        collection_name: `${collection}_${userId}`,
        expr: `relation in ['${relation}']`,
      });

      if (deleteResponse.status.error_code === "Success") {
        logger.log(
          "Milvus",
          `Deleted vector with relation '${relation}' from ${collection}_${userId}`
        );
      } else {
        logger.log(
          "Milvus",
          `Failed to delete vector with relation '${relation}' from ${collection}_${userId}. Reason: ${deleteResponse.status.reason}`
        );
      }
    }
  } catch (error) {
    logger.log("Milvus", `Error deleting vectors: ${error}`);
  }
}

/**
 * Inserts or updates vectors related to augmented intelligence into a Milvus collection.
 * @param {number[]} vectors - The vector embeddings to insert or update.
 * @param {string} content - The content associated with the vectors.
 * @param {string} relational - A string describing the relationship or category of the content.
 * @param {string} userId - The identifier of the user to whom the data belongs.
 * @returns {Promise<boolean>} - True if the operation was successful, otherwise false.
 */
async function insertAugmentVectorsToMilvus(
  vectors,
  content,
  relational,
  userId
) {
  try {
    const collectionName = `${await retrieveConfigValue("milvus.collections.intelligence")}_${userId}`;

    const exists = await client.hasCollection({
      collection_name: collectionName,
    });
    if (!exists.value) {
      logger.log("Milvus", `Collection ${collectionName} does not exist.`);
      const created = await checkAndCreateCollection(
        await retrieveConfigValue("milvus.collections.intelligence"),
        userId
      );
      if (!created) {
        logger.log("Milvus", `Failed to create collection ${collectionName}.`);
        return false;
      }
    }

    const isLoaded = await loadCollectionIfNeeded(
      await retrieveConfigValue("milvus.collections.intelligence"),
      userId
    );
    if (!isLoaded) {
      logger.log("Milvus", `Failed to load collection ${collectionName}.`);
      return false;
    }

    // Prepare the data for insertion
    const fieldsData = [
      {
        embedding: vectors,
        relation: relational,
        text_content: content,
      },
    ];

    const insertResponse = await client.insert({
      collection_name: collectionName,
      fields_data: fieldsData,
    });

    if (insertResponse.status.error_code === "Success") {
      logger.log(
        "Augment",
        `Inserted/updated data in collection ${collectionName}`
      );
      return true;
    } else {
      logger.log(
        "Augment",
        `Failed to insert/update data in collection ${collectionName}. Reason: ${insertResponse.status.reason}`
      );
      return false;
    }
  } catch (error) {
    logger.log("Augment", `Error in insertAugmentVectorsToMilvus: ${error}`);
    return false;
  }
}

/**
 * Retrieves web context, summarizes it, and stores it in Milvus.
 * @param {object[]} urls - Array of URL objects from search
 * @param {string} query - The search query
 * @param {string} subject - The subject of the search
 * @param {string} userId - The user ID
 * @returns {Promise<string|object>} - The summary string or error object
 */
export async function retrieveWebContext(urls, query, subject, userId) {
  if (!urls || urls.length === 0) {
    return createRagError(
      "context-retrieval",
      "No URLs provided for context extraction",
      { query: query }
    );
  }

  try {
    logger.log(
      "LLM",
      `Starting optimized web context retrieval for '${query}'`
    );

    // Step 1: Scrape each URL in parallel.
    const scrapePromises = urls.map((urlObj) =>
      pullFromWebScraper([urlObj], subject)
    );
    const pageContentsArray = await Promise.all(scrapePromises);
    const validContents = pageContentsArray.filter(
      (content) =>
        content && typeof content === "string" && content.trim() !== ""
    );

    if (validContents.length === 0) {
      return createRagError(
        "content-scraping",
        "No valid content found from scraped URLs",
        { urlCount: urls.length }
      );
    }

    // Step 2: Summarize each page individually.
    const summaryPromises = validContents.map((content) =>
      summarizePage(content, subject)
    );
    const individualSummaries = await Promise.all(summaryPromises);

    // Filter out failed summaries
    const validSummaries = individualSummaries.filter(
      (summary) =>
        summary &&
        !summary.error &&
        summary.vectorString &&
        summary.summaryContents
    );

    if (validSummaries.length === 0) {
      return createRagError(
        "summarization",
        "Failed to generate valid summaries from content",
        { contentCount: validContents.length }
      );
    }

    // Step 3: Generate a final combined summary.
    const finalSummary = await finalCombinedSummary(validSummaries, subject);

    // Check if we got an error object back
    if (finalSummary && finalSummary.error) {
      return finalSummary; // Already a properly formatted error
    }

    if (
      !finalSummary ||
      !finalSummary.vectorString ||
      !finalSummary.summaryContents
    ) {
      return createRagError(
        "final-summary",
        "Failed to generate final combined summary",
        { summaryCount: validSummaries.length }
      );
    }

    // Step 4: Upsert the final summary into the vector DB.
    const finalText = `### Final Summary for ${subject}:\n${finalSummary.summaryContents}`;
    const embeddingArray = await getMessageEmbedding(finalSummary.vectorString);

    if (!embeddingArray) {
      return createRagError(
        "embedding-generation",
        "Failed to generate embedding for summary",
        { vectorString: finalSummary.vectorString.substring(0, 100) + "..." }
      );
    }

    const upsertData = [
      {
        relation: finalSummary.vectorString.slice(0, 512),
        text_content: finalText,
        embedding: embeddingArray,
      },
    ];

    const upsertResult = await upsertIntelligenceToMilvus(
      upsertData,
      await retrieveConfigValue("milvus.collections.intelligence"),
      userId
    );

    if (!upsertResult) {
      return createRagError(
        "vector-storage",
        "Failed to store summary in vector database",
        { subject: subject }
      );
    }

    logger.log("Augment", `Final combined summary stored for '${subject}'`);
    return finalText;
  } catch (error) {
    logger.log(
      "Augment",
      `Error in web context retrieval for '${query}': ${error.message}`,
      "err"
    );
    return createRagError("web-context", error.message, {
      query: query,
      subject: subject,
    });
  }
}

async function summarizePage(pageContent, subject) {
  try {
    // Generate a summary request for the individual page
    const instruct = await SummaryRequestBody.create(
      `Please summarize the following content about "${subject}" in a way that provides both a concise vector-optimized sentence and a detailed summary.`,
      await retrieveConfigValue("models.summary.model"),
      pageContent
    );

    const chatTask = await sendToolCompletionRequest(
      instruct,
      await retrieveConfigValue("models.summary")
    );

    // Handle the response based on its type
    if (!chatTask) {
      logger.log("Augment", "Empty response from summary request");
      return null;
    }

    if (chatTask.error) {
      logger.log("Augment", `Error in summary request: ${chatTask.error}`);
      return { error: chatTask.error };
    }

    // If response is already an object (from the guided format), use it directly
    if (typeof chatTask.response === "object" && chatTask.response !== null) {
      return chatTask.response;
    }

    // Otherwise try parsing it as JSON
    try {
      return JSON.parse(chatTask.response);
    } catch (parseError) {
      logger.log(
        "Augment",
        `Failed to parse summary response as JSON: ${parseError.message}`
      );
      return {
        error: "JSON parsing failed",
        details: parseError.message,
      };
    }
  } catch (error) {
    logger.log("Augment", `Error in summarizePage: ${error.message}`);
    return { error: error.message };
  }
}

async function finalCombinedSummary(summaries, subject) {
  try {
    // Combine the individual summaries into one text block
    const combinedText = summaries
      .map(
        (s) => `Vector hint: ${s.vectorString}\nDetailed: ${s.summaryContents}`
      )
      .join("\n\n");

    // Create a final summary prompt that instructs the model to produce a unified summary
    const finalPrompt = `You are provided with multiple summaries for content about "${subject}". Please consolidate these into a final summary. Your output must be in JSON format with two properties: "vectorString" (a single concise sentence optimized for vector search) and "summaryContents" (the complete final summary). Here are the individual summaries:\n\n${combinedText}`;

    const instruct = await SummaryRequestBody.create(
      finalPrompt,
      await retrieveConfigValue("models.summary.model"),
      combinedText
    );

    const chatTask = await sendToolCompletionRequest(
      instruct,
      await retrieveConfigValue("models.summary")
    );

    // Handle the response based on its type
    if (!chatTask) {
      logger.log("Augment", "Empty response from final summary request");
      return createRagError(
        "summary-generation",
        "Empty response from summary tool"
      );
    }

    if (chatTask.error) {
      logger.log(
        "Augment",
        `Error in final summary request: ${chatTask.error}`
      );
      return createRagError("summary-generation", chatTask.error);
    }

    // If response is already an object (from the guided format), use it directly
    if (typeof chatTask.response === "object" && chatTask.response !== null) {
      // Validate that the object has the expected properties
      if (
        !chatTask.response.vectorString ||
        !chatTask.response.summaryContents
      ) {
        logger.log(
          "Augment",
          "Final summary response missing required properties"
        );
        return createRagError(
          "summary-format",
          "Summary response missing required properties",
          {
            response:
              JSON.stringify(chatTask.response).substring(0, 100) + "...",
          }
        );
      }
      return chatTask.response;
    }

    // Otherwise try parsing it as JSON
    try {
      const parsedResponse = JSON.parse(chatTask.response);
      // Validate parsed response
      if (!parsedResponse.vectorString || !parsedResponse.summaryContents) {
        logger.log(
          "Augment",
          "Parsed final summary response missing required properties"
        );
        return createRagError(
          "summary-format",
          "Parsed summary response missing required properties",
          { response: JSON.stringify(parsedResponse).substring(0, 100) + "..." }
        );
      }
      return parsedResponse;
    } catch (parseError) {
      logger.log(
        "Augment",
        `Failed to parse final summary response as JSON: ${parseError.message}`
      );
      return createRagError(
        "summary-parsing",
        "Failed to parse summary as JSON",
        {
          error: parseError.message,
          rawResponse: chatTask.response.substring(0, 100) + "...",
        }
      );
    }
  } catch (error) {
    logger.log("Augment", `Error in finalCombinedSummary: ${error.message}`);
    return createRagError("summary-execution", error.message, {
      stack: error.stack,
    });
  }
}

/**
 * Searches the Brave API for web results.
 * @param {string} query - The search query.
 * @param {string} freshness - The freshness parameter for the search.
 * @returns {Promise<object[]>} - An array of web results.
 */
async function searchBraveAPI(query, freshness) {
  try {
    const url = new URL("https://api.search.brave.com/res/v1/web/search");
    url.searchParams.set("q", query);
    url.searchParams.set("result_filter", "web");
    // Add Goggles ID if you have one or remove the line if not applicable
    // url.searchParams.set('goggles_id', 'your_goggles_id');
    url.searchParams.set("freshness", freshness);

    const httpsAgent = new https.Agent({
      keepAlive: true,
      rejectUnauthorized: true,
      timeout: 10000,
    });

    const response = await fetch(url.toString(), {
      method: "GET",
      agent: httpsAgent,
      headers: {
        "X-Subscription-Token": await retrieveConfigValue("brave.apiKey"),
        Accept: "application/json",
        "User-Agent": "curl/7.68.0", // You can change this to a custom user agent if needed
      },
    });

    const data = await response.json();
    if (data && data.web && Array.isArray(data.web.results)) {
      const chosenResults = data.web.results.slice(0, 4);
      let resultStuff = [];
      for await (const item of chosenResults) {
        const relevantItems = {
          url: item.url,
          title: item.title,
          source: item.meta_url.hostname,
        };
        resultStuff.push(relevantItems);
      }
      return resultStuff;
    } else {
      logger.log(
        "Brave Search",
        `No web results found from Brave for '${query}' using freshness '${freshness}'`,
        "err"
      );
      return [];
    }
  } catch (error) {
    console.error("Error:", error);
  }
}

/**
 * Searches SearXNG for web results
 * @param {string} query - The search query
 * @param {string} freshness - The freshness parameter
 * @returns {Promise<Array|object>} - Search results or error object
 */
export async function searchSearXNG(query, freshness) {
  try {
    const url = new URL("https://search.prolix.dev/search");
    url.searchParams.set("q", query);
    url.searchParams.set("safesearch", 0);
    url.searchParams.set("categories", "general");
    url.searchParams.set("engines", "google,bing");
    url.searchParams.set("format", "json");

    const response = await axios.get(url.toString());

    if (!response.data || !Array.isArray(response.data.results)) {
      return createRagError("search-api", "Invalid response from search API", {
        query: query,
        responseStatus: response.status,
      });
    }

    if (response.data.results.length === 0) {
      return createRagError("search-results", "No results found for query", {
        query: query,
        freshness: freshness,
      });
    }

    const chosenResults = response.data.results.slice(0, 4);
    let resultStuff = [];

    for await (const item of chosenResults) {
      const relevantItems = {
        url: item.url,
        title: item.title,
        source: item.parsed_url[1],
      };
      resultStuff.push(relevantItems);
    }

    return resultStuff;
  } catch (error) {
    logger.log("SearXNG Search", `Error searching: ${error.message}`);
    return createRagError("search-execution", error.message, { query: query });
  }
}

/**
 * Modifies the inferSearchParam function to use structured error objects
 * @param {string} query - The query to infer search parameters from
 * @param {string} userId - The user ID
 * @returns {Promise<object|{success:boolean, error?:object}>} - Search parameters or error object
 */
export async function inferSearchParam(query, userId) {
  try {
    const instruct = await queryPrompt(query, userId);

    const chatTask = await sendToolCompletionRequest(
      instruct,
      await retrieveConfigValue("models.query")
    );

    if (!chatTask || chatTask.error) {
      return createRagError(
        "query-generation",
        "Failed to generate search query",
        { originalError: chatTask?.error || "Unknown error" }
      );
    }

    // For tools using JSON response format, chatTask.response is already parsed
    const fullChat = chatTask.response;

    // Validate that we have a properly structured response
    if (!fullChat || typeof fullChat !== "object") {
      return createRagError(
        "query-parsing",
        "Invalid response structure from query builder",
        { responseType: typeof fullChat }
      );
    }

    if (fullChat.valid === false) {
      logger.log(
        "LLM",
        `Query builder opted out of search for this query. Reason: ${fullChat.reason}`
      );
      return {
        success: false,
        optedOut: true,
        reason: fullChat.reason,
      };
    } else {
      logger.log(
        "LLM",
        `Returned optimized search param: '${fullChat.searchTerm}'. Time to first token: ${chatTask.timeToFirstToken} seconds. Process speed: ${chatTask.tokensPerSecond}tps`
      );
      return {
        success: true,
        searchTerm: fullChat.searchTerm,
        subject: fullChat.subject,
        freshness: fullChat.freshness,
        vectorString: fullChat.vectorString,
      };
    }
  } catch (error) {
    logger.log("LLM", `Error inferring search parameter: ${error}`);
    return createRagError("query-inference", error.message, {
      stack: error.stack,
    });
  }
}

/**
 * Inserts voice interaction vectors into a Milvus collection.
 * @param {number[]} vectors - The vector embeddings for the voice interaction.
 * @param {string} summary - A summary of the voice interaction.
 * @param {string} message - The user's voice message.
 * @param {string} response - The AI's response to the voice message.
 * @param {string} user - The username associated with the voice interaction.
 * @param {string} date - The timestamp of the voice interaction.
 * @param {string} userId - The user ID.
 * @returns {Promise<boolean>} - True if the operation was successful, false otherwise.
 */
async function insertVoiceVectorsIntoMilvus(
  vectors,
  summary,
  message,
  response,
  user,
  date,
  userId
) {
  try {
    const collectionName = `${await retrieveConfigValue("milvus.collections.voice")}_${userId}`;

    const exists = await client.hasCollection({
      collection_name: collectionName,
    });
    if (!exists.value) {
      logger.log(
        "Milvus Voice",
        `Collection ${collectionName} does not exist.`
      );
      const created = await checkAndCreateCollection(
        await retrieveConfigValue("milvus.collections.voice"),
        userId
      );
      if (!created) {
        logger.log(
          "Milvus Voice",
          `Could not spawn collection '${collectionName}'`
        );
        return false;
      }
    }

    const isLoaded = await loadCollectionIfNeeded(
      await retrieveConfigValue("milvus.collections.voice"),
      userId
    );
    if (!isLoaded) {
      logger.log(
        "Milvus Voice",
        `Failed to load collection '${collectionName}'`
      );
      return false;
    }

    const fieldsData = [
      {
        embedding: vectors,
        username: user,
        user_message: message,
        ai_resp: response,
        summary: summary,
        date_time: date,
      },
    ];

    const insertResponse = await client.insert({
      collection_name: collectionName,
      fields_data: fieldsData,
    });

    if (insertResponse.status.error_code === "Success") {
      logger.log(
        "Milvus Voice",
        `Inserted voice interaction vectors into ${collectionName}`
      );
      return true;
    } else {
      logger.log(
        "Milvus Voice",
        `Failed to insert voice interaction vectors into ${collectionName}. Reason: ${insertResponse.status.reason}`
      );
      return false;
    }
  } catch (error) {
    logger.log(
      "Milvus Voice",
      `Error inserting voice interaction vectors: ${error}`
    );
    return false;
  }
}

/**
 * Reads files recursively from a directory and returns an array of file paths with a .json extension.
 * @param {string} directory - The directory to read files from.
 * @returns {Promise<string[]>} - An array of file paths.
 */
async function readFilesFromDirectory(directory) {
  const files = [];
  try {
    const items = await fs.readdir(directory, { withFileTypes: true });
    for (const item of items) {
      const fullPath = path.join(directory, item.name);
      if (item.isDirectory()) {
        const subDirFiles = await readFilesFromDirectory(fullPath);
        files.push(...subDirFiles);
      } else if (item.isFile() && path.extname(item.name) === ".json") {
        files.push(fullPath);
      }
    }
  } catch (error) {
    logger.log("File System", `Error reading directory ${directory}: ${error}`);
    return []; // Return an empty array to indicate failure
  }
  return files;
}

/**
 * Checks if a collection exists in Milvus, and creates it if it doesn't.
 * @param {string} collection - The name of the collection to check.
 * @param {string} userId - The user ID.
 * @returns {Promise<boolean>} - True if the collection exists or was created, false otherwise.
 */
async function checkAndCreateCollection(collection, userId) {
  try {
    const exists = await client.hasCollection({
      collection_name: `${collection}_${userId}`,
    });

    if (!exists.value) {
      logger.log(
        "Milvus",
        `Collection '${collection}_${userId}' does not exist. Attempting to create...`
      );
      await createCollection(collection, userId);
      logger.log(
        "Milvus",
        `Collection '${collection}_${userId}' creation attempted.`
      );
      return true; // Collection was created or creation was attempted
    } else {
      logger.log(
        "Milvus",
        `Collection '${collection}_${userId}' already exists.`
      );
      return true; // Collection already exists
    }
  } catch (error) {
    logger.log(
      "Milvus",
      `Error checking or creating collection '${collection}_${userId}': ${error}`
    );
    return false; // Indicate failure
  }
}

/**
 * Compares local and remote documents and determines necessary actions (insert, update, delete).
 *
 * @param {string} directory - The directory containing the local files.
 * @param {string} userId - The user ID.
 * @param {string} collectionName - The name of the Milvus collection.
 * @returns {Promise<object>} - An object containing arrays for missing, update, and remove actions.
 */
async function compareDocuments(directory, userId, collectionName) {
  // Get local file data
  const filenames = await readFilesFromDirectory(`${directory}/${userId}`);
  const localDocuments = (
    await Promise.all(
      filenames.map(async (filename) => {
        try {
          const content = await fs.readFile(filename, "utf8");
          return isValidJson(content) ? JSON.parse(content) : null;
        } catch (error) {
          logger.log(
            "File System",
            `Error reading or parsing file ${filename}: ${error}`
          );
          return null;
        }
      })
    )
  ).filter((content) => content !== null);

  // Get existing documents from Milvus
  const existingDocsResponse = await client.query({
    collection_name: collectionName,
    output_fields: ["relation", "text_content", "embedding"],
    limit: 10000,
  });

  logger.log(
    "Milvus",
    `Retrieved ${existingDocsResponse.data.length} existing documents from Milvus for user ${userId}.`
  );

  const existingDocsMap = new Map(
    existingDocsResponse.data.map((doc) => [doc.relation, doc])
  );

  // Prepare data for comparison
  const toInsert = [];
  const toUpdate = [];
  const toDelete = new Set(existingDocsMap.keys());

  for (const localDoc of localDocuments) {
    if (!localDoc || !localDoc.relation || localDoc.content === undefined) {
      logger.log(
        "Milvus",
        `Skipping invalid local document: ${JSON.stringify(localDoc)}`
      );
      continue;
    }
    const existingDoc = existingDocsMap.get(localDoc.relation);

    // Get the embedding for the relation
    const embedding = await getMessageEmbedding(localDoc.relation);
    const flattenedEmbedding = embedding.flat(); // Flatten the embedding here

    if (!existingDoc) {
      // New document: add to toInsert
      toInsert.push({
        relation: localDoc.relation,
        text_content: localDoc.content,
        embedding: flattenedEmbedding,
      });
    } else {
      // Existing document: remove from deletion set, check for content change
      toDelete.delete(localDoc.relation);

      // Log localDoc.content and existingDoc.text_content for debugging

      if (existingDoc.text_content !== localDoc.content) {
        // Modified document: add to toUpdate
        toUpdate.push({
          relation: localDoc.relation,
          text_content: localDoc.content,
          embedding: flattenedEmbedding,
        });
      } else {
      }
    }
  }

  // Format for output
  const result = {
    missing: toInsert,
    update: toUpdate,
    remove: Array.from(toDelete).map((relation) => ({ relation })),
  };

  return result;
}

/**
 * Processes files in a directory, comparing them with the corresponding Milvus collection,
 * and performs necessary operations like upsertion and deletions.
 *
 * @param {string} directory - The directory containing the files to process.
 * @param {string} userId - The user ID.
 * @returns {Promise<void>}
 */
async function processFiles(directory, userId) {
  try {
    const collectionName = `${await retrieveConfigValue("milvus.collections.intelligence")}_${userId}`;
    const collectionCreated = await checkAndCreateCollection(
      await retrieveConfigValue("milvus.collections.intelligence"),
      userId
    );
    if (!collectionCreated) {
      logger.log(
        "Milvus",
        `Failed to create or verify collection for ${userId}.`
      );
      return;
    }

    const loadedColl = await loadCollectionIfNeeded(
      await retrieveConfigValue("milvus.collections.intelligence"),
      userId
    );
    if (!loadedColl) {
      logger.log("Milvus", `Failed to load collection for ${userId}.`);
      return;
    }

    // Use the compareDocuments function to get the actions needed
    const actions = await compareDocuments(directory, userId, collectionName);

    // Perform upserts for new and updated documents
    if (actions.missing.length > 0) {
      await upsertIntelligenceToMilvus(
        [...actions.missing],
        await retrieveConfigValue("milvus.collections.intelligence"),
        userId
      );
      logger.log(
        "Milvus",
        `Adding ${actions.missing.length} documents to ${userId}'s intelligence collection...`
      );
    }

    if (actions.update.length > 0) {
      await upsertIntelligenceToMilvus(
        [...actions.update],
        await retrieveConfigValue("milvus.collections.intelligence"),
        userId
      );
      logger.log(
        "Milvus",
        `Updating ${actions.missing.length} documents from ${userId}'s intelligence collection...`
      );
    }

    // Perform deletions for removed documents
    if (actions.remove.length > 0) {
      await deleteVectorsFromMilvus(
        actions.remove.map((doc) => doc.relation),
        await retrieveConfigValue("milvus.collections.intelligence"),
        userId
      );
      logger.log(
        "Milvus",
        `Removing ${actions.missing.length} documents from ${userId}'s intelligence collection...`
      );
    }
  } catch (error) {
    logger.log("Milvus", `Error processing files for ${userId}: ${error}`);
  }
}

/**
 * Responds to a chat message from any source
 * @param {object} messageData - The message data
 * @param {string} userId - The user ID
 * @returns {Promise<object>} - The response
 */
export async function respondToChat(messageData, userId) {
  try {
    const { message, user } = messageData;

    // Format date for context
    const formattedDate = new Date().toLocaleString();

    // Use existing response function
    const response = await respondWithContext(message, user, userId);

    if (response && response.response) {
      // Add the conversation to vector storage
      const summaryString = `On ${formattedDate}, ${user} said: "${message}". You responded by saying: ${response.response}`;

      addChatMessageAsVector(
        summaryString,
        message,
        user,
        formattedDate,
        response.response,
        userId
      ).catch((err) => {
        logger.log("API", "Error saving chat message vector:", err);
      });

      return {
        success: true,
        text: response.response,
        thoughtProcess: response.thoughtProcess || null,
      };
    }

    return { success: false, error: "No response generated" };
  } catch (error) {
    logger.log("AI", `Error responding to chat: ${error.message}`);
    return { success: false, error: error.message };
  }
}

/**
 * Responds to a message with context retrieved from Milvus.
 * @param {string} message - The message to respond to.
 * @param {string} username - The username of the sender.
 * @param {string} userID - The user ID.
 * @returns {Promise<string>} - The response string.
 */
async function respondWithContext(message, username, userID) {
  try {
    // Check if we already have cached response for this exact message
    const responseCacheKey = `response_${userID}_${message}_${username}`;
    const cachedResponse = getCachedResult(responseCacheKey);
    if (cachedResponse) {
      logger.log(
        "System",
        "Using cached response from previous identical query"
      );
      return cachedResponse;
    }

    // Perform parallel queries for all relevant context
    // Use Promise.all for better performance
    const [rawContext, voiceCtx, chatHistory] = await Promise.all([
      findRelevantDocuments(message, userID, 8),
      findRelevantVoiceInMilvus(message, userID, 3),
      findRelevantChats(message, username, userID, 3),
    ]);

    // Process results in parallel
    const [contextBody, relChatBody, relVoiceBody] = await Promise.all([
      resultsReranked(rawContext, message, userID, true),
      resultsReranked(chatHistory, message, userID),
      resultsReranked(voiceCtx, message, userID),
    ]);

    const promptData = {
      relChats: Array.isArray(relChatBody) ? relChatBody : [],
      relContext: contextBody,
      relVoice: Array.isArray(relVoiceBody) ? relVoiceBody : [],
      chat_user: username,
    };

    // Using the updated contextPromptChat function that creates the new message structure
    const body = await contextPromptChat(promptData, message, userID);

    // Use retryMilvusOperation to handle potential LLM request failures
    const chatTask = await retryMilvusOperation(
      async () =>
        sendChatCompletionRequest(
          body,
          await retrieveConfigValue("models.chat")
        ),
      2, // Fewer retries for LLM since these can be slow
      500 // Longer initial delay
    );

    logger.log(
      "LLM",
      `Processed thoughts: ${JSON.stringify(chatTask.thoughtProcess, null, 2)}`
    );
    logger.log(
      "System",
      `Generated textual character response. Time to first token: ${chatTask.timeToFirstToken} seconds. Process speed: ${chatTask.tokensPerSecond}tps`
    );

    // Cache the response for a short time (10 seconds)
    // Only cache if it was successful
    if (chatTask.response) {
      setCachedResult(responseCacheKey, chatTask.response, 10000);
    }
    const strippedResp = await replyStripped(chatTask.response, userID);

    return { response: strippedResp, thoughtProcess: chatTask.thoughtProcess };
  } catch (error) {
    logger.log("System", `Error calling respondWithContext: ${error}`);
    // Return a fallback response rather than throwing
    return {
      response:
        "I'm sorry, I encountered an issue while processing your message. Could you please try again?",
      thoughtProcess: `Error: ${error.message}`,
    };
  }
}

async function rerankString(message, userId) {
  const promptRerank = await rerankPrompt(message, userId);
  const chatTask = await sendToolCompletionRequest(
    promptRerank,
    await retrieveConfigValue("models.rerankTransform")
  );
  return chatTask.response;
}

async function respondWithoutContext(message, userId) {
  try {
    // Build the prompt data with minimal context
    const promptData = {
      relChats: "- No relevant chat context available.",
      relContext: "- No additional context to provide.",
      relVoice: "- No voice conversation history.",
      chat_user: "User",
    };

    // Using updated contextPromptChat function with new message structure
    const body = await contextPromptChat(promptData, message, userId);
    const chatTask = await sendChatCompletionRequest(
      body,
      await retrieveConfigValue("models.chat")
    );

    const strippedResp = await replyStripped(chatTask.response, userId);
    return {
      response: strippedResp,
      thoughtProcess: chatTask.thoughtProcess,
    };
  } catch (error) {
    logger.log("System", `Error in respondWithoutContext: ${error}`);
    return {
      response: "I'm sorry, I encountered an error processing your request.",
      thoughtProcess: `Error: ${error.message}`,
    };
  }
}

async function respondWithVoice(message, userId) {
  const startTime = performance.now();

  // Process acronyms in the message
  const fixedAcro = await fixTTSString(message);
  const userObj = await returnAuthObject(userId);

  logger.log(
    "LLM",
    `Converted ${fixedAcro.acronymCount} acronyms in ${userObj.bot_name}'s TTS message.`
  );

  try {
    // Create temp directory
    const tempDir = path.join(__dirname, "temp");
    await fs.mkdir(tempDir, { recursive: true }).catch(() => {});

    // Get the TTS preference from config
    const ttsPreference = await retrieveConfigValue("ttsPreference");

    let audioFilePath;
    let outputFileName;

    // Generate audio based on the preferred TTS engine
    if (ttsPreference === "fish") {
      // Fish TTS parameters
      const fishParameters = {
        text: fixedAcro.fixedString,
        chunk_length: 400,
        format: "wav",
        reference_id: userObj.fishTTSVoice,
        seed: null,
        normalize: false,
        streaming: false,
        max_new_tokens: 4096,
        top_p: 0.82,
        repetition_penalty: 1.2,
        temperature: 0.75,
      };

      // Make the API request, specifying responseType as arraybuffer for binary data
      const res = await axios.post(
        new URL(await retrieveConfigValue("fishTTS.ttsGenEndpoint.internal")),
        fishParameters,
        { responseType: "arraybuffer" }
      );

      // Generate a filename and save the audio data directly
      outputFileName = `fish_${userId}_${Date.now()}.wav`;
      const tempFilePath = path.join("./final", outputFileName);
      await fs.writeFile(tempFilePath, Buffer.from(res.data));

      audioFilePath = tempFilePath;
    } else {
      // AllTalk implementation
      const voiceForm = new FormData();
      voiceForm.append("text_input", fixedAcro.fixedString);
      voiceForm.append("text_filtering", "standard");
      voiceForm.append("character_voice_gen", userObj.speaker_file);
      voiceForm.append("narrator_enabled", "false");
      voiceForm.append("text_not_inside", "character");
      voiceForm.append("language", "en");
      voiceForm.append("output_file_name", userObj.user_id);
      voiceForm.append("output_file_timestamp", "true");
      voiceForm.append("autoplay", "false");
      voiceForm.append("temperature", "0.9");
      voiceForm.append("repetition_penalty", "1.5");

      const res = await axios.post(
        new URL(await retrieveConfigValue("alltalk.ttsGenEndpoint.internal")),
        voiceForm
      );

      // For AllTalk, download the file from the provided URL
      const fileRes = await axios({
        method: "GET",
        url: `${await retrieveConfigValue("alltalk.ttsServeEndpoint.internal")}${res.data.output_file_url}`,
        responseType: "arraybuffer",
      });

      outputFileName = `alltalk_${userId}_${Date.now()}.wav`;
      const tempFilePath = path.join("./final", outputFileName);
      await fs.writeFile(tempFilePath, Buffer.from(fileRes.data));

      audioFilePath = tempFilePath;
    }

    const timeElapsed = (performance.now() - startTime) / 1000;

    // Process the audio if user has upsampling preference enabled
    if (userObj.ttsUpsamplePref) {
      try {
        // Process the audio file with the specified preset
        const processedFilePath = processAudio(audioFilePath, {
          preset: userObj.ttsEqPref || "clarity",
          userId: userObj.user_id,
        });

        logger.log("API", `Processed audio file to ${processedFilePath}`);

        // Return the appropriate URL
        const serviceEndpoint =
          ttsPreference === "fish" ? "fishTTS" : "alltalk";
        const audioUrl = userObj.is_local
          ? `${await retrieveConfigValue(`${serviceEndpoint}.ttsServeEndpoint.internal`)}${processedFilePath}`
          : `${await retrieveConfigValue(`${serviceEndpoint}.ttsServeEndpoint.external`)}${processedFilePath}`;

        logger.log(
          "LLM",
          `TTS request completed in ${timeElapsed.toFixed(2)} seconds.`
        );
        return audioUrl;
      } catch (processingError) {
        logger.error(
          "API",
          `Error processing audio: ${processingError.message}`
        );
        // Return the original, unprocessed file path if processing fails
        const serviceEndpoint =
          ttsPreference === "fish" ? "fishTTS" : "alltalk";
        return userObj.is_local
          ? `${await retrieveConfigValue(`${serviceEndpoint}.ttsServeEndpoint.internal`)}/${path.basename(audioFilePath)}`
          : `${await retrieveConfigValue(`${serviceEndpoint}.ttsServeEndpoint.external`)}/${path.basename(audioFilePath)}`;
      }
    } else {
      // For non-processed audio, just return a URL to the saved file
      const serviceEndpoint = ttsPreference === "fish" ? "fishTTS" : "alltalk";
      const audioUrl = userObj.is_local
        ? `${await retrieveConfigValue(`${serviceEndpoint}.ttsServeEndpoint.internal`)}/${path.basename(audioFilePath)}`
        : `${await retrieveConfigValue(`${serviceEndpoint}.ttsServeEndpoint.external`)}/${path.basename(audioFilePath)}`;

      logger.log(
        "LLM",
        `TTS request completed in ${timeElapsed.toFixed(2)} seconds.`
      );
      return audioUrl;
    }
  } catch (error) {
    logger.error("TTS", `Error during TTS request: ${error.message}`);
    return { error: error.message };
  }
}

async function respondToDirectVoice(message, userId, withVoice = false) {
  try {
    const userObj = await returnAuthObject(userId);

    // Perform parallel queries for all relevant context
    const [voiceCtx, rawContext] = await Promise.all([
      findRelevantVoiceInMilvus(message, userId, 3),
      findRelevantDocuments(message, userId, 6),
    ]);

    // Process results in parallel
    const [contextBody, voiceCtxBody] = await Promise.all([
      resultsReranked(rawContext, message, userId, true),
      withVoice
        ? resultsReranked(voiceCtx, message, userId, false)
        : "- No additional voice conversations to supply.",
    ]);

    const promptData = {
      relChats: "- No additional chat content.",
      relContext: contextBody,
      relVoice: voiceCtxBody,
      user: userObj.user_name,
    };

    // Using updated contextPromptChat function with new message structure
    const body = await contextPromptChat(promptData, message, userId);
    const chatTask = await sendChatCompletionRequest(
      body,
      await retrieveConfigValue("models.chat")
    );

    logger.log(
      "LLM",
      `Generated textual response to voice message. Time to first token: ${chatTask.timeToFirstToken} seconds. Process speed: ${chatTask.tokensPerSecond}tps`
    );
    const strippedResp = await replyStripped(chatTask.response, userId);

    // If voice response requested, generate it
    if (withVoice) {
      const audioUrl = await respondWithVoice(strippedResp, userId);
      return {
        response: strippedResp,
        audio_url: audioUrl,
        thoughtProcess: chatTask.thoughtProcess,
      };
    } else {
      return {
        response: strippedResp,
        thoughtProcess: chatTask.thoughtProcess,
      };
    }
  } catch (error) {
    logger.log("Voice", `Error in respondToDirectVoice: ${error}`);
    return {
      response: "Error processing voice response.",
      error: error.message,
    };
  }
}
async function addChatMessageAsVector(
  sumText,
  message,
  username,
  date,
  response,
  userId
) {
  try {
    // Use our optimized collection loading
    const isLoaded = await ensureCollectionLoaded(
      await retrieveConfigValue("milvus.collections.chat"),
      userId
    );

    if (!isLoaded) {
      logger.log("Milvus", `Can't load collection for chat.`);
      return false;
    }

    const currentTime = Date.now();
    const embeddingsArray = await getMessageEmbedding(sumText);

    // Prepare vector data
    const vectorData = {
      embedding: embeddingsArray,
      username: username,
      text_content: sumText,
      raw_msg: message,
      ai_message: response,
      time_stamp: currentTime,
    };

    // Schedule for batch insertion
    scheduleVectorInsertion("chat", userId, vectorData);
    return true;
  } catch (error) {
    logger.log("Milvus", `Error processing chat text: ${error}`);
    return false;
  }
}

async function addVoiceMessageAsVector(
  sumString,
  message,
  username,
  date,
  response,
  userId
) {
  const loadedColl = await loadCollectionIfNeeded(
    await retrieveConfigValue("milvus.collections.voice"),
    userId
  );
  if (!loadedColl) {
    logger.log("Milvus", `Can't load collection for voice.`);
    return; // Early return on failure
  }

  try {
    const embeddingsArray = await getMessageEmbedding(message);
    const success = await insertVoiceVectorsIntoMilvus(
      embeddingsArray,
      sumString,
      message,
      response,
      username,
      date,
      userId
    );
    if (success) {
      logger.log("Milvus", "Voice message successfully inserted into Milvus.");
    } else {
      logger.log("Milvus", "Failed to insert voice message into Milvus.");
    }
  } catch (error) {
    logger.log("Milvus", `Error processing voice message: ${error}`);
  }
}

async function respondToEvent(event, userId) {
  try {
    const eventMessage = await returnTwitchEvent(event, userId);

    // Using updated eventPromptChat function with the new message structure
    const instructPrompt = await eventPromptChat(eventMessage, userId);

    const chatTask = await sendChatCompletionRequest(
      instructPrompt,
      await retrieveConfigValue("models.chat")
    );
    logger.log(
      "LLM",
      `Generated event response. Time to first token: ${chatTask.timeToFirstToken} seconds. Process speed: ${chatTask.tokensPerSecond}tps`
    );

    const strippedResp = await replyStripped(chatTask.response, userId);
    return { response: strippedResp, thoughtProcess: chatTask.thoughtProcess };
  } catch (error) {
    logger.log("System", `Error in respondToEvent: ${error}`);
    return {
      response: "I'm sorry, I encountered an error processing this event.",
      thoughtProcess: `Error: ${error.message}`,
    };
  }
}

async function startIndexingVectors(userId) {
  const authObjects = await returnAuthObject(userId);
  logger.log("Milvus", `Beginning indexing for ${authObjects.user_id}`);
  await processFiles(
    `${await retrieveConfigValue("milvus.localTextDirectory")}`,
    authObjects.user_id
  );
}

async function checkMilvusHealth() {
  const isUp = await client.checkHealth();
  return isUp.isHealthy;
}

/**
 * Perform a health check on the Milvus database with detailed diagnostics
 * @param {string} userId - User ID to check collections for
 * @returns {Promise<object>} - Health status and metrics
 */
async function checkMilvusHealthDetailed(userId = null) {
  try {
    // Basic health check
    const isHealthy = await client.checkHealth();

    const healthData = {
      isHealthy: isHealthy.isHealthy,
      timestamp: Date.now(),
      metrics: {},
    };

    if (!isHealthy.isHealthy) {
      logger.log("Milvus", "Milvus health check failed");
      return healthData;
    }

    // If userId is provided, check their collections
    if (userId) {
      const collections = [
        await retrieveConfigValue("milvus.collections.user"),
        await retrieveConfigValue("milvus.collections.intelligence"),
        await retrieveConfigValue("milvus.collections.chat"),
        await retrieveConfigValue("milvus.collections.voice"),
      ];

      const collectionStats = {};

      for (const collection of collections) {
        const collName = `${collection}_${userId}`;
        try {
          const exists = await client.hasCollection({
            collection_name: collName,
          });

          if (exists.value) {
            // Get collection statistics
            const stats = await client.getCollectionStatistics({
              collection_name: collName,
            });

            // Get load status
            const loadState = await client.getLoadState({
              collection_name: collName,
            });

            collectionStats[collection] = {
              exists: true,
              rowCount: parseInt(stats.stats.row_count || 0),
              loadState: loadState.state,
            };
          } else {
            collectionStats[collection] = {
              exists: false,
            };
          }
        } catch (err) {
          collectionStats[collection] = {
            exists: "error",
            error: err.message,
          };
        }
      }

      healthData.metrics.collections = collectionStats;
    }

    // Get system info if available
    try {
      const sysInfo = await client.getMetric({
        request: {},
      });

      if (sysInfo && sysInfo.response) {
        healthData.metrics.system = sysInfo.response;
      }
    } catch (error) {
      healthData.metrics.system = { error: error.message };
    }

    // Add cache stats
    healthData.metrics.cache = {
      queryCache: {
        size: queryCache.size,
        maxSize: MAX_CACHE_SIZE,
      },
      collectionLoadStatus: {
        size: collectionLoadStatus.size,
      },
    };

    return healthData;
  } catch (error) {
    logger.log("Milvus", `Error in detailed health check: ${error}`);
    return {
      isHealthy: false,
      error: error.message,
      timestamp: Date.now(),
    };
  }
}

/**
 * Drops specified collection(s) in Milvus based on the provided parameters.
 * Supports dropping a single collection for a user, all collections of a type for a user,
 * or all collections for all users.
 *
 * @param {string} collection - The name of the collection to drop, or "all" for all collections.
 * @param {string} userId - The ID of the user, or "all" for all users.
 * @returns {Promise<boolean>} - True if the operation was successful, false otherwise.
 */
async function weGottaGoBald(collection, userId) {
  try {
    if (userId === "all") {
      // Reload all specified collections for all users
      const allUsers = await returnAPIKeys();
      let allDropsSuccessful = true;

      for (const user of allUsers) {
        if (collection === "all") {
          const allCollections = [
            await retrieveConfigValue("milvus.collections.user"),
            await retrieveConfigValue("milvus.collections.intelligence"),
            await retrieveConfigValue("milvus.collections.chat"),
            await retrieveConfigValue("milvus.collections.voice"),
          ];
          for (const coll of allCollections) {
            const success = await dropCollection(coll, user.user_id);
            if (!success) {
              allDropsSuccessful = false;
            }
          }
        } else {
          const success = await dropCollection(collection, user.user_id);
          if (!success) {
            allDropsSuccessful = false;
          }
        }
      }
      return allDropsSuccessful;
    } else {
      // Reload a specific collection for a specific user
      return await dropCollection(collection, userId);
    }
  } catch (error) {
    logger.log("Milvus", `Error during database reload: ${error}`);
    return false;
  }
}

/**
 * Drops a specified collection in Milvus for a given user.
 *
 * @param {string} collection - The name of the collection to drop.
 * @param {string} userId - The ID of the user associated with the collection.
 * @returns {Promise<boolean>} - True if the collection was dropped successfully, false otherwise.
 */
async function dropCollection(collection, userId) {
  const collectionName = `${collection}_${userId}`;
  try {
    const exists = await client.hasCollection({
      collection_name: collectionName,
    });

    if (!exists.value) {
      logger.log("Milvus", `Collection '${collectionName}' does not exist.`);
      return false;
    }

    const status = await client.dropCollection({
      collection_name: collectionName,
    });

    if (status.error_code === "Success") {
      logger.log(
        "Milvus",
        `Collection '${collectionName}' dropped successfully.`
      );
      return true;
    } else {
      logger.log(
        "Milvus",
        `Failed to drop collection '${collectionName}'. Reason: ${status.reason}`
      );
      return false;
    }
  } catch (error) {
    logger.log(
      "Milvus",
      `Error dropping collection '${collectionName}': ${error}`
    );
    return false;
  }
}

const isValidJson = (input) => {
  if (typeof input === "string") {
    try {
      JSON.parse(input);
      return true;
    } catch {
      return false;
    }
  } else if (typeof input === "object" && input !== null) {
    return true;
  }
  return false;
};

async function checkEndpoint(endpoint, key, modelName) {
  try {
    if (endpoint === (await retrieveConfigValue("models.embedding.endpoint"))) {
      if (
        (await retrieveConfigValue("models.embedding.apiKeyType")) ===
        "infinity"
      ) {
        const response = await axios.get(`${endpoint}/models`, {
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json",
          },
          validateStatus: (status) => status < 500,
        });

        if (
          response.status === 200 &&
          response.data &&
          Array.isArray(response.data.data)
        ) {
          const modelFound = response.data.data.some(
            (model) => model.id === modelName
          );
          if (modelFound) {
            return true;
          } else {
            throw new Error(
              `Model ${modelName} not found in the list of available models.`
            );
          }
        } else {
          throw new Error(
            `Invalid response from embedding endpoint: ${response.status}`
          );
        }
      } else if (
        (await retrieveConfigValue("models.embedding.apiKeyType")) ===
        "enspiraEmb"
      ) {
        const response = await axios.get(
          `${await retrieveConfigValue("models.embedding.endpoint")}/health`,
          {
            headers: {
              Authorization: `Bearer ${await retrieveConfigValue("models.embedding.apiKey")}`,
            },
          }
        );
        if (response.status == 200) {
          return true;
        } else {
          return false;
        }
      }
    } else {
      const openai = new OpenAI({
        baseURL: endpoint,
        apiKey: key,
      });
      const response = await openai.models.list();
      if (
        response.data &&
        Array.isArray(response.data) &&
        response.data.length > 0
      ) {
        return true;
      } else {
        throw new Error(`Invalid or empty response from LLM endpoint`);
      }
    }
  } catch (err) {
    logger.log("INIT", `Error checking endpoint ${endpoint}: ${err}`);
  }
}

export {
  checkEndpoint,
  respondWithContext,
  checkMilvusHealth,
  rerankString,
  searchBraveAPI,
  respondToDirectVoice,
  addVoiceMessageAsVector,
  loadCollectionIfNeeded,
  addChatMessageAsVector,
  insertAugmentVectorsToMilvus,
  respondWithoutContext,
  respondWithVoice,
  respondToEvent,
  processFiles,
  startIndexingVectors,
  findRelevantVoiceInMilvus,
  findRelevantDocuments,
  weGottaGoBald,
  checkAndCreateCollection,
  returnRecentChats,
  ensureCollectionLoaded,
  retryMilvusOperation,
  getOptimizedSearchParams,
  scheduleVectorInsertion,
  processVectorBatch,
  getCachedResult,
  setCachedResult,
  clearQueryCache,
  checkMilvusHealthDetailed,
};
</file>

<file path="index.js">
import Fastify from "fastify";
import fs from "fs-extra";
import { join } from "path";
import { audioRoutes } from './routes/audio.js';
import twitchEventSubRoutes from './routes/twitch.js';
import * as aiHelper from "./ai-logic.js";
import webRoutes from './routes/web.js';
import {
  initAllAPIs,
  returnAPIKeys
} from "./api-helper.js";
import { preloadAllTokenizers } from "./token-helper.js";
import { retrieveConfigValue, loadConfig } from "./config-helper.js";
import routes from './routes/v1.js';
import './create-global-logger.js'; // This ensures the logger is properly set up
import { logger } from './create-global-logger.js';
import fastifyCookie from "@fastify/cookie";
import * as crypto from 'crypto'
import { setupTemplating } from './template-engine.js';

process.on('uncaughtException', (err) => {
  console.error('UNCAUGHT EXCEPTION:', err);
  // Keep process alive for debugging
  console.error('Stack trace:', err.stack);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('UNHANDLED REJECTION:', reason);
  // Keep process alive for debugging
  console.error('Stack trace:', reason.stack);
});

// Create the fastify instance
const createServer = async () => {
  const fastify = Fastify({
    trustProxy: true,
    http2: true,
    methodNotAllowed: true,
    https: {
      allowHTTP1: true,
      key: fs.readFileSync(join(process.cwd(), "self_signed.key")),
      cert: fs.readFileSync(join(process.cwd(), "self_signed.crt")),
    },
    logger: false,
    requestTimeout: 30000,
    // Add these options
    // For http/1 header size
    http: {
      maxHeaderSize: 81920, // 80KB
      keepAliveTimeout: 120000, // 2 minutes
      headersTimeout: 65000 // 65 seconds
    },
    bodyLimit: 10485760, // 10MB for request body size (default is 1MB)
    maxParamLength: 2000, // Increase param length limit

  });
  const endPointDoc = {
    "chat": {
      endpoint: "/v1/chats",
      method: "POST"
    },
    "voice": {
      endpoint: "/v1/voice",
      method: "POST"
    },
    "event": {
      endpoint: "/v1/events",
      method: "POST"
    },
    "tts": {
      endpoint: "/v1/speak",
      method: "POST"
    },
    "healthcheck": {
      endpoint: "/v1/healthcheck",
      method: "GET"
    }
  };

  await fastify.register(fastifyCookie, {
    secret: await retrieveConfigValue("server.cookieSecret") || crypto.randomBytes(32).toString('hex'), // Use a stored secret or generate one
    parseOptions: {}
  });

  await fastify.register(import('@fastify/multipart'), {
    limits: {
      fieldNameSize: 100,
      fieldSize: 1000000,
      fields: 20,
      fileSize: 5000000,
      files: 5,
      headerPairs: 2000
    },
    attachFieldsToBody: true
  });

  fastify.setErrorHandler((error, request, reply) => {
    if (error instanceof Fastify.errorCodes.FST_ERR_ROUTE_METHOD_NOT_SUPPORTED) {
      reply.code(405).send({
        error: "Method Not Allowed",
        message: `HTTP method "${request.method}" is not supported for this route.`,
        allowedMethods: reply.context.config.allowedMethods // List of allowed methods
      });
    } else {
      reply.send(error);
    }
  });
  await setupTemplating(fastify);
  // Register routes
  await fastify.register(routes, {
    prefix: "/api/v1",
  });

  await fastify.register(audioRoutes, {
    outputDir: 'final',
    prefix: '/files/audio',
    addContentDisposition: true
  });

  await fastify.register(twitchEventSubRoutes, {
    prefix: "/api/v1/twitch"
  });

  await fastify.register(webRoutes, {
    prefix: "/web"
  });

  return fastify;
};

/**
 * Performs preflight checks on external services and databases.
 * @returns {Promise<object>} - A promise that resolves to a status object.
 */
export async function preflightChecks() {
  try {
    const axios = (await import('axios')).default;
    let ttsRes = { status: 0 };
    const ttsPreference = await retrieveConfigValue("ttsPreference");
    try {
      switch (ttsPreference) {
        case "fish":
          ttsRes = await axios.get(
            await retrieveConfigValue("fishTTS.healthcheck.internal")
          );
          break;
        case "alltalk":
          ttsRes = await axios.get(
            await retrieveConfigValue("alltalk.healthcheck.internal")
          );
          break;
        default:
          ttsRes = { status: 200 };
          break;
      }
    } catch (ttsError) {
      logger.log("API", `TTS healthcheck error: ${ttsError.message}`);
    }

    logger.log("API", `Current TTS engine: ${ttsPreference}, ${ttsRes.status == 200 ? "is alive." : "is not alive."}`);
    const databaseRes = await aiHelper.checkMilvusHealth();

    const checkResult = {
      llmStatuses: {
        allTalkIsOnline: ttsRes.status == 200 ? true : false,
        embeddingIsOnline: await aiHelper.checkEndpoint(
          await retrieveConfigValue("models.embedding.endpoint"),
          await retrieveConfigValue("models.embedding.apiKey"),
          await retrieveConfigValue("models.embedding.model"),
        ),
        llmIsOnline: await aiHelper.checkEndpoint(
          await retrieveConfigValue("models.chat.endpoint"),
          await retrieveConfigValue("models.chat.apiKey"),
          await retrieveConfigValue("models.chat.model"),
        ),
        summaryIsOnline: await aiHelper.checkEndpoint(
          await retrieveConfigValue("models.summary.endpoint"),
          await retrieveConfigValue("models.summary.apiKey"),
          await retrieveConfigValue("models.summary.model"),
        ),
        queryIsOnline: await aiHelper.checkEndpoint(
          await retrieveConfigValue("models.query.endpoint"),
          await retrieveConfigValue("models.query.apiKey"),
          await retrieveConfigValue("models.query.model"),
        ),
        conversionIsOnline: await aiHelper.checkEndpoint(
          await retrieveConfigValue("models.conversion.endpoint"),
          await retrieveConfigValue("models.conversion.apiKey"),
          await retrieveConfigValue("models.conversion.model"),
        ),
      },
      restIsOnline: true,
      dbIsOnline: databaseRes,
    };

    return checkResult;
  } catch (error) {
    logger.error("System", `Error during preflight checks: ${error.message}`);
    return {
      llmStatuses: {
        allTalkIsOnline: false,
        embeddingIsOnline: false,
        llmIsOnline: false,
        summaryIsOnline: false,
        queryIsOnline: false,
        conversionIsOnline: false,
      },
      restIsOnline: false,
      dbIsOnline: false,
    };
  }
}

/**
 * Launches the Fastify server.
 * @param {Fastify.FastifyInstance} fastify - The Fastify instance to launch.
 * @returns {Promise<void>} - A promise that resolves when the server starts listening.
 */
export async function launchRest(fastify) {
  const portNum = await retrieveConfigValue("server.port");

  try {
    await fastify.listen({
      port: portNum,
      host: await retrieveConfigValue("server.endpoints.internal"),
    });
    logger.log(
      "API",
      `Fastify server launched successfully on port ${portNum}`,
    );
    return Promise.resolve();
  } catch (err) {
    logger.error("API", `Failed to launch API server with error: ${err}`);
    await fs.writeFile('./error.txt', JSON.stringify(err))
    throw err;
  }
}

/**
 * Initializes the application, loads API keys, starts vector indexing,
 * preloads tokenizers, launches the REST server, and performs preflight checks.
 * @returns {Promise<{server: Fastify.FastifyInstance, status: object}>} - A promise that resolves with the server instance and status.
 */
export async function initializeApp() {
  try {
    const allUsers = await returnAPIKeys();

    const collectionNames = [
      await retrieveConfigValue("milvus.collections.user"),
      await retrieveConfigValue("milvus.collections.intelligence"),
      await retrieveConfigValue("milvus.collections.chat"),
      await retrieveConfigValue("milvus.collections.voice"),
    ];

    await loadConfig();
    for await (const user of allUsers) {
      for await (const collectionName of collectionNames) {
        try {
          const collectionExists = await aiHelper.checkAndCreateCollection(
            collectionName,
            user.user_id,
          );
          if (!collectionExists) {
            logger.error("Milvus", `Failed to create collection ${collectionName} for user ${user.user_id}`);
            continue;
          }

          const isLoaded = await aiHelper.loadCollectionIfNeeded(
            collectionName,
            user.user_id,
          );
          if (!isLoaded) {
            logger.error("Milvus", `Failed to load collection ${collectionName} for user ${user.user_id}`);
            continue;
          }
        } catch (error) {
          logger.error("Milvus", `Error with collection ${collectionName} for user ${user.user_id}: ${error.message}`);
          continue;
        }
      }
    }

    // Now start indexing vectors after ensuring each user has collections
    await Promise.all(
      allUsers.map((user) => aiHelper.startIndexingVectors(user.user_id)),
    );

    await preloadAllTokenizers();
    const server = await createServer();
    await launchRest(server);

    const status = await preflightChecks();
    await initAllAPIs();

    try {
      logger.log("System", "Importing Twitch EventSub manager...");
      const { registerAllUsersEventSub, setupTwitchCronJobs } = await import('./twitch-eventsub-manager.js');

      logger.log("System", "Registering Twitch EventSub subscriptions...");
      const eventSubResults = await registerAllUsersEventSub();
      logger.log("System", `EventSub registration complete: ${eventSubResults.success} successful, ${eventSubResults.failures} failed`);

      // Set up periodic Twitch data update jobs
      logger.log("System", "Setting up Twitch cron jobs...");
      setupTwitchCronJobs();
    } catch (eventSubError) {
      logger.error("System", `Error with Twitch integration: ${eventSubError.message}`);
      // Continue execution even if EventSub registration fails
    }

    logger.log("System", "Enspira is fully initialized and ready!");
    return { server, status };
  } catch (error) {
    logger.error("System", `Failed to initialize the application: ${error.message}`);
    throw error;
  }
}

// Only start server if this file is run directly, not if it's imported
if (import.meta.url === import.meta.main) {
  initializeApp().catch(err => {
    logger.error("System", `Fatal error in application: ${err.message}`);
    process.exit(1);
  });
}

// Export the initializeApp function for use in main.js
export default initializeApp;
</file>

<file path="routes/v1.js">
import * as aiHelper from "../ai-logic.js";
import { containsCharacterName, containsAuxBotName } from "../prompt-helper.js";
import {
  checkForAuth,
  updateUserParameter,
  returnAuthObject,
} from "../api-helper.js";
import { maintainVoiceContext } from "../data-helper.js";
import * as twitchHelper from "../twitch-helper.js";
import { retrieveConfigValue } from "../config-helper.js";
import moment from "moment";
import fastifyFormbody from "@fastify/formbody";
import cors from "@fastify/cors";
import fastifyCompress from "@fastify/compress";
import fs from "fs-extra";
import * as crypto from "crypto";
import path from "path";

async function requireAuth(request, reply) {
  // First check if cookies object exists
  if (!request.cookies) {
    logger.error(
      "Auth",
      "Cookie parser not available - make sure fastify-cookie is registered"
    );
    return reply.redirect("/web/auth/login");
  }

  const sessionToken = request.cookies.enspira_session;

  if (!sessionToken) {
    return reply.redirect("/web/auth/login");
  }

  try {
    // Verify and decode the session token
    const decoded = verifySessionToken(sessionToken);

    if (!decoded || !decoded.userId) {
      // Invalid token
      reply.clearCookie("enspira_session");
      return reply.redirect("/web/auth/login");
    }

    // Get user from database
    const user = await returnAuthObject(decoded.userId);

    if (!user) {
      // User doesn't exist
      reply.clearCookie("enspira_session");
      return reply.redirect("/web/auth/login");
    }

    // Add user to request for use in route handlers
    request.user = user;

    // Continue to route handler
    return;
  } catch (error) {
    logger.error("Auth", `Session validation error: ${error.message}`);
    reply.clearCookie("enspira_session");
    return reply.redirect("/web/auth/login");
  }
}

export function createSessionToken(userId, expiresIn = "7d") {
  // Create a token payload
  const payload = {
    userId,
    exp: Math.floor(Date.now() / 1000) + 60 * 60 * 24 * 7, // 7 days
  };

  // Sign the token
  const token = crypto
    .createHmac("sha256", process.env.COOKIE_SECRET || "enspira-secret-key")
    .update(JSON.stringify(payload))
    .digest("hex");

  // Return token and payload together
  return `${token}.${Buffer.from(JSON.stringify(payload)).toString("base64")}`;
}

// Function to verify a session token
export function verifySessionToken(token) {
  try {
    const [signature, payloadBase64] = token.split(".");

    // Decode the payload
    const payload = JSON.parse(Buffer.from(payloadBase64, "base64").toString());

    // Check if token is expired
    if (payload.exp < Math.floor(Date.now() / 1000)) {
      return null;
    }

    // Verify the signature
    const expectedSignature = crypto
      .createHmac("sha256", process.env.COOKIE_SECRET || "enspira-secret-key")
      .update(JSON.stringify(payload))
      .digest("hex");

    if (signature !== expectedSignature) {
      return null;
    }

    return payload;
  } catch (error) {
    logger.error("Auth", `Token verification error: ${error.message}`);
    return null;
  }
}

/**
 * Checks if the input contains a jailbreak attempt.
 * @param {string} input - The input string to check.
 * @returns {boolean} - True if the input contains a jailbreak attempt, false otherwise.
 */
function containsJailbreakAttempt(input) {
  const pattern =
    /\b(ignore|disregard|bypass|override|forget|delete|remove|disable|break|reset|unlock|nullify|circumvent|destroy)\b\s+(all\s+)?(previous\s+|prior\s+|any\s+)?(instructions?|prompts?|rules?|filters?|limitations?|constraints?|policies?|protocols?|restrictions?|directives?|guidelines?)/i;
  return pattern.test(input);
}

async function routes(fastify, options) {
  await configureResponseHandling(fastify);

  await fastify.register(import("@fastify/rate-limit"), {
    max: 100,
    timeWindow: "20 seconds",
  });

  await fastify.register(cors, {
    origin: true,
  });

  await fastify.register(fastifyCompress, {
    global: true,
    threshold: 1024, // Start compressing at 1KB
    encodings: ["gzip", "deflate", "br"],
    inflateIfDeflated: true, // Handle already compressed payloads
    zlibOptions: {
      level: 4, // Balance between compression level and CPU usage
      memLevel: 8, // Use more memory for better compression
      windowBits: 15, // Maximum window size
    },
  });
  await fastify.register(fastifyFormbody);

  fastify.setErrorHandler((error, request, reply) => {
    if (error && error.code === "FST_ERR_ROUTE_METHOD_NOT_SUPPORTED") {
      reply.code(405).send({
        error: "Method Not Allowed",
        message: `HTTP method "${request.method}" is not supported for this route.`,
        allowedMethods: reply.context.config.allowedMethods,
      });
      return reply;
    } else {
      reply.send(error);
      return reply;
    }
  });

  // Login POST handler
  fastify.post("/auth/login", async (request, reply) => {
    try {
      const { user_id, password } = request.body;

      if (!user_id || !password) {
        return reply.redirect(
          "/web/auth/auth/login?error=Missing+required+fields"
        );
      }

      // Get user
      const user = await returnAuthObject(user_id);

      if (!user) {
        return reply.redirect("/web/auth/login?error=Invalid+credentials");
      }

      // Check password
      if (!user.webPasswordHash || !user.webPasswordSalt) {
        return reply.redirect("/web/auth/login?error=No+password+set");
      }

      const passwordCorrect = await isPasswordCorrect(
        user.webPasswordHash,
        user.webPasswordSalt,
        user.webPasswordIterations || 20480,
        password
      );

      if (!passwordCorrect) {
        return reply.redirect("/web/auth/login?error=Invalid+credentials");
      }

      // Create session
      const sessionToken = createSessionToken(user_id);

      // Set cookie
      reply.setCookie("enspira_session", sessionToken, {
        path: "/",
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "lax",
        maxAge: 60 * 60 * 24 * 7, // 7 days
      });

      // Redirect to dashboard
      return reply.redirect("/web/dashboard");
    } catch (error) {
      logger.error("Auth", `Login error: ${error.message}`);
      return reply.redirect("/web/auth/auth/login?error=An+error+occurred");
    }
  });

  // Voice file upload endpoint
  // Updated server route to use the new JSON endpoint on the helper API
  fastify.post('/character/voice-upload', { preHandler: requireAuth }, async (request, reply) => {
    try {
      const user = request.user;

      // Debug logging
      logger.log("Audio", `Voice upload request received for user ${user.user_id}`);

      // Extract file data from the request body
      const fileData = request.body.files || [];

      logger.log("Audio", `Received ${fileData.length} files in Base64 format`);

      if (fileData.length === 0) {
        logger.error("Audio", "No files received in request");
        return reply.redirect('/web/character?error=No+files+uploaded');
      }

      // Validate file count
      if (fileData.length > 4) {
        logger.error("Audio", `Too many files: ${fileData.length}`);
        return reply.redirect('/web/character?error=Maximum+4+files+allowed');
      }

      // Process each file
      const processedFiles = [];

      for (const file of fileData) {
        try {
          // Validate the file data
          if (!file.name || !file.data) {
            logger.error("Audio", "Invalid file data: missing name or data");
            continue;
          }

          // Check file name
          if (!file.name.toLowerCase().endsWith('.wav')) {
            logger.error("Audio", `File ${file.name} is not a WAV file`);
            return reply.redirect('/web/character?error=Only+WAV+files+are+accepted');
          }

          // Decode Base64 data
          const base64Data = file.data.split(';base64,').pop();
          const buffer = Buffer.from(base64Data, 'base64');

          // Check file size
          if (buffer.length > 3 * 1024 * 1024) {
            logger.error("Audio", `File ${file.name} exceeds 3MB limit (${buffer.length} bytes)`);
            return reply.redirect('/web/character?error=File+exceeds+3MB+limit');
          }

          logger.log("Audio", `Decoded ${file.name}: ${buffer.length} bytes`);

          // Validate audio file - now using our lightweight parser
          const validationResult = await validateWavBuffer(buffer);

          if (!validationResult.valid) {
            logger.error("Audio", `Audio validation failed for ${file.name}: ${validationResult.reason}`);
            return reply.redirect(`/web/character?error=${encodeURIComponent(validationResult.reason)}`);
          }

          // Add to processed files - we'll pass along the Base64 data directly
          processedFiles.push({
            name: file.name,
            data: file.data
          });

          logger.log("Audio", `Validated ${file.name}: sampleRate=${validationResult.sampleRate}Hz, duration=${validationResult.duration.toFixed(1)}s`);
        } catch (fileError) {
          logger.error("Audio", `Error processing file ${file.name}: ${fileError.message}`);
          return reply.redirect('/web/character?error=Error+processing+file');
        }
      }

      // Check if we have any valid files
      if (processedFiles.length === 0) {
        logger.error("Audio", "No valid files found in request");
        return reply.redirect('/web/character?error=No+valid+files+uploaded');
      }

      // Get the base URL for the helper API
      const helperApiBase = await retrieveConfigValue("voiceHelper.endpoint") || 'http://localhost:3500';

      // Construct the JSON endpoint URL - now using the new create-json endpoint
      const helperApiEndpoint = `${helperApiBase}/voice/create-json`;

      // Log that we're sending files to the helper API
      logger.log("Audio", `Sending ${processedFiles.length} files to voice helper API at ${helperApiEndpoint}`);

      // Send to helper API using JSON
      try {
        const axios = (await import('axios')).default;

        // Create the JSON payload
        const jsonPayload = {
          files: processedFiles
        };

        // Send the request with JSON payload
        const response = await axios.post(
          `${helperApiEndpoint}?userID=${user.user_id}&characterName=${encodeURIComponent(user.bot_name || 'character')}`,
          jsonPayload,
          {
            headers: {
              'Content-Type': 'application/json',
            },
            timeout: 60000, // 60 second timeout
            maxContentLength: Infinity,
            maxBodyLength: Infinity
          }
        );

        // Check response
        if (response.data && response.data.success && response.data.filename) {
          // Update user's speaker_file with the returned filename
          await updateUserParameter(user.user_id, "speaker_file", response.data.filename);

          logger.log("Audio", `Successfully processed voice files for user ${user.user_id}, saved as ${response.data.filename}`);

          // Redirect with success message
          return reply.redirect('/web/character?success=Voice+files+uploaded+successfully');
        } else {
          logger.error("Audio", `Helper API error: ${JSON.stringify(response.data)}`);
          return reply.redirect('/web/character?error=Failed+to+process+voice+files');
        }
      } catch (apiError) {
        logger.error("Audio", `Helper API request failed: ${apiError.message}`);

        let errorMessage = 'Upload+failed';
        if (apiError.code === 'ECONNREFUSED' || apiError.code === 'ECONNABORTED') {
          errorMessage = 'Voice+processing+service+unavailable';
        } else if (apiError.response && apiError.response.status) {
          errorMessage = `Server+error+${apiError.response.status}`;
        }

        return reply.redirect(`/web/character?error=${errorMessage}`);
      }
    } catch (error) {
      logger.error("Audio", `Error in voice upload route: ${error.message}`);
      return reply.redirect('/web/character?error=Internal+server+error');
    }
  });

  // Logout route
  fastify.get("/auth/logout", async (request, reply) => {
    reply.clearCookie("enspira_session");
    return reply.redirect("/web/auth/login");
  });

  fastify.post(
    "/character/features",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Extract values from form data
        const funFacts = getFieldValue(request.body.funFacts) === "true";
        const funFactsInterval = parseInt(
          getFieldValue(request.body.funFactsInterval),
          10
        );
        const ttsEnabled = getFieldValue(request.body.tts_enabled) === "true";
        const ttsEqPref = getFieldValue(request.body.ttsEqPref);
        const ttsUpsamplePref =
          getFieldValue(request.body.ttsUpsamplePref) === "true";

        // Validate funFactsInterval
        const interval = Math.max(5, Math.min(240, funFactsInterval || 30));

        // Update user parameters
        await updateUserParameter(user.user_id, "funFacts", funFacts);
        await updateUserParameter(user.user_id, "funFactsInterval", interval);
        await updateUserParameter(user.user_id, "tts_enabled", ttsEnabled);

        // Only update TTS-related settings if TTS is enabled
        if (ttsEnabled) {
          await updateUserParameter(user.user_id, "ttsEqPref", ttsEqPref);
          await updateUserParameter(
            user.user_id,
            "ttsUpsamplePref",
            ttsUpsamplePref
          );
        }

        reply.send({
          success: true,
          message: "Character features updated successfully",
        });
      } catch (error) {
        logger.error(
          "Web",
          `Error updating character features: ${error.message}`
        );
        reply.code(500).send({
          success: false,
          error: "An error occurred while updating character features",
        });
      }
    }
  );

  fastify.get(
    "/auth/twitch/connect",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const { type } = request.query;
        const user = request.user;

        if (!type || (type !== "bot" && type !== "streamer")) {
          return reply.code(400).send({ error: "Invalid account type" });
        }

        // Generate auth token and store it temporarily
        const authToken = crypto.randomBytes(32).toString("hex");

        global.pendingTwitchAuths = global.pendingTwitchAuths || new Map();
        global.pendingTwitchAuths.set(authToken, {
          userId: user.user_id,
          createdAt: Date.now(),
          authType: type,
        });

        // Get the scopes based on auth type
        const scopeType = type;
        let scopeValue;

        try {
          // Get the scopes from config
          const configScopes = await retrieveConfigValue(
            `twitch.scopes.${scopeType}`
          );

          // Handle different possible formats
          if (Array.isArray(configScopes)) {
            scopeValue = configScopes.join(" ");
          } else if (typeof configScopes === "string") {
            scopeValue = configScopes;
          } else if (configScopes === null || configScopes === undefined) {
            if (scopeType === "bot") {
              scopeValue = "chat:read chat:edit user:read:email";
            } else {
              scopeValue =
                "channel:read:broadcast channel:read:subscriptions channel:read:hype_train channel:read:follows";
            }
            logger.log(
              "Auth",
              `No twitch.scopes.${scopeType} found in config, using defaults`
            );
          } else {
            scopeValue = String(configScopes);
            logger.log(
              "Auth",
              `Unexpected type for twitch.scopes.${scopeType}: ${typeof configScopes}. Converting to string.`
            );
          }
        } catch (error) {
          logger.error(
            "Auth",
            `Error getting Twitch scopes: ${error.message}. Using defaults.`
          );
          if (scopeType === "bot") {
            scopeValue = "chat:read chat:edit user:read:email";
          } else {
            scopeValue =
              "channel:read:broadcast channel:read:subscriptions channel:read:hype_train channel:read:follows";
          }
        }

        // Create the Twitch OAuth URL
        const authUrl = new URL("https://id.twitch.tv/oauth2/authorize");
        authUrl.searchParams.set(
          "client_id",
          await retrieveConfigValue("twitch.clientId")
        );
        authUrl.searchParams.set(
          "redirect_uri",
          await retrieveConfigValue("twitch.redirectUri")
        );
        authUrl.searchParams.set("response_type", "code");
        authUrl.searchParams.set("scope", scopeValue);
        authUrl.searchParams.set("state", authToken);

        // Force login prompt if connecting a bot account
        if (type === "bot") {
          authUrl.searchParams.set("force_verify", "true");
        }

        return reply.redirect(authUrl.toString());
      } catch (error) {
        logger.error("Auth", `Error in Twitch connect: ${error.message}`);
        return reply.code(500).send({ error: "An error occurred" });
      }
    }
  );

  // 2. Authentication endpoint that verifies credentials
  fastify.post("/auth/twitch/authenticate", async (request, reply) => {
    try {
      // 1. Validate request body
      if (!request.body || typeof request.body !== "object") {
        return reply.code(400).send({ error: "Invalid request format" });
      }

      const { user_id, password, auth_type } = request.body;

      // 2. Check for required fields
      if (!user_id || !password) {
        return reply.code(400).send({ error: "Missing required fields" });
      }

      // Log the auth_type to debug
      logger.log(
        "Auth",
        `Authenticating user: ${user_id} for ${auth_type || "streamer"} account`
      );

      // 4. Get user details
      const user = await returnAuthObject(user_id);

      if (!user) {
        return reply.code(401).send({ error: "User not found" });
      }

      // 5. Check if password hash and salt exist
      if (!user.webPasswordHash || !user.webPasswordSalt) {
        logger.log("Auth", `User ${user_id} has no password set`);
        return reply.code(401).send({
          error: "No password set for this account",
          setupRequired: true,
        });
      }

      // 6. Validate parameters for isPasswordCorrect
      const iterations = user.webPasswordIterations || 20480;

      logger.log(
        "Auth",
        `Verifying password with hash=${user.webPasswordHash ? "exists" : "missing"}, salt=${user.webPasswordSalt ? "exists" : "missing"}`
      );

      // 7. Verify password with explicit parameter validation
      const passwordCorrect = await isPasswordCorrect(
        user.webPasswordHash,
        user.webPasswordSalt,
        iterations,
        password
      );

      if (!passwordCorrect) {
        return reply.code(401).send({ error: "Invalid credentials" });
      }

      // Generate auth token and store it temporarily
      const authToken = crypto.randomBytes(32).toString("hex");

      global.pendingTwitchAuths = global.pendingTwitchAuths || new Map();
      global.pendingTwitchAuths.set(authToken, {
        userId: user_id,
        createdAt: Date.now(),
        authType: auth_type || "streamer", // Default to streamer if not specified
      });

      // Get the scopes based on auth type (bot or streamer)
      const scopeType = auth_type === "bot" ? "bot" : "streamer";
      let scopeValue;

      try {
        // Get the scopes from config
        const configScopes = await retrieveConfigValue(
          `twitch.scopes.${scopeType}`
        );

        // Handle different possible formats
        if (Array.isArray(configScopes)) {
          // If it's already an array, just join it
          scopeValue = configScopes.join(" ");
        } else if (typeof configScopes === "string") {
          // If it's a single string, use it directly
          scopeValue = configScopes;
        } else if (configScopes === null || configScopes === undefined) {
          // If not configured, use default scopes based on type
          if (scopeType === "bot") {
            scopeValue = "chat:read chat:edit user:read:email";
          } else {
            scopeValue =
              "channel:read:broadcast channel:read:subscriptions channel:read:hype_train channel:read:follows";
          }
          logger.log(
            "Auth",
            `No twitch.scopes.${scopeType} found in config, using defaults`
          );
        } else {
          // Unexpected type, convert to string
          scopeValue = String(configScopes);
          logger.log(
            "Auth",
            `Unexpected type for twitch.scopes.${scopeType}: ${typeof configScopes}. Converting to string.`
          );
        }
      } catch (error) {
        // Fallback to default scopes if there's an error
        logger.error(
          "Auth",
          `Error getting Twitch scopes: ${error.message}. Using defaults.`
        );
        if (scopeType === "bot") {
          scopeValue = "chat:read chat:edit user:read:email";
        } else {
          scopeValue =
            "channel:read:broadcast channel:read:subscriptions channel:read:hype_train channel:read:follows";
        }
      }

      // Now use scopeValue in the URL
      const authUrl = new URL("https://id.twitch.tv/oauth2/authorize");
      authUrl.searchParams.set(
        "client_id",
        await retrieveConfigValue("twitch.clientId")
      );
      authUrl.searchParams.set(
        "redirect_uri",
        await retrieveConfigValue("twitch.redirectUri")
      );
      authUrl.searchParams.set("response_type", "code");
      authUrl.searchParams.set("scope", scopeValue);
      authUrl.searchParams.set("state", authToken);
      if (auth_type === "bot") {
        authUrl.searchParams.set("force_verify", "true");
      }
      return reply.redirect(authUrl.toString());
    } catch (error) {
      logger.error(
        "Auth",
        `Error during Twitch authentication: ${error.message}`
      );
      return reply
        .code(500)
        .send({ error: "Authentication error", details: error.message });
    }
  });

  // 3. Callback from Twitch OAuth
  fastify.get("/auth/twitch/callback", async (request, reply) => {
    const { code, state } = request.query;

    // Verify state token exists in our pending auths
    if (!global.pendingTwitchAuths || !global.pendingTwitchAuths.has(state)) {
      return reply.code(400).send("Invalid or expired authorization request");
    }

    // Get user ID from the stored mapping
    const { userId, createdAt, authType } =
      global.pendingTwitchAuths.get(state);

    // Check if the token has expired (e.g., after 10 minutes)
    if (Date.now() - createdAt > 10 * 60 * 1000) {
      global.pendingTwitchAuths.delete(state);
      return reply.code(400).send("Authorization request expired");
    }

    try {
      const axios = (await import("axios")).default;
      // Exchange code for access token
      const tokenResponse = await axios.post(
        "https://id.twitch.tv/oauth2/token",
        {
          client_id: await retrieveConfigValue("twitch.clientId"),
          client_secret: await retrieveConfigValue("twitch.clientSecret"),
          code,
          grant_type: "authorization_code",
          redirect_uri: await retrieveConfigValue("twitch.redirectUri"),
        }
      );

      const { access_token, refresh_token, expires_in } = tokenResponse.data;

      // Get user info from Twitch
      const userResponse = await axios.get(
        "https://api.twitch.tv/helix/users",
        {
          headers: {
            "Client-ID": await retrieveConfigValue("twitch.clientId"),
            Authorization: `Bearer ${access_token}`,
          },
        }
      );

      const twitchUserInfo = userResponse.data.data[0];

      // Store tokens in user record - use the appropriate field based on auth type
      const tokenPath =
        authType === "bot" ? "twitch_tokens.bot" : "twitch_tokens.streamer";

      await updateUserParameter(userId, tokenPath, {
        access_token,
        refresh_token,
        expires_at: Date.now() + expires_in * 1000,
        twitch_user_id: twitchUserInfo.id,
        twitch_login: twitchUserInfo.login,
        twitch_display_name: twitchUserInfo.display_name,
      });

      // Clean up the pending auth
      global.pendingTwitchAuths.delete(state);

      // Redirect back to the management page
      return reply.redirect("/web/dashboard");
    } catch (error) {
      logger.log(
        "Auth",
        `Error during Twitch token exchange: ${error.message}`
      );
      return reply.code(500).send("Failed to complete Twitch authorization");
    }
  });

  function getFieldValue(field) {
    if (!field) return "";

    // If the field is a Part object from @fastify/multipart
    if (field.value !== undefined) {
      return field.value;
    }

    // If the field is already a string
    if (typeof field === "string") {
      return field;
    }

    // If the field is a readable stream (file upload)
    if (field.pipe && typeof field.pipe === "function") {
      // For this implementation, we're not handling file uploads
      // If needed, use stream handling here
      return "";
    }

    // Return empty string for any other case
    return "";
  }

  // Character personality update endpoint
  fastify.post(
    "/character/personality",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Extract values safely from multipart form data
        const botName = getFieldValue(request.body.bot_name);
        const personality = getFieldValue(request.body.personality);

        // Update bot name in user record
        await updateUserParameter(user.user_id, "bot_name", botName);

        // Save personality to file
        const success = await saveTextContent(
          user.user_id,
          "character_personality",
          personality
        );

        if (success) {
          reply.send({
            success: true,
            message: "Personality updated successfully",
          });
        } else {
          reply
            .code(500)
            .send({ success: false, error: "Failed to save personality" });
        }
      } catch (error) {
        logger.error("Web", `Error updating personality: ${error.message}`);
        reply.code(500).send({
          success: false,
          error: "An error occurred while updating personality",
        });
      }
    }
  );

  // Character description update endpoint
  fastify.post(
    "/character/description",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Extract values safely from multipart form data
        const description = getFieldValue(request.body.description);
        const botTwitch = getFieldValue(request.body.bot_twitch);

        // Save description to file
        const success = await saveTextContent(
          user.user_id,
          "character_card",
          description
        );

        // Update bot_twitch if provided
        if (botTwitch) {
          await updateUserParameter(user.user_id, "bot_twitch", botTwitch);
        }

        if (success) {
          reply.send({
            success: true,
            message: "Description updated successfully",
          });
        } else {
          reply
            .code(500)
            .send({ success: false, error: "Failed to save description" });
        }
      } catch (error) {
        logger.error("Web", `Error updating description: ${error.message}`);
        reply.code(500).send({
          success: false,
          error: "An error occurred while updating description",
        });
      }
    }
  );

  // Character examples update endpoint
  fastify.post(
    "/character/examples",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Extract value safely from multipart form data
        const examples = getFieldValue(request.body.examples);

        // Save examples to file
        const success = await saveTextContent(
          user.user_id,
          "examples",
          examples
        );

        if (success) {
          reply.send({
            success: true,
            message: "Examples updated successfully",
          });
        } else {
          reply
            .code(500)
            .send({ success: false, error: "Failed to save examples" });
        }
      } catch (error) {
        logger.error("Web", `Error updating examples: ${error.message}`);
        reply.code(500).send({
          success: false,
          error: "An error occurred while updating examples",
        });
      }
    }
  );

  // World info update endpoint
  fastify.post(
    "/world/info",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Extract values safely from multipart form data
        const worldInfo = getFieldValue(request.body.world_info);
        const weatherEnabled = getFieldValue(request.body.weather_enabled);

        // Update weather flag in user record
        await updateUserParameter(
          user.user_id,
          "weather",
          weatherEnabled === "true"
        );

        // Save world info to file
        const success = await saveTextContent(
          user.user_id,
          "world_lore",
          worldInfo
        );

        if (success) {
          reply.send({
            success: true,
            message: "World information updated successfully",
          });
        } else {
          reply.code(500).send({
            success: false,
            error: "Failed to save world information",
          });
        }
      } catch (error) {
        logger.error("Web", `Error updating world info: ${error.message}`);
        reply.code(500).send({
          success: false,
          error: "An error occurred while updating world information",
        });
      }
    }
  );

  // Player info update endpoint
  fastify.post(
    "/world/player",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Extract values safely from multipart form data
        const playerInfo = getFieldValue(request.body.player_info);
        const commandsList = getFieldValue(request.body.commands_list);

        // Update commands list in user record if provided
        if (commandsList) {
          const commandsArray = commandsList
            .split("\n")
            .map((cmd) => cmd.trim())
            .filter((cmd) => cmd.length > 0);
          await updateUserParameter(
            user.user_id,
            "commands_list",
            commandsArray
          );
        }

        // Save player info to file
        const success = await saveTextContent(
          user.user_id,
          "player_info",
          playerInfo
        );

        if (success) {
          reply.send({
            success: true,
            message: "Player information updated successfully",
          });
        } else {
          reply.code(500).send({
            success: false,
            error: "Failed to save player information",
          });
        }
      } catch (error) {
        logger.error("Web", `Error updating player info: ${error.message}`);
        reply.code(500).send({
          success: false,
          error: "An error occurred while updating player information",
        });
      }
    }
  );

  // Scenario update endpoint
  fastify.post(
    "/world/scenario",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Extract values safely from multipart form data
        const scenario = getFieldValue(request.body.scenario);
        const auxBots = getFieldValue(request.body.aux_bots);

        // Update aux bots list in user record if provided
        if (auxBots) {
          const auxBotsArray = auxBots
            .split("\n")
            .map((bot) => bot.trim())
            .filter((bot) => bot.length > 0);
          await updateUserParameter(user.user_id, "aux_bots", auxBotsArray);
        }

        // Save scenario to file
        const success = await saveTextContent(
          user.user_id,
          "scenario",
          scenario
        );

        if (success) {
          reply.send({
            success: true,
            message: "Scenario updated successfully",
          });
        } else {
          reply
            .code(500)
            .send({ success: false, error: "Failed to save scenario" });
        }
      } catch (error) {
        logger.error("Web", `Error updating scenario: ${error.message}`);
        reply.code(500).send({
          success: false,
          error: "An error occurred while updating scenario",
        });
      }
    }
  );

  // Bot configuration update endpoint
  fastify.post(
    "/world/bot-config",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Extract values safely from multipart form data
        const commandsList = getFieldValue(request.body.commands_list);
        const auxBots = getFieldValue(request.body.aux_bots);

        // Update commands list in user record
        const commandsArray = commandsList
          .split("\n")
          .map((cmd) => cmd.trim())
          .filter((cmd) => cmd.length > 0);

        await updateUserParameter(user.user_id, "commands_list", commandsArray);

        // Update aux bots list in user record
        const auxBotsArray = auxBots
          .split("\n")
          .map((bot) => bot.trim())
          .filter((bot) => bot.length > 0);

        await updateUserParameter(user.user_id, "aux_bots", auxBotsArray);

        reply.send({
          success: true,
          message: "Bot configuration updated successfully",
        });
      } catch (error) {
        logger.error(
          "Web",
          `Error updating bot configuration: ${error.message}`
        );
        reply.code(500).send({
          success: false,
          error: "An error occurred while updating bot configuration",
        });
      }
    }
  );
  // Preferences settings update endpoint
  fastify.post(
    "/settings/preferences",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Extract values from form data
        const storeAllChat =
          getFieldValue(request.body.store_all_chat) === "true";
        const ttsEnabled = getFieldValue(request.body.tts_enabled) === "true";
        const ttsEqPref = getFieldValue(request.body.ttsEqPref);
        const ttsUpsamplePref =
          getFieldValue(request.body.ttsUpsamplePref) === "true";

        // Update user parameters
        await updateUserParameter(user.user_id, "store_all_chat", storeAllChat);
        await updateUserParameter(user.user_id, "tts_enabled", ttsEnabled);
        await updateUserParameter(user.user_id, "ttsEqPref", ttsEqPref);
        await updateUserParameter(
          user.user_id,
          "ttsUpsamplePref",
          ttsUpsamplePref
        );

        return reply.send({
          success: true,
          message: "Preferences updated successfully",
        });
      } catch (error) {
        logger.error("Web", `Error updating preferences: ${error.message}`);
        return reply.code(500).send({
          success: false,
          error: "An error occurred while updating preferences",
        });
      }
    }
  );
  fastify.post(
    "/gallery/:characterId/use",
    { preHandler: requireAuth },
    async (request, reply) => {
      const { user } = request;
      const { characterId } = request.params;

      try {
        const preset = await loadPreset(characterId);
        if (!preset) {
          return reply
            .code(404)
            .send({ success: false, error: "Character preset not found" });
        }

        logger.log(
          "Web",
          `Applying character preset: ${preset.name} (${characterId}) for user ${user.user_id}`
        );

        // Extract the internal format for saving to user files
        const personalityContent =
          preset.personality.internalFmt || preset.personality || "";
        const descriptionContent =
          preset.char_description.internalFmt || preset.char_description || "";

        // Apply the preset data to the user
        const nameUpdate = await updateUserParameter(
          user.user_id,
          "bot_name",
          preset.name
        );

        // Save personality and description to files
        const personalitySave = await saveTextContent(
          user.user_id,
          "character_personality",
          personalityContent
        );
        const descriptionSave = await saveTextContent(
          user.user_id,
          "character_card",
          descriptionContent
        );

        // Make sure bot_twitch is set if present in the preset
        if (preset.bot_twitch) {
          await updateUserParameter(
            user.user_id,
            "bot_twitch",
            preset.bot_twitch
          );
        }

        if (nameUpdate && personalitySave && descriptionSave) {
          logger.log(
            "Web",
            `Successfully applied preset '${characterId}' for user ${user.user_id}`
          );

          // Respond with success and a redirect URL for the frontend handler
          return reply.send({
            success: true,
            message: `Character preset "${preset.name}" applied successfully!`,
            redirect: "/web/character",
          });
        } else {
          logger.error(
            "Web",
            `Failed to fully apply preset '${characterId}' for user ${user.user_id}`
          );
          return reply.code(500).send({
            success: false,
            error: "Failed to save all character data",
          });
        }
      } catch (error) {
        logger.error(
          "Web",
          `Error applying preset '${characterId}' for user ${user.user_id}: ${error.message}`
        );
        return reply.code(500).send({
          success: false,
          error: "An error occurred while applying the preset",
        });
      }
    }
  );
}

/**
 * Lightweight WAV file parser that doesn't require audio output devices
 * @param {Buffer} buffer - The WAV file buffer to analyze
 * @returns {Object} - Validation result with audio properties
 */
async function validateWavBuffer(buffer) {
  try {
    // Log the buffer size for debugging
    logger.log("Audio", `Analyzing WAV buffer of size: ${buffer.length} bytes`);

    // Check if the buffer is valid and has enough bytes for a WAV header
    if (!buffer || buffer.length < 44) {
      return {
        valid: false,
        reason: "Invalid WAV file: too small or corrupted"
      };
    }

    // Check WAV header magic bytes (RIFF....WAVE)
    const isRiff = buffer.slice(0, 4).toString() === 'RIFF';
    const isWave = buffer.slice(8, 12).toString() === 'WAVE';

    if (!isRiff || !isWave) {
      logger.error("Audio", `Invalid WAV header: RIFF=${isRiff}, WAVE=${isWave}`);
      return {
        valid: false,
        reason: "Invalid WAV file: incorrect format"
      };
    }

    // Find the 'fmt ' chunk
    let offset = 12; // Start after "WAVE"
    let fmtChunkFound = false;

    // Parse all chunks until we find 'fmt '
    while (offset < buffer.length - 8) {
      const chunkId = buffer.slice(offset, offset + 4).toString();
      const chunkSize = buffer.readUInt32LE(offset + 4);

      if (chunkId === 'fmt ') {
        fmtChunkFound = true;
        break;
      }

      offset += 8 + chunkSize;
    }

    if (!fmtChunkFound) {
      logger.error("Audio", "WAV file missing 'fmt ' chunk");
      return {
        valid: false,
        reason: "Invalid WAV file: missing format information"
      };
    }

    // Now parse the format chunk
    offset += 8; // Skip chunk ID and size

    // Audio format (PCM = 1)
    const audioFormat = buffer.readUInt16LE(offset);

    // Number of channels
    const numChannels = buffer.readUInt16LE(offset + 2);

    // Sample rate
    const sampleRate = buffer.readUInt32LE(offset + 4);

    // Bytes per second
    const byteRate = buffer.readUInt32LE(offset + 8);

    // Bits per sample
    const bitsPerSample = buffer.readUInt16LE(offset + 14);

    // Find data chunk to calculate duration
    let dataSize = 0;
    offset = 12; // Reset to start after "WAVE"

    while (offset < buffer.length - 8) {
      const chunkId = buffer.slice(offset, offset + 4).toString();
      const chunkSize = buffer.readUInt32LE(offset + 4);

      if (chunkId === 'data') {
        dataSize = chunkSize;
        break;
      }

      offset += 8 + chunkSize;
    }

    // Calculate duration
    const bytesPerSample = bitsPerSample / 8;
    const totalSamples = dataSize / (bytesPerSample * numChannels);
    const duration = totalSamples / sampleRate;

    // Log the results
    logger.log("Audio", `WAV analysis: format=${audioFormat}, channels=${numChannels}, sampleRate=${sampleRate}Hz, bitsPerSample=${bitsPerSample}, duration=${duration.toFixed(2)}s`);

    // Validate requirements
    if (numChannels !== 1) {
      return {
        valid: false,
        reason: `Audio must be mono (found ${numChannels} channels)`
      };
    }

    // Accept common sample rates: 22050Hz, 44100Hz, 48000Hz
    const acceptableSampleRates = [22050, 44100, 48000];
    const closestRate = acceptableSampleRates.reduce((prev, curr) =>
      (Math.abs(curr - sampleRate) < Math.abs(prev - sampleRate) ? curr : prev)
    );

    // Allow more variance (within 10% of target rate)
    if (Math.abs(sampleRate - closestRate) / closestRate > 0.1) {
      logger.warn("Audio", `Unusual sample rate detected: ${sampleRate}Hz, closest standard rate: ${closestRate}Hz`);
      // We'll still accept it and let the voice API handle resampling
    }

    if (duration > 20) {
      return {
        valid: false,
        reason: `Duration exceeds 20 seconds (${duration.toFixed(1)}s)`
      };
    }

    // Return all the parsed information
    return {
      valid: true,
      sampleRate,
      numChannels,
      bitsPerSample,
      duration,
      format: audioFormat === 1 ? "PCM" : "Non-PCM",
      closestStandardRate: closestRate
    };
  } catch (error) {
    logger.error("Audio", `Error analyzing WAV file: ${error.message}`);
    return {
      valid: false,
      reason: `Failed to analyze WAV file: ${error.message}`
    };
  }
}

/**
 * Saves text content to a file
 * @param {string} userId - The user ID
 * @param {string} fileName - The file name
 * @param {string} content - The content to save
 * @returns {Promise<boolean>} - True if successful, false otherwise
 */
export async function saveTextContent(userId, fileName, content) {
  try {
    const filePath = path.join(
      process.cwd(),
      "world_info",
      userId,
      `${fileName}.txt`
    );

    // Create directory if it doesn't exist
    await fs.ensureDir(path.join(process.cwd(), "world_info", userId));

    // Write content to file
    await fs.writeFile(filePath, content);
    return true;
  } catch (error) {
    logger.error(
      "Web",
      `Error saving ${fileName} for user ${userId}: ${error.message}`
    );
    return false;
  }
}

export async function hashPassword(password) {
  return new Promise((resolve, reject) => {
    try {
      const salt = crypto.randomBytes(128).toString("base64");
      const iterations = 20480;
      const keylen = 64;
      const digest = "sha512";

      crypto.pbkdf2(
        password,
        salt,
        iterations,
        keylen,
        digest,
        (err, derivedKey) => {
          if (err) {
            reject(err);
            return;
          }

          resolve({
            salt: salt,
            hash: derivedKey.toString("hex"),
            iterations: iterations,
            digest: digest,
          });
        }
      );
    } catch (error) {
      reject(error);
    }
  });
}

export async function isPasswordCorrect(
  savedHash,
  savedSalt,
  savedIterations,
  passwordAttempt
) {
  // Validate parameters
  if (!savedHash || !savedSalt || !passwordAttempt) {
    throw new Error("Missing required parameters for password verification");
  }

  // Ensure all parameters are strings
  savedHash = String(savedHash);
  savedSalt = String(savedSalt);
  passwordAttempt = String(passwordAttempt);

  // Ensure iterations is a number
  const iterations = Number(savedIterations) || 20480;

  return new Promise((resolve, reject) => {
    try {
      const digest = "sha512";
      const keylen = 64;

      crypto.pbkdf2(
        passwordAttempt,
        savedSalt,
        iterations,
        keylen,
        digest,
        (err, derivedKey) => {
          if (err) {
            reject(err);
            return;
          }

          const hash = derivedKey.toString("hex");
          resolve(savedHash === hash);
        }
      );
    } catch (error) {
      reject(error);
    }
  });
}

async function configureResponseHandling(fastify) {
  if (fastify.hasPlugin("fastify-compress")) {
    logger.log(
      "API",
      "Compression plugin already registered, updating configuration"
    );
  }

  // Configure response timeouts if server is available
  if (fastify.server) {
    // Use safer timeout values
    if (typeof fastify.server.keepAliveTimeout === "number") {
      fastify.server.keepAliveTimeout = 120000; // 2 minutes
    }
    if (typeof fastify.server.headersTimeout === "number") {
      fastify.server.headersTimeout = 65000; // Just above default 60s
    }
  }

  // Add hook to handle large responses - this should work regardless of server setup
  fastify.addHook("onRequest", (request, reply, done) => {
    // Set default headers for all responses
    reply.header("Content-Type", "application/json; charset=utf-8");
    done();
  });

  // Add response monitoring middleware
  fastify.addHook("onSend", (request, reply, payload, done) => {
    // For debugging, log payload size
    if (payload) {
      const size =
        typeof payload === "json"
          ? payload.length
          : JSON.stringify(payload).length;
      logger.log(
        "API",
        `Response payload size: ${size} bytes for ${request.url}`
      );

      // Check for suspiciously small payloads
      if (
        size < 5 &&
        request.method !== "HEAD" &&
        request.method !== "OPTIONS"
      ) {
        logger.log(
          "API",
          `WARNING: Very small response detected for ${request.url}: ${payload}`
        );
      }
    }

    // Make sure content type is set
    if (!reply.getHeader("content-type")) {
      reply.header("Content-Type", "application/json; charset=utf-8");
    }

    done(null, payload);
  });

  // Add a simple response helper method to the reply object
  fastify.decorateReply("sendSafe", function (data) {
    // If the data is already a string, use it directly
    if (typeof data === "string") {
      return this.type("text/plain; charset=utf-8").send(data);
    }

    try {
      // Try to stringify the data safely
      const safeJSON = JSON.stringify(data);
      return this.type("application/json; charset=utf-8").send(safeJSON);
    } catch (error) {
      logger.log("API", `Error stringifying response: ${error.message}`);
      // Send a fallback response
      return this.code(500).send(
        JSON.stringify({
          error: "Error generating response",
          message: "Failed to serialize response data",
        })
      );
    }
  });

  logger.log("API", "Response handling configuration completed");
}

/**
 * Load all character presets from the presets directory
 * @returns {Promise<Array>} Array of character preset objects
 */
export async function loadAllPresets() {
  try {
    const presetsDir = path.join(process.cwd(), "presets");

    // Make sure the directory exists
    await fs.ensureDir(presetsDir);

    const files = await fs.readdir(presetsDir);

    // Only process JSON files
    const jsonFiles = files.filter((file) => file.endsWith(".json"));

    // If no presets found, return empty array
    if (jsonFiles.length === 0) {
      logger.log("Web", "No character presets found in presets directory");
      return [];
    }

    // Load each preset file
    const presets = await Promise.all(
      jsonFiles.map(async (file) => {
        try {
          const filePath = path.join(presetsDir, file);
          const data = await fs.readFile(filePath, "utf8");
          const preset = JSON.parse(data);

          // Add the filename (without extension) as an ID
          preset.id = path.basename(file, ".json");

          // Handle basic preset fields
          preset.name = preset.name || "Unnamed Character";
          preset.author = preset.author || "Unknown Author";
          preset.summary = preset.summary || "No description provided.";

          // Handle nested personality structure
          if (
            typeof preset.personality === "object" &&
            preset.personality !== null
          ) {
            // Already using new format
            preset.personality.internalFmt =
              preset.personality.internalFmt || "";
            preset.personality.publicFmt = preset.personality.publicFmt || "";
          } else if (typeof preset.personality === "string") {
            // Convert old format to new
            const personalityText = preset.personality;
            preset.personality = {
              internalFmt: personalityText,
              publicFmt: personalityText,
            };
          } else {
            // Initialize with empty values
            preset.personality = {
              internalFmt: "",
              publicFmt: "",
            };
          }

          // Handle nested character description structure
          if (
            typeof preset.char_description === "object" &&
            preset.char_description !== null
          ) {
            // Already using new format
            preset.char_description.internalFmt =
              preset.char_description.internalFmt || "";
            preset.char_description.publicFmt =
              preset.char_description.publicFmt || "";
          } else if (typeof preset.char_description === "string") {
            // Convert old format to new
            const descriptionText = preset.char_description;
            preset.char_description = {
              internalFmt: descriptionText,
              publicFmt: descriptionText,
            };
          } else {
            // Initialize with empty values
            preset.char_description = {
              internalFmt: "",
              publicFmt: "",
            };
          }

          // Default image if not present
          if (!preset.image) {
            preset.image = "/api/placeholder/200/200";
          }

          return preset;
        } catch (err) {
          logger.error("Web", `Error loading preset ${file}: ${err.message}`);
          return null;
        }
      })
    );

    // Filter out any null results from failed loads
    return presets.filter((preset) => preset !== null);
  } catch (error) {
    logger.error("Web", `Error loading presets: ${error.message}`);
    // Return empty array instead of throwing, to show empty gallery
    return [];
  }
}

/**
 * Load a specific character preset by name
 * @param {string} characterId - ID of the character (filename without .json)
 * @returns {Promise<Object|null>} Character preset object or null if not found
 */
export async function loadPreset(characterId) {
  try {
    const filePath = path.join(process.cwd(), "presets", `${characterId}.json`);

    // Check if file exists
    const exists = await fs.pathExists(filePath);
    if (!exists) {
      logger.warn(
        "Web",
        `Character preset file not found: ${characterId}.json`
      );
      return null;
    }

    const data = await fs.readFile(filePath, "utf8");
    const preset = JSON.parse(data);

    // Add the characterId as an ID
    preset.id = characterId;

    // Handle basic preset fields
    preset.name = preset.name || "Unnamed Character";
    preset.author = preset.author || "Unknown Author";
    preset.summary = preset.summary || "No description provided.";

    // Handle nested personality structure
    if (typeof preset.personality === "object" && preset.personality !== null) {
      // Already using new format
      preset.personality.internalFmt = preset.personality.internalFmt || "";
      preset.personality.publicFmt = preset.personality.publicFmt || "";
    } else if (typeof preset.personality === "string") {
      // Convert old format to new
      const personalityText = preset.personality;
      preset.personality = {
        internalFmt: personalityText,
        publicFmt: personalityText,
      };
    } else {
      // Initialize with empty values
      preset.personality = {
        internalFmt: "",
        publicFmt: "",
      };
    }

    // Handle nested character description structure
    if (
      typeof preset.char_description === "object" &&
      preset.char_description !== null
    ) {
      // Already using new format
      preset.char_description.internalFmt =
        preset.char_description.internalFmt || "";
      preset.char_description.publicFmt =
        preset.char_description.publicFmt || "";
    } else if (typeof preset.char_description === "string") {
      // Convert old format to new
      const descriptionText = preset.char_description;
      preset.char_description = {
        internalFmt: descriptionText,
        publicFmt: descriptionText,
      };
    } else {
      // Initialize with empty values
      preset.char_description = {
        internalFmt: "",
        publicFmt: "",
      };
    }

    // Default image if not present
    if (!preset.image) {
      preset.image = "/api/placeholder/200/200";
    }

    return preset;
  } catch (error) {
    if (error.code === "ENOENT") {
      // File not found
      return null;
    }
    logger.error(
      "Web",
      `Error loading preset ${characterId}: ${error.message}`
    );
    return null;
  }
}

export default routes;
</file>

</files>
