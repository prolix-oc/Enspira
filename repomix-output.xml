This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/*.log, tmp/, node_modules/*, package-lock.json, *.lock, *.md, **/*.mtn
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
auth/
  auth_keys.example.json
config/
  config.example.json
routes/
  audio.js
  twitch.js
  v1.js
  web.js
utils/
  api-utils.js
  cache-utils.js
  error-utils.js
  file-utils.js
  index.js
  string-utils.js
views/
  character-details.njk
  character.njk
  dashboard.njk
  gallery.njk
  help.njk
  layout.njk
  login.njk
  settings.njk
  twitch-health.njk
  world.njk
.cache_ggshield
.gitignore
ai-logic.js
api-helper.js
audio-processor.js
chat-handler.js
config-helper.js
create-global-logger.js
data-helper.js
debug-mention-detection.js
expression-parser.js
index.js
logger.js
main.js
mongodb-client.js
oai-requests.js
package.json
prompt-helper.js
response-monitor.js
restart-helper.js
setup-alternate-spelling.js
start.bat
template-engine.js
token-helper.js
twitch-eventsub-manager.js
twitch-helper.js
twitch-webhook-tester.js
websocket-test-client.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="views/twitch-health.njk">
const twitchHealthDashboard = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Twitch Health Dashboard - Enspira</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #1a1a1a; color: #fff; }
        .dashboard { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
        .card { background: #2a2a2a; border-radius: 8px; padding: 20px; border-left: 4px solid #9146ff; }
        .healthy { border-left-color: #00ff88; }
        .warning { border-left-color: #ffaa00; }
        .error { border-left-color: #ff4444; }
        .metric { display: flex; justify-content: space-between; margin: 10px 0; }
        .metric-value { font-weight: bold; color: #9146ff; }
        .status-indicator { display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 8px; }
        .status-healthy { background: #00ff88; }
        .status-warning { background: #ffaa00; }
        .status-error { background: #ff4444; }
        h2 { margin-top: 0; color: #9146ff; }
        .refresh-btn { background: #9146ff; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; }
        .refresh-btn:hover { background: #7c3aed; }
        .timestamp { color: #888; font-size: 0.9em; }
    </style>
</head>
<body>
    <h1>🟣 Twitch Health Dashboard</h1>
    <button class="refresh-btn" onclick="location.reload()">Refresh Data</button>
    
    <div class="dashboard" id="dashboard">
        <div class="card">
            <h2>Loading...</h2>
            <p>Please wait while we fetch the latest health data.</p>
        </div>
    </div>

    <script>
        async function loadHealthData() {
            try {
                const response = await fetch('/api/v1/twitch/health?detailed=true');
                const data = await response.json();
                
                updateDashboard(data);
            } catch (error) {
                console.error('Failed to load health data:', error);
                document.getElementById('dashboard').innerHTML = 
                    '<div class="card error"><h2>Error</h2><p>Failed to load health data</p></div>';
            }
        }
        
        function updateDashboard(data) {
            const dashboard = document.getElementById('dashboard');
            const healthClass = data.overall === 'healthy' ? 'healthy' : 
                               data.overall === 'degraded' ? 'warning' : 'error';
            
            dashboard.innerHTML = \`
                <div class="card \${healthClass}">
                    <h2>
                        <span class="status-indicator status-\${data.overall === 'healthy' ? 'healthy' : 
                              data.overall === 'degraded' ? 'warning' : 'error'}"></span>
                        System Health
                    </h2>
                    <div class="metric">
                        <span>Overall Status:</span>
                        <span class="metric-value">\${data.overall.toUpperCase()}</span>
                    </div>
                    <div class="metric">
                        <span>Uptime:</span>
                        <span class="metric-value">\${formatUptime(data.uptime)}</span>
                    </div>
                    <div class="metric">
                        <span>Memory Usage:</span>
                        <span class="metric-value">\${(data.memoryUsage.heapUsed / 1024 / 1024).toFixed(1)} MB</span>
                    </div>
                    <div class="timestamp">Updated: \${new Date(data.timestamp).toLocaleString()}</div>
                </div>
                
                <div class="card">
                    <h2>Event Processing</h2>
                    <div class="metric">
                        <span>Events Processed:</span>
                        <span class="metric-value">\${data.twitch.events.eventsProcessed || 0}</span>
                    </div>
                    <div class="metric">
                        <span>Success Rate:</span>
                        <span class="metric-value">\${data.twitch.events.successRate || '100%'}</span>
                    </div>
                    <div class="metric">
                        <span>Avg Response Time:</span>
                        <span class="metric-value">\${data.twitch.events.averageResponseTime || 0}ms</span>
                    </div>
                    <div class="metric">
                        <span>Chat Messages:</span>
                        <span class="metric-value">\${data.twitch.events.chatMessagesProcessed || 0}</span>
                    </div>
                </div>
                
                \${data.twitch.api ? \`
                <div class="card">
                    <h2>API Health</h2>
                    <div class="metric">
                        <span>Total Requests:</span>
                        <span class="metric-value">\${data.twitch.api.totalRequests}</span>
                    </div>
                    <div class="metric">
                        <span>Success Rate:</span>
                        <span class="metric-value">\${data.twitch.api.successRate}</span>
                    </div>
                    <div class="metric">
                        <span>Rate Limit Violations:</span>
                        <span class="metric-value">Helix: \${data.twitch.api.rateLimitViolations.helix}, Auth: \${data.twitch.api.rateLimitViolations.auth}</span>
                    </div>
                </div>
                \` : ''}
            \`;
        }
        
        function formatUptime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            return \`\${hours}h \${minutes}m\`;
        }
        
        // Load data on page load
        loadHealthData();
        
        // Auto-refresh every 30 seconds
        setInterval(loadHealthData, 30000);
    </script>
</body>
</html>
`;

// Export everything for use in other modules
export { 
  TwitchAlertSystem, 
  setupEnhancedTwitchCronJobs, 
  twitchHealthDashboard 
};
</file>

<file path="debug-mention-detection.js">
// debug-mention-detection.js
// Utility script to test and debug mention detection
import { returnAuthObject } from './api-helper.js';
import { logger } from './create-global-logger.js';

/**
 * Helper function to escape special regex characters
 * @param {string} string - String to escape
 * @returns {string} - Escaped string safe for regex
 */
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Enhanced containsCharacterName function with debugging
 * @param {string} message - The message to check.
 * @param {string} userId - The user ID.
 * @returns {Promise<object>} - Result with debug information
 */
async function debugContainsCharacterName(message, userId) {
  try {
    const userObj = await returnAuthObject(userId);
    
    const debugInfo = {
      message: message,
      userId: userId,
      userObj: {
        bot_name: userObj.bot_name,
        bot_twitch: userObj.bot_twitch,
        twitch_tokens: {
          bot: userObj.twitch_tokens?.bot ? {
            twitch_login: userObj.twitch_tokens.bot.twitch_login,
            twitch_display_name: userObj.twitch_tokens.bot.twitch_display_name
          } : null,
          streamer: userObj.twitch_tokens?.streamer ? {
            twitch_login: userObj.twitch_tokens.streamer.twitch_login,
            twitch_display_name: userObj.twitch_tokens.streamer.twitch_display_name
          } : null
        }
      },
      namesToCheck: [],
      matchResults: [],
      finalResult: false
    };
    
    if (!message || typeof message !== 'string') {
      debugInfo.error = 'Invalid message';
      return debugInfo;
    }

    const normalizedMessage = message.toLowerCase().trim();
    debugInfo.normalizedMessage = normalizedMessage;
    
    // Get all possible name variations
    const namesToCheck = new Set();
    
    // Add character/bot name
    if (userObj.bot_name) {
      namesToCheck.add(userObj.bot_name.toLowerCase());
    }
    
    // Add Twitch bot username variations
    if (userObj.bot_twitch) {
      const botTwitch = userObj.bot_twitch.toLowerCase();
      namesToCheck.add(botTwitch);
      // Remove @ if present and add both versions
      const cleanBotTwitch = botTwitch.startsWith('@') ? botTwitch.slice(1) : botTwitch;
      namesToCheck.add(cleanBotTwitch);
      namesToCheck.add('@' + cleanBotTwitch);
    }
    
    // Add the actual bot account username from tokens if available
    if (userObj.twitch_tokens?.bot?.twitch_login) {
      const botLogin = userObj.twitch_tokens.bot.twitch_login.toLowerCase();
      namesToCheck.add(botLogin);
      namesToCheck.add('@' + botLogin);
    }
    
    if (userObj.twitch_tokens?.bot?.twitch_display_name) {
      const botDisplayName = userObj.twitch_tokens.bot.twitch_display_name.toLowerCase();
      namesToCheck.add(botDisplayName);
      namesToCheck.add('@' + botDisplayName);
    }
    
    // Also check against streamer account in case bot_twitch points to streamer
    if (userObj.twitch_tokens?.streamer?.twitch_login) {
      const streamerLogin = userObj.twitch_tokens.streamer.twitch_login.toLowerCase();
      namesToCheck.add(streamerLogin);
      namesToCheck.add('@' + streamerLogin);
    }
    
    // Remove empty/undefined entries
    const validNames = Array.from(namesToCheck).filter(name => name && name.length > 0);
    debugInfo.namesToCheck = validNames;
    
    if (validNames.length === 0) {
      debugInfo.error = 'No valid bot names found';
      return debugInfo;
    }
    
    // Check each name variation
    for (const nameToCheck of validNames) {
      const testResult = {
        name: nameToCheck,
        wordBoundaryMatch: false,
        atMentionMatch: false,
        matched: false
      };
      
      // Exact word match (handles @mentions and regular mentions)
      const wordBoundaryRegex = new RegExp(`\\b${escapeRegExp(nameToCheck)}\\b`, 'i');
      testResult.wordBoundaryMatch = wordBoundaryRegex.test(normalizedMessage);
      testResult.wordBoundaryRegex = wordBoundaryRegex.toString();
      
      // Also check for @ mentions without word boundaries (for usernames with special chars)
      if (nameToCheck.startsWith('@')) {
        const atMentionRegex = new RegExp(`${escapeRegExp(nameToCheck)}`, 'i');
        testResult.atMentionMatch = atMentionRegex.test(normalizedMessage);
        testResult.atMentionRegex = atMentionRegex.toString();
      }
      
      testResult.matched = testResult.wordBoundaryMatch || testResult.atMentionMatch;
      
      if (testResult.matched) {
        debugInfo.finalResult = true;
      }
      
      debugInfo.matchResults.push(testResult);
    }
    
    return debugInfo;
  } catch (error) {
    return {
      message: message,
      userId: userId,
      error: error.message,
      finalResult: false
    };
  }
}

/**
 * Test multiple messages against mention detection
 * @param {string} userId - The user ID to test against
 * @param {string[]} testMessages - Array of test messages
 */
async function testMentionDetection(userId, testMessages = []) {
  console.log(`\n=== Testing Mention Detection for User ${userId} ===\n`);
  
  // Default test messages if none provided
  if (testMessages.length === 0) {
    testMessages = [
      "Hello Layla",
      "@Layla how are you?",
      "Hey layla, what's up?",
      "Layla, can you help me?",
      "I think Layla is great",
      "Not mentioning anyone here",
      "This is just a regular message",
      "@layla123",
      "LAYLA!!"
    ];
  }
  
  for (const message of testMessages) {
    console.log(`\nTesting: "${message}"`);
    console.log('─'.repeat(50));
    
    const result = await debugContainsCharacterName(message, userId);
    
    console.log(`Result: ${result.finalResult ? '✅ MATCH' : '❌ NO MATCH'}`);
    
    if (result.error) {
      console.log(`Error: ${result.error}`);
      continue;
    }
    
    console.log(`Names checked: ${result.namesToCheck.join(', ')}`);
    
    // Show detailed match results
    result.matchResults.forEach(matchResult => {
      if (matchResult.matched) {
        console.log(`  ✅ "${matchResult.name}" matched`);
        if (matchResult.wordBoundaryMatch) {
          console.log(`     - Word boundary: ${matchResult.wordBoundaryRegex}`);
        }
        if (matchResult.atMentionMatch) {
          console.log(`     - @ mention: ${matchResult.atMentionRegex}`);
        }
      }
    });
  }
  
  console.log('\n=== Test Complete ===\n');
}

/**
 * Debug user configuration for mention detection
 * @param {string} userId - The user ID to debug
 */
async function debugUserConfiguration(userId) {
  try {
    console.log(`\n=== User Configuration Debug for ${userId} ===\n`);
    
    const userObj = await returnAuthObject(userId);
    
    if (!userObj) {
      console.log('❌ User not found');
      return;
    }
    
    console.log('Bot Configuration:');
    console.log(`  bot_name: "${userObj.bot_name || 'NOT SET'}"`);
    console.log(`  bot_twitch: "${userObj.bot_twitch || 'NOT SET'}"`);
    
    console.log('\nTwitch Tokens:');
    if (userObj.twitch_tokens?.bot) {
      console.log('  Bot Account:');
      console.log(`    access_token: ${userObj.twitch_tokens.bot.access_token ? 'SET' : 'NOT SET'}`);
      console.log(`    twitch_login: "${userObj.twitch_tokens.bot.twitch_login || 'NOT SET'}"`);
      console.log(`    twitch_display_name: "${userObj.twitch_tokens.bot.twitch_display_name || 'NOT SET'}"`);
      console.log(`    twitch_user_id: "${userObj.twitch_tokens.bot.twitch_user_id || 'NOT SET'}"`);
    } else {
      console.log('  Bot Account: NOT CONNECTED');
    }
    
    if (userObj.twitch_tokens?.streamer) {
      console.log('  Streamer Account:');
      console.log(`    access_token: ${userObj.twitch_tokens.streamer.access_token ? 'SET' : 'NOT SET'}`);
      console.log(`    twitch_login: "${userObj.twitch_tokens.streamer.twitch_login || 'NOT SET'}"`);
      console.log(`    twitch_display_name: "${userObj.twitch_tokens.streamer.twitch_display_name || 'NOT SET'}"`);
      console.log(`    twitch_user_id: "${userObj.twitch_tokens.streamer.twitch_user_id || 'NOT SET'}"`);
    } else {
      console.log('  Streamer Account: NOT CONNECTED');
    }
    
    console.log('\nAux Bots:');
    if (userObj.aux_bots && userObj.aux_bots.length > 0) {
      userObj.aux_bots.forEach((bot, index) => {
        console.log(`  ${index + 1}. "${bot}"`);
      });
    } else {
      console.log('  None configured');
    }
    
    console.log('\n=== Configuration Debug Complete ===\n');
  } catch (error) {
    console.log(`❌ Error debugging user configuration: ${error.message}`);
  }
}

// Export functions for use
export {
  debugContainsCharacterName,
  testMentionDetection,
  debugUserConfiguration
};

// If run directly from command line
if (import.meta.url === `file://${process.argv[1]}`) {
  const userId = process.argv[2];
  
  if (!userId) {
    console.log('Usage: node debug-mention-detection.js <userId> [test|config]');
    console.log('  test   - Run mention detection tests');
    console.log('  config - Show user configuration');
    process.exit(1);
  }
  
  const action = process.argv[3] || 'test';
  
  if (action === 'config') {
    await debugUserConfiguration(userId);
  } else {
    await testMentionDetection(userId);
  }
}
</file>

<file path="expression-parser.js">
// expression-parser.js
import { retrieveConfigValue } from "./config-helper.js";

/**
 * Parses AI response text for expression tags and extracts clean text with expression metadata
 * @param {string} text - The AI response text containing expression tags
 * @param {string[]} availableExpressions - Array of available expressions from the model
 * @returns {Object} - Object containing cleanText and expressions array
 */
export function parseExpressions(text, availableExpressions = []) {
  if (!text || typeof text !== 'string') {
    return { cleanText: '', expressions: [] };
  }

  // Expression tag pattern: [EXPRESSION:expressionName] or [EXP:expressionName]
  const expressionRegex = /\[(?:EXPRESSION|EXP):(\w+)\]/gi;
  const expressions = [];
  let cleanText = text;
  let totalRemovedLength = 0;

  // Find all expression matches with their positions
  const matches = Array.from(text.matchAll(expressionRegex));
  
  for (const match of matches) {
    const expressionName = match[1].toLowerCase();
    const tagPosition = match.index;
    const tagLength = match[0].length;
    
    // Calculate position in clean text (accounting for previously removed tags)
    const cleanTextPosition = tagPosition - totalRemovedLength;
    
    // Validate expression exists in available expressions (case-insensitive)
    const validExpression = availableExpressions.find(
      expr => expr.toLowerCase() === expressionName
    );
    
    if (validExpression || availableExpressions.length === 0) {
      expressions.push({
        expression: validExpression || expressionName,
        textPosition: Math.max(0, cleanTextPosition),
        originalTag: match[0],
        isValid: !!validExpression
      });
    }
    
    // Track total length of removed tags
    totalRemovedLength += tagLength;
  }

  // Remove all expression tags from the text
  cleanText = text.replace(expressionRegex, '');
  
  // Clean up any double spaces that might result from tag removal
  cleanText = cleanText.replace(/\s+/g, ' ').trim();

  logger.log('Expression', `Parsed ${expressions.length} expressions from response`);
  
  return { 
    cleanText, 
    expressions: expressions.sort((a, b) => a.textPosition - b.textPosition)
  };
}

/**
 * Calculates timing for expressions based on text positions and estimated audio duration
 * @param {Array} expressions - Array of expression objects with textPosition
 * @param {string} text - Clean text without expression tags
 * @param {number} estimatedDuration - Estimated audio duration in seconds
 * @returns {Array} - Array of expressions with calculated timing
 */
export function calculateExpressionTimings(expressions, text, estimatedDuration) {
  if (!expressions || expressions.length === 0) {
    return [];
  }

  const totalCharacters = text.length;
  if (totalCharacters === 0) {
    return expressions.map(expr => ({
      ...expr,
      startTime: 0,
      duration: 2.0,
      endTime: 2.0
    }));
  }

  return expressions.map((expr, index) => {
    // Calculate start time based on character position
    const relativePosition = expr.textPosition / totalCharacters;
    const startTime = relativePosition * estimatedDuration;
    
    // Calculate expression duration (until next expression or end of audio)
    let duration = 2.0; // Default 2 seconds
    
    if (index < expressions.length - 1) {
      const nextExprStartTime = (expressions[index + 1].textPosition / totalCharacters) * estimatedDuration;
      duration = Math.max(1.0, nextExprStartTime - startTime);
    } else {
      // Last expression - hold until near end of audio
      duration = Math.max(1.0, estimatedDuration - startTime - 0.5);
    }
    
    return {
      expression: expr.expression,
      startTime: Math.max(0, startTime),
      duration: duration,
      endTime: startTime + duration,
      textPosition: expr.textPosition,
      isValid: expr.isValid
    };
  });
}

/**
 * Estimates audio duration based on text length and speaking rate
 * @param {string} text - Text to estimate duration for
 * @param {Object} options - Options for duration estimation
 * @returns {number} - Estimated duration in seconds
 */
export function estimateAudioDuration(text, options = {}) {
  const {
    wordsPerMinute = 150, // Average speaking rate
    pauseFactor = 1.2,    // Factor for natural pauses
    minimumDuration = 1.0  // Minimum duration in seconds
  } = options;

  if (!text || typeof text !== 'string') {
    return minimumDuration;
  }

  // Count words (simple split by whitespace)
  const wordCount = text.trim().split(/\s+/).length;
  
  // Calculate base duration
  const baseDuration = (wordCount / wordsPerMinute) * 60;
  
  // Apply pause factor for natural speech
  const estimatedDuration = baseDuration * pauseFactor;
  
  return Math.max(minimumDuration, estimatedDuration);
}

/**
 * Generates enhanced system prompt with expression instructions
 * @param {string[]} availableExpressions - Array of available expressions
 * @param {string} basePrompt - Base system prompt
 * @returns {string} - Enhanced prompt with expression instructions
 */
export function generateExpressionPrompt(availableExpressions, basePrompt) {
  if (!availableExpressions || availableExpressions.length === 0) {
    return basePrompt;
  }

  const expressionInstructions = `
You can enhance your responses with facial expressions using expression tags. Use the format [EXPRESSION:name] to trigger expressions.

Available expressions: ${availableExpressions.join(', ')}

Expression Guidelines:
- Use expressions that match the emotional context naturally
- Place expression tags at the beginning of sentences or emotional shifts
- Maximum 1 expression per sentence to avoid overwhelming
- Default to 'neutral' when uncertain about appropriate expression
- Examples:
  * "[EXPRESSION:happy] That's wonderful news!"
  * "[EXPRESSION:thoughtful] Let me consider your question. [EXPRESSION:excited] I have a great idea!"
  * "[EXPRESSION:concerned] I'm worried about that issue."

Remember: Expressions should feel natural and enhance communication, not distract from it.`;

  return basePrompt + '\n\n' + expressionInstructions;
}

/**
 * Validates and filters expressions based on available model expressions
 * @param {Array} expressions - Array of expression objects
 * @param {string[]} availableExpressions - Valid expressions from the model
 * @returns {Array} - Filtered array of valid expressions
 */
export function validateExpressions(expressions, availableExpressions) {
  if (!expressions || !Array.isArray(expressions)) {
    return [];
  }

  if (!availableExpressions || availableExpressions.length === 0) {
    // If no available expressions defined, pass all through
    return expressions;
  }

  const validExpressions = expressions.filter(expr => {
    const isValid = availableExpressions.some(
      available => available.toLowerCase() === expr.expression.toLowerCase()
    );
    
    if (!isValid) {
      logger.log('Expression', `Filtered invalid expression: ${expr.expression}`);
    }
    
    return isValid;
  });

  logger.log('Expression', `Validated ${validExpressions.length}/${expressions.length} expressions`);
  
  return validExpressions;
}

/**
 * Creates expression debug information for logging and troubleshooting
 * @param {string} originalText - Original AI response with tags
 * @param {string} cleanText - Text with tags removed
 * @param {Array} expressions - Parsed expressions
 * @param {string[]} availableExpressions - Available model expressions
 * @returns {Object} - Debug information object
 */
export function createExpressionDebugInfo(originalText, cleanText, expressions, availableExpressions) {
  return {
    originalLength: originalText.length,
    cleanLength: cleanText.length,
    removedCharacters: originalText.length - cleanText.length,
    expressionCount: expressions.length,
    validExpressions: expressions.filter(e => e.isValid).length,
    invalidExpressions: expressions.filter(e => !e.isValid).map(e => e.expression),
    availableExpressionCount: availableExpressions?.length || 0,
    expressionCoverage: expressions.length > 0 ? 
      (expressions[expressions.length - 1].textPosition / cleanText.length * 100).toFixed(1) + '%' : '0%'
  };
}

/**
 * Main function to process AI response with expressions
 * @param {string} aiResponse - Raw AI response text
 * @param {string[]} availableExpressions - Available expressions from model
 * @param {Object} options - Processing options
 * @returns {Object} - Processed response with expressions
 */
export async function processResponseWithExpressions(aiResponse, availableExpressions = [], options = {}) {
  try {
    const {
      enableDebugLogging = true,
      estimateDuration = true,
      validateExpressionList = true
    } = options;

    // Parse expressions from the AI response
    const { cleanText, expressions } = parseExpressions(aiResponse, availableExpressions);
    
    // Validate expressions if validation is enabled
    const validatedExpressions = validateExpressionList ? 
      validateExpressions(expressions, availableExpressions) : expressions;
    
    // Estimate audio duration for timing calculations
    let estimatedDuration = 0;
    let timedExpressions = [];
    
    if (estimateDuration && cleanText) {
      estimatedDuration = estimateAudioDuration(cleanText);
      timedExpressions = calculateExpressionTimings(validatedExpressions, cleanText, estimatedDuration);
    } else {
      timedExpressions = validatedExpressions;
    }

    // Create debug information
    const debugInfo = enableDebugLogging ? 
      createExpressionDebugInfo(aiResponse, cleanText, expressions, availableExpressions) : null;

    if (enableDebugLogging && debugInfo) {
      logger.log('Expression', `Response processing complete:`, debugInfo);
    }

    return {
      success: true,
      originalText: aiResponse,
      cleanText: cleanText,
      expressions: timedExpressions,
      estimatedDuration: estimatedDuration,
      debug: debugInfo
    };

  } catch (error) {
    logger.error('Expression', `Error processing response with expressions: ${error.message}`);
    
    return {
      success: false,
      originalText: aiResponse,
      cleanText: aiResponse, // Fallback to original text
      expressions: [],
      error: error.message
    };
  }
}

export default {
  parseExpressions,
  calculateExpressionTimings,
  estimateAudioDuration,
  generateExpressionPrompt,
  validateExpressions,
  processResponseWithExpressions,
  createExpressionDebugInfo
};
</file>

<file path="setup-alternate-spelling.js">
// setup-alternate-spelling.js - Script to configure alternate spellings
// Run this script to add alternate spelling support to your Enspira installation

import { connectToMongoDB, getAllUsers, updateUserData, addAlternateSpelling } from './mongodb-client.js';
import { logger } from './create-global-logger.js';

/**
 * Setup script to configure alternate spellings for your bot
 * This script will:
 * 1. Add the alternateSpell field to all users who don't have it
 * 2. Configure common alternate spellings for bot names
 * 3. Set up your specific "Leila" -> "Layla" mapping
 */
async function setupAlternateSpelling() {
  try {
    logger.log("Setup", "Starting alternate spelling configuration...");

    // Connect to MongoDB
    const connected = await connectToMongoDB();
    if (!connected) {
      logger.error("Setup", "Failed to connect to MongoDB");
      return false;
    }

    // Get all users
    const users = await getAllUsers();
    logger.log("Setup", `Found ${users.length} users to configure`);

    let configuredCount = 0;

    for (const user of users) {
      try {
        // Initialize alternateSpell array if it doesn't exist
        if (!user.alternateSpell) {
          await updateUserData(user.user_id, 'alternateSpell', []);
          logger.log("Setup", `Initialized alternateSpell for user ${user.user_id}`);
        }

        // Configure based on bot name
        const botName = user.bot_name;
        if (!botName) {
          logger.warn("Setup", `User ${user.user_id} has no bot_name, skipping`);
          continue;
        }

        let alternateSpellings = [];

        // Common alternate spellings for popular bot names
        switch (botName.toLowerCase()) {
          case 'layla':
            alternateSpellings = ['Leila', 'Lila', 'Laila', 'Leyla', 'Laela'];
            break;
          case 'sarah':
            alternateSpellings = ['Sara', 'Sera'];
            break;
          case 'catherine':
            alternateSpellings = ['Katherine', 'Kathryn', 'Catherine', 'Kate', 'Katie'];
            break;
          case 'elena':
            alternateSpellings = ['Helena', 'Alena', 'Elaina'];
            break;
          case 'sophia':
            alternateSpellings = ['Sofia', 'Sophie'];
            break;
          case 'maya':
            alternateSpellings = ['Maia', 'Mya'];
            break;
          case 'aria':
            alternateSpellings = ['Arya', 'Aria'];
            break;
          default:
            // For other names, we'll add basic variations
            alternateSpellings = [];
        }

        // Add the alternate spellings
        for (const spelling of alternateSpellings) {
          const success = await addAlternateSpelling(user.user_id, spelling);
          if (success) {
            logger.log("Setup", `Added "${spelling}" as alternate for ${botName} (user: ${user.user_id})`);
          }
        }

        configuredCount++;

      } catch (userError) {
        logger.error("Setup", `Error configuring user ${user.user_id}: ${userError.message}`);
      }
    }

    logger.log("Setup", `Successfully configured alternate spellings for ${configuredCount} users`);
    return true;

  } catch (error) {
    logger.error("Setup", `Error in setupAlternateSpelling: ${error.message}`);
    return false;
  }
}

/**
 * Add a custom alternate spelling for a specific user
 * @param {string} userId - User ID
 * @param {string} alternateSpelling - The alternate spelling to add
 */
async function addCustomAlternateSpelling(userId, alternateSpelling) {
  try {
    const success = await addAlternateSpelling(userId, alternateSpelling);
    if (success) {
      logger.log("Setup", `Added custom alternate spelling "${alternateSpelling}" for user ${userId}`);
    } else {
      logger.error("Setup", `Failed to add alternate spelling for user ${userId}`);
    }
    return success;
  } catch (error) {
    logger.error("Setup", `Error adding custom alternate spelling: ${error.message}`);
    return false;
  }
}

/**
 * Advanced setup for complex name mappings
 * This allows mapping from specific incorrect names to specific correct names
 * @param {string} userId - User ID
 * @param {string} fromName - The incorrect name (e.g., "Leila")
 * @param {string} toName - The correct name (e.g., "Layla")
 */
async function addAdvancedMapping(userId, fromName, toName) {
  try {
    const mapping = { from: fromName, to: toName };
    const success = await addAlternateSpelling(userId, mapping);
    if (success) {
      logger.log("Setup", `Added advanced mapping "${fromName}" -> "${toName}" for user ${userId}`);
    } else {
      logger.error("Setup", `Failed to add mapping for user ${userId}`);
    }
    return success;
  } catch (error) {
    logger.error("Setup", `Error adding advanced mapping: ${error.message}`);
    return false;
  }
}

/**
 * Test the alternate spelling functionality
 * @param {string} testText - Text to test
 * @param {Array} alternateSpellings - Array of alternate spellings
 */
function testAlternateSpelling(testText, alternateSpellings, botName) {
  logger.log("Test", `Testing text: "${testText}"`);
  
  let processedText = testText;
  
  for (const alternateEntry of alternateSpellings) {
    if (typeof alternateEntry === 'string') {
      const regex = new RegExp(`\\b${alternateEntry}\\b`, 'gi');
      processedText = processedText.replace(regex, botName);
    } else if (typeof alternateEntry === 'object' && alternateEntry.from && alternateEntry.to) {
      const regex = new RegExp(`\\b${alternateEntry.from}\\b`, 'gi');
      processedText = processedText.replace(regex, alternateEntry.to);
    }
  }
  
  logger.log("Test", `Processed text: "${processedText}"`);
  return processedText;
}

// Example usage and tests
async function runSetup() {
  logger.log("Setup", "Starting Enspira Alternate Spelling Setup");
  
  // Run the main setup
  const success = await setupAlternateSpelling();
  
  if (success) {
    // Example: Add a custom mapping for a specific user
    // Replace 'your_user_id' with your actual user ID
    // await addAdvancedMapping('your_user_id', 'Leila', 'Layla');
    
    // Example: Test the functionality
    const testAlternates = ['Leila', 'Lila', 'Laila'];
    testAlternateSpelling("Hey Leila, how are you feeling today?", testAlternates, "Layla");
    testAlternateSpelling("Lila, can you help me?", testAlternates, "Layla");
    testAlternateSpelling("What do you think, Laila?", testAlternates, "Layla");
    
    logger.log("Setup", "Setup completed successfully!");
    logger.log("Setup", "Restart your Enspira server to apply the changes.");
  } else {
    logger.error("Setup", "Setup failed. Please check the logs above.");
  }
}

// Export functions for use in other modules
export {
  setupAlternateSpelling,
  addCustomAlternateSpelling,
  addAdvancedMapping,
  testAlternateSpelling
};

// Run setup if this file is executed directly
if (import.meta.url === import.meta.resolve(process.argv[1])) {
  runSetup().then(() => {
    process.exit(0);
  }).catch((error) => {
    logger.error("Setup", `Unhandled error: ${error.message}`);
    process.exit(1);
  });
}
</file>

<file path="routes/audio.js">
// routes/audio.js
import path from 'path';
import fastifyStatic from '@fastify/static';
import fs from 'fs/promises';

export async function audioRoutes(fastify, options = {}) {
  const {
    outputDir = 'final',
    addContentDisposition = false
  } = options;

  // Resolve the absolute path to the output directory
  const audioFilesPath = path.resolve(process.cwd(), outputDir);
  
  console.log('Audio files directory:', audioFilesPath);
  
  // Simple test route to verify the plugin is working
  fastify.get('/test', async () => {
    return { status: 'Audio routes working' };
  });
  
  // Direct file serving
  fastify.get('/:filename', async (request, reply) => {
    const { filename } = request.params;
    
    // Prevent path traversal
    if (filename.includes('..') || filename.includes('/') || filename.includes('\\')) {
      return reply.code(400).send({ error: 'Invalid filename' });
    }
    
    const filePath = path.join(audioFilesPath, filename);
    
    try {
      // Verify file exists
      await fs.access(filePath);
      
      // Set headers manually
      reply.header('Content-Type', 'audio/wav');
      
      if (addContentDisposition) {
        reply.header('Content-Disposition', `attachment; filename="${filename}"`);
      }
      
      // Read and send file directly
      const fileContent = await fs.readFile(filePath);
      return reply.send(fileContent);
    } catch (error) {
      console.error('Error serving file:', error);
      return reply.code(error.code === 'ENOENT' ? 404 : 500)
        .send({ error: error.code === 'ENOENT' ? 'File not found' : 'Error serving file' });
    }
  });
  
  // Register static file plugin as a separate handler
  await fastify.register(fastifyStatic, {
    root: audioFilesPath,
    prefix: '/static',
    decorateReply: false,
    setHeaders: (res) => {
      res.setHeader('Content-Type', 'audio/wav');
      if (addContentDisposition) {
        const filePath = req.url;
        const fileName = path.basename(filePath);
        res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
      }
    }
  });
  
  // Add a delete route
  fastify.delete('/:filename', async (request, reply) => {
    const { filename } = request.params;
    
    // Prevent path traversal
    if (filename.includes('..') || filename.includes('/') || filename.includes('\\')) {
      return reply.code(400).send({ error: 'Invalid filename' });
    }
    
    const filePath = path.join(audioFilesPath, filename);
    
    try {
      await fs.unlink(filePath);
      return { success: true, message: `File ${filename} deleted` };
    } catch (error) {
      if (error.code === 'ENOENT') {
        return reply.code(404).send({ error: 'File not found' });
      }
      return reply.code(500).send({ error: 'Failed to delete file' });
    }
  });
}
</file>

<file path="utils/api-utils.js">
import axios from 'axios';
import https from 'https';
import { logger } from '../create-global-logger.js';

/**
 * Creates an axios instance with consistent defaults
 * @param {object} options - Configuration options
 * @returns {object} - Configured axios instance
 */
export function createApiClient(options = {}) {
  const {
    baseURL = '',
    timeout = 15000,
    headers = {},
    keepAlive = true
  } = options;
  
  // Create https agent with keep-alive
  const httpsAgent = new https.Agent({
    keepAlive,
    rejectUnauthorized: true,
    timeout: timeout
  });
  
  return axios.create({
    baseURL,
    timeout,
    headers: {
      'User-Agent': 'Enspira/1.0',
      'Accept': 'application/json',
      ...headers
    },
    httpsAgent
  });
}

/**
 * Makes API request with automatic retries
 * @param {function} requestFn - Function that returns a promise (e.g., axios call)
 * @param {object} options - Retry options
 * @returns {Promise<any>} - API response
 */
export async function makeRequestWithRetry(requestFn, options = {}) {
  const {
    maxRetries = 3,
    initialDelay = 500,
    maxDelay = 10000,
    factor = 2,
    retryStatusCodes = [408, 429, 500, 502, 503, 504],
    retryErrorCodes = ['ETIMEDOUT', 'ECONNRESET', 'ECONNABORTED', 'EPIPE'],
    logContext = "API"
  } = options;
  
  let lastError;
  let delay = initialDelay;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await requestFn();
    } catch (error) {
      lastError = error;
      
      // Determine if error is retryable
      const statusCode = error.response?.status;
      const isRetryable = 
        retryStatusCodes.includes(statusCode) || 
        retryErrorCodes.includes(error.code);
      
      if (isRetryable && attempt < maxRetries - 1) {
        // Calculate backoff with jitter
        const jitterDelay = Math.min(
          maxDelay, 
          delay * (0.75 + Math.random() * 0.5)
        );
        
        logger.warn(
          logContext,
          `Request failed (${statusCode || error.code}). Retrying in ${Math.round(jitterDelay)}ms. Attempt ${attempt + 1}/${maxRetries}`
        );
        
        // Wait before retry
        await new Promise(resolve => setTimeout(resolve, jitterDelay));
        delay *= factor;
      } else {
        break;
      }
    }
  }
  
  throw lastError;
}

/**
 * Simplified form data submission with proper error handling
 * @param {string} url - Target URL
 * @param {object} formData - Form data to submit
 * @param {object} [options] - Additional options
 * @returns {Promise<object>} - Response data
 */
export async function submitFormData(url, formData, options = {}) {
  const {
    method = 'POST',
    headers = {},
    timeout = 30000,
    maxRetries = 3
  } = options;
  
  const requestFn = () => axios({
    method,
    url,
    data: formData,
    headers: {
      ...headers,
      'Content-Type': 'multipart/form-data'
    },
    timeout,
    maxContentLength: 100 * 1024 * 1024, // 100MB
    maxBodyLength: 100 * 1024 * 1024 // 100MB
  });
  
  return makeRequestWithRetry(requestFn, { maxRetries });
}
</file>

<file path="utils/cache-utils.js">
import { logger } from '../create-global-logger.js';

/**
 * Creates a configurable in-memory cache
 * @param {object} options - Cache configuration
 * @returns {object} - Cache controller
 */
export function createCache(options = {}) {
  const {
    maxSize = 500,
    defaultTtl = 60000, // 1 minute
    name = 'cache',
    logHits = false
  } = options;
  
  const cache = new Map();
  let hitCount = 0;
  let missCount = 0;
  
  /**
   * Checks if key exists and isn't expired
   * @param {string} key - Cache key
   * @returns {boolean} - Whether key exists and is valid
   */
  function has(key) {
    if (!cache.has(key)) {
      return false;
    }
    
    const { expiry } = cache.get(key);
    if (Date.now() > expiry) {
      cache.delete(key);
      return false;
    }
    
    return true;
  }
  
  /**
   * Gets value from cache
   * @param {string} key - Cache key
   * @returns {any} - Cached value or null if missing/expired
   */
  function get(key) {
    if (!has(key)) {
      missCount++;
      return null;
    }
    
    hitCount++;
    if (logHits) {
      logger.log('Cache', `${name} cache hit for: ${key}`);
    }
    
    return cache.get(key).data;
  }
  
  /**
   * Stores value in cache
   * @param {string} key - Cache key
   * @param {any} value - Value to store
   * @param {number} [ttl] - Custom TTL in ms
   */
  function set(key, value, ttl = defaultTtl) {
    // Evict oldest entry if at capacity
    if (cache.size >= maxSize) {
      let oldest = null;
      let oldestTime = Infinity;
      
      for (const [existingKey, entry] of cache.entries()) {
        if (entry.expiry < oldestTime) {
          oldestTime = entry.expiry;
          oldest = existingKey;
        }
      }
      
      if (oldest) {
        cache.delete(oldest);
      }
    }
    
    cache.set(key, {
      data: value,
      expiry: Date.now() + ttl,
      created: Date.now()
    });
  }
  
  /**
   * Gets a value or generates it if missing
   * @param {string} key - Cache key
   * @param {function} fetchFn - Function to generate value
   * @param {object} [options] - Additional options
   * @returns {Promise<any>} - Retrieved or generated value
   */
  async function getOrSet(key, fetchFn, options = {}) {
    const { ttl = defaultTtl, forceFresh = false } = options;
    
    // Return cached value if valid and not forcing refresh
    if (!forceFresh && has(key)) {
      return get(key);
    }
    
    try {
      // Generate new value
      const freshValue = await fetchFn();
      
      // Only cache if value exists
      if (freshValue !== undefined && freshValue !== null) {
        set(key, freshValue, ttl);
      }
      
      return freshValue;
    } catch (error) {
      logger.error('Cache', `Error generating value for key '${key}': ${error.message}`);
      throw error;
    }
  }
  
  /**
   * Deletes a key from cache
   * @param {string} key - Key to delete
   * @returns {boolean} - Whether deletion was successful
   */
  function del(key) {
    return cache.delete(key);
  }
  
  /**
   * Clears all or matching entries
   * @param {string} [pattern] - Optional pattern to match keys
   * @returns {number} - Number of entries cleared
   */
  function clear(pattern = null) {
    if (!pattern) {
      const size = cache.size;
      cache.clear();
      return size;
    }
    
    let count = 0;
    for (const key of cache.keys()) {
      if (key.includes(pattern)) {
        cache.delete(key);
        count++;
      }
    }
    
    return count;
  }
  
  /**
   * Gets cache statistics
   * @returns {object} - Cache statistics
   */
  function stats() {
    return {
      size: cache.size,
      maxSize,
      hits: hitCount,
      misses: missCount,
      hitRate: hitCount + missCount > 0 
        ? hitCount / (hitCount + missCount) 
        : 0
    };
  }
  
  return {
    get,
    set,
    has,
    del,
    clear,
    getOrSet,
    stats
  };
}

/**
 * Creates a disk cache with filesystem persistence
 * @param {object} options - Cache configuration
 * @returns {object} - Disk cache controller
 */
export function createDiskCache(options = {}) {
  // Implementation details would go here
  // This would use fs-extra to persist cache entries to disk
  // with similar interface to in-memory cache
}
</file>

<file path="utils/error-utils.js">
import { logger } from '../create-global-logger.js';

/**
 * Standard error structure for consistent error handling
 */
export class ApplicationError extends Error {
  constructor(message, options = {}) {
    super(message);
    
    const {
      code = 'INTERNAL_ERROR',
      statusCode = 500,
      context = 'Application',
      details = null,
      cause = null,
      logLevel = 'error'
    } = options;
    
    this.name = this.constructor.name;
    this.code = code;
    this.statusCode = statusCode;
    this.context = context;
    this.details = details;
    this.cause = cause;
    this.timestamp = new Date();
    
    // Log automatically on creation
    logger[logLevel](context, message);
    
    // Capture stack trace
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  
  /**
   * Creates a formatted response object
   * @returns {object} - Response error object
   */
  toResponse() {
    return {
      error: {
        code: this.code,
        message: this.message,
        details: this.details,
        timestamp: this.timestamp.toISOString()
      }
    };
  }
}

/**
 * Executes function with standard error handling
 * @param {function} fn - Function to execute
 * @param {object} [options] - Error handling options
 * @returns {Promise<any>} - Function result or error
 */
export async function withErrorHandling(fn, options = {}) {
  const {
    context = 'Application',
    defaultValue = null,
    rethrow = false,
    errorFormatter = null,
    logError = true,
    captureAll = false
  } = options;
  
  try {
    return await fn();
  } catch (error) {
    if (logError) {
      if (error instanceof ApplicationError) {
        // Already logged during creation
      } else {
        logger.error(context, `${error.message}`);
      }
    }
    
    if (rethrow) {
      // Format error if requested
      if (errorFormatter && typeof errorFormatter === 'function') {
        throw errorFormatter(error);
      }
      
      // Convert to ApplicationError if not already
      if (!(error instanceof ApplicationError) && captureAll) {
        throw new ApplicationError(error.message, {
          context,
          cause: error,
          details: {
            originalError: {
              name: error.name,
              stack: error.stack
            }
          }
        });
      }
      
      throw error;
    }
    
    return defaultValue;
  }
}

/**
 * Creates an error handler for specific contexts
 * @param {string} context - Error context name
 * @returns {function} - Configured error handler
 */
export function createErrorHandler(context) {
  return async (fn, options = {}) => {
    return withErrorHandling(fn, {
      context,
      ...options
    });
  };
}
</file>

<file path="utils/file-utils.js">
import fs from 'fs-extra';
import path from 'path';
import { logger } from '../create-global-logger.js';

// Cache for template files
const templateCache = new Map();

/**
 * Reads a template file with caching
 * @param {string} filePath - Path to template file
 * @returns {Promise<string>} - Template content
 */
export async function getTemplate(filePath) {
  if (templateCache.has(filePath)) {
    return templateCache.get(filePath);
  }
  
  try {
    const content = await fs.readFile(filePath, "utf-8");
    templateCache.set(filePath, content);
    return content;
  } catch (error) {
    logger.error("Files", `Error reading template file ${filePath}: ${error.message}`);
    throw error;
  }
}

/**
 * Reads multiple files in parallel and returns contents organized by file name
 * @param {string} basePath - Base directory path
 * @param {string[]} fileNames - Array of file names to read
 * @param {string} [extension='.txt'] - File extension
 * @returns {Promise<object>} - Object with fileNames as keys and content as values
 */
export async function readMultipleFiles(basePath, fileNames, extension = '.txt') {
  const fileContents = {};
  
  await Promise.all(
    fileNames.map(async (fileName) => {
      const filePath = path.join(basePath, `${fileName}${extension}`);
      try {
        fileContents[fileName] = await fs.readFile(filePath, "utf-8");
      } catch (error) {
        logger.log("Files", `Error reading file ${filePath}: ${error.message}`);
        fileContents[fileName] = ""; // Default empty string for missing files
      }
    })
  );
  
  return fileContents;
}

/**
 * Safely writes JSON data to a file with proper error handling
 * @param {string} filePath - Path to write the file
 * @param {object} data - Data to write
 * @param {object} [options] - Options for writing
 * @returns {Promise<boolean>} - Success indicator
 */
export async function safeWriteJSON(filePath, data, options = {}) {
  try {
    // Ensure directory exists
    await fs.ensureDir(path.dirname(filePath));
    
    // Write with custom options or defaults
    await fs.writeJSON(filePath, data, {
      spaces: 2,
      EOL: '\n',
      ...options
    });
    
    return true;
  } catch (error) {
    logger.error("Files", `Error writing JSON to ${filePath}: ${error.message}`);
    return false;
  }
}
</file>

<file path="utils/index.js">
// Barrel file to easily export all utilities
export * from './file-utils.js';
export * from './api-utils.js';
export * from './cache-utils.js';
export * from './string-utils.js';
export * from './error-utils.js';

// Import commonly used utilities for quick access
import { getTemplate, readMultipleFiles, safeWriteJSON } from './file-utils.js';
import { makeRequestWithRetry, createApiClient } from './api-utils.js';
import { createCache } from './cache-utils.js';
import { replacePlaceholders, transformTtsText } from './string-utils.js';
import { withErrorHandling, ApplicationError } from './error-utils.js';

// Export common combinations
export const utils = {
  file: {
    getTemplate,
    readMultipleFiles,
    safeWriteJSON
  },
  api: {
    makeRequestWithRetry,
    createApiClient
  },
  cache: {
    createCache
  },
  string: {
    replacePlaceholders,
    transformTtsText
  },
  error: {
    withErrorHandling,
    ApplicationError
  }
};

export default utils;
</file>

<file path="utils/string-utils.js">
/**
 * Replaces placeholders in template strings
 * @param {string} template - Template string with placeholders
 * @param {object} replacements - Map of placeholders to values
 * @returns {string} - Processed string
 */
export function replacePlaceholders(template, replacements) {
    if (!template) return '';
    
    let result = template;
    for (const [placeholder, value] of Object.entries(replacements)) {
      // Skip undefined values
      if (value === undefined) continue;
      
      // Convert null to empty string
      const replacement = value === null ? '' : value;
      
      // Use global regex for all occurrences
      result = result.replace(
        new RegExp(escapeRegExp(placeholder), 'g'), 
        replacement
      );
    }
    
    return result;
  }
  
  /**
   * Escapes special characters in string for regex
   * @param {string} string - String to escape
   * @returns {string} - Escaped string
   */
  export function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }
  
  /**
   * Transforms TTS text by handling acronyms and special formats
   * @param {string} input - Input string
   * @param {object} [options] - Transformation options
   * @returns {object} - Transformed string and statistics
   */
  export function transformTtsText(input, options = {}) {
    const {
      acronymExceptions = ["GOATs", "LOL", "LMAO"],
      separateWithDots = true
    } = options;
    
    const acronymRegex = /\b([A-Z]{2,})(?!\w)/g;
    const jsRegex = /\.js\b/gi;
    
    let acronymCount = 0;
    let jsCount = 0;
    
    let transformed = input.replace(acronymRegex, (match) => {
      if (acronymExceptions.includes(match)) {
        return match;
      }
      
      acronymCount++;
      
      if (separateWithDots) {
        let result = match.slice(0, -1).split("").join(".") + "." + match.slice(-1);
        if (match.endsWith("S") && match.length > 2) {
          const base = match.slice(0, -1).split("").join(".");
          result = `${base}'s`;
        }
        return result;
      } else {
        // Alternate transformation: spell out with spaces
        return match.split("").join(" ");
      }
    });
    
    transformed = transformed.replace(jsRegex, (match) => {
      jsCount++;
      return ".J.S";
    });
    
    return { 
      text: transformed, 
      stats: {
        acronymCount,
        jsCount
      }
    };
  }
  
  /**
   * Formats a string for fixed character limit
   * @param {string} input - Input string
   * @param {number} maxLength - Maximum length
   * @returns {string} - Truncated string
   */
  export function truncateWithEllipsis(input, maxLength) {
    if (!input || input.length <= maxLength) {
      return input;
    }
    
    // Find a good breaking point
    const breakPoint = input.lastIndexOf(' ', maxLength - 3);
    if (breakPoint > maxLength * 0.7) {
      return input.substring(0, breakPoint) + '...';
    }
    
    // If no good breaking point, just truncate
    return input.substring(0, maxLength - 3) + '...';
  }
</file>

<file path="views/help.njk">
{% extends "layout.njk" %}

{% block title %}Help & Documentation{% endblock %}

{% block content %}
<div class="card">
  <div class="card-header">
    <h1>Help & Documentation</h1>
  </div>
  
  <p>Welcome to Enspira's Help page! This guide explains how to use template variables in your character, world info, and scenario settings. Simply insert these variables in your templates, and they will be automatically replaced with your data.</p>
  
  <div class="card" style="margin-top: 20px; background-color: rgba(88, 166, 255, 0.1); border-color: var(--accent);">
    <h2 style="margin-top: 0;">Quick Reference</h2>
    <p>Commonly used variables:</p>
    <div class="scope-list" style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 10px;">
      <code class="scope">&#123;&#123;user&#125;&#125;</code>
      <code class="scope">&#123;&#123;char&#125;&#125;</code>
      <code class="scope">&#123;&#123;socials&#125;&#125;</code>
      <code class="scope">&#123;&#123;socials.twitter&#125;&#125;</code>
      <code class="scope">&#123;&#123;datetime&#125;&#125;</code>
      <code class="scope">&#123;&#123;current_game&#125;&#125;</code>
      <code class="scope">&#123;&#123;current_views&#125;&#125;</code>
    </div>
  </div>
  
  <h2 class="section-title">Template Variables</h2>
  
  <div class="card">
    <h3 class="card-subtitle">Character Card & World Information Variables</h3>
    <ul class="variable-list">
      <li class="variable-item">
        <code class="variable-name">&#123;&#123;user&#125;&#125;</code>
        <span class="variable-desc">Your name as recognized by the assistant – typically your streaming username</span>
      </li>
      <li class="variable-item">
        <code class="variable-name">&#123;&#123;char&#125;&#125;</code>
        <span class="variable-desc">The name of your AI assistant or character</span>
      </li>
      <li class="variable-item">
        <code class="variable-name">&#123;&#123;socials&#125;&#125;</code>
        <span class="variable-desc">A pre-formatted list of all your linked social media accounts</span>
      </li>
      <li class="variable-item">
        <code class="variable-name">&#123;&#123;socials.xxx&#125;&#125;</code>
        <span class="variable-desc">A specific social media account where xxx is one of:</span>
        <div class="platform-list">
          <span class="platform">tiktok</span>
          <span class="platform">youtube</span>
          <span class="platform">twitch</span>
          <span class="platform">twitter</span>
          <span class="platform">kick</span>
        </div>
      </li>
      <li class="variable-item">
        <code class="variable-name">&#123;&#123;datetime&#125;&#125;</code>
        <span class="variable-desc">The current date and time</span>
      </li>
    </ul>
  </div>
  
  <div class="card">
    <h3 class="card-subtitle">Scenario Variables</h3>
    <ul class="variable-list">
      <li class="variable-item">
        <code class="variable-name">&#123;&#123;current_game&#125;&#125;</code>
        <span class="variable-desc">The game you are currently playing, as retrieved from Twitch</span>
      </li>
      <li class="variable-item">
        <code class="variable-name">&#123;&#123;current_views&#125;&#125;</code>
        <span class="variable-desc">The current viewer count of your Twitch channel</span>
      </li>
      <li class="variable-item">
        <code class="variable-name">&#123;&#123;current_follows&#125;&#125;</code>
        <span class="variable-desc">Your current follower count from Twitch</span>
      </li>
      <li class="variable-item">
        <span class="variable-desc">Also available: <code class="inline-code">&#123;&#123;user&#125;&#125;</code>, <code class="inline-code">&#123;&#123;char&#125;&#125;</code>, <code class="inline-code">&#123;&#123;socials&#125;&#125;</code>, <code class="inline-code">&#123;&#123;socials.xxx&#125;&#125;</code>, and <code class="inline-code">&#123;&#123;datetime&#125;&#125;</code></span>
      </li>
    </ul>
  </div>
  
  <h2 class="section-title">How to Use Template Variables</h2>
  
  <div class="card">
    <p>When editing your character, world, or scenario, simply place these variables within your content. For example, to display your name, include <code class="inline-code">&#123;&#123;user&#125;&#125;</code> where appropriate.</p>
    
    <h4 class="example-heading">Example Template:</h4>
    <pre class="code-example">Hello, my name is &#123;&#123;char&#125;&#125; and I'm &#123;&#123;user&#125;&#125;'s AI assistant!
You can follow &#123;&#123;user&#125;&#125; on Twitter at @&#123;&#123;socials.twitter&#125;&#125;

The current game being played is &#123;&#123;current_game&#125;&#125;
There are &#123;&#123;current_views&#125;&#125; viewers watching right now!</pre>
  </div>
  
  <h2 class="section-title">Tips for Effective Templates</h2>
  
  <div class="card">
    <ul class="tips-list">
      <li class="tip-item">Always use the exact variable names as shown above (including curly braces)</li>
      <li class="tip-item">For social media handles, replace <code class="inline-code">xxx</code> in <code class="inline-code">&#123;&#123;socials.xxx&#125;&#125;</code> with a valid platform name</li>
      <li class="tip-item">Combine static text with variables to craft personalized messages</li>
      <li class="tip-item">Preview your changes to see how the data populates</li>
      <li class="tip-item">Be aware that some variables (like <code class="inline-code">&#123;&#123;current_game&#125;&#125;</code>) will only display data when your stream is active</li>
    </ul>
  </div>
  
  <div class="card" style="margin-top: 20px; background-color: rgba(86, 211, 100, 0.1); border-color: var(--success);">
    <p style="margin: 0;">This guide is designed to help you create dynamic, data-driven character and world settings for your stream. If you have questions, check our <a href="https://github.com/prolix-oc/Enspira" target="_blank">GitHub repository</a> or reach out to the community.</p>
  </div>
</div>
{% endblock %}

{% block extraStyles %}
<style>
  .section-title {
    margin-top: 30px;
    border-bottom: 1px solid var(--border);
    padding-bottom: 10px;
  }
  
  .card-subtitle {
    margin-top: 0;
    color: var(--accent);
  }
  
  .variable-list {
    list-style-type: none;
    padding-left: 0;
  }
  
  .variable-item {
    margin-bottom: 12px;
    padding-left: 20px;
    position: relative;
  }
  
  .variable-item::before {
    content: '›';
    position: absolute;
    left: 0;
    top: 2px;
    color: var(--accent);
  }
  
  .variable-name {
    background: var(--input-bg);
    padding: 2px 6px;
    border-radius: 4px;
    font-weight: bold;
    font-family: monospace;
  }
  
  .variable-desc {
    margin-left: 5px;
  }
  
  .platform-list {
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
    margin-top: 5px;
    margin-left: 20px;
  }
  
  .platform {
    background: rgba(100, 65, 164, 0.2);
    color: #d2b8ff;
    padding: 3px 8px;
    border-radius: 4px;
    font-size: 0.9em;
  }
  
  .inline-code {
    background: var(--input-bg);
    padding: 2px 6px;
    border-radius: 4px;
    font-family: monospace;
  }
  
  .code-example {
    background-color: var(--input-bg);
    padding: 15px;
    border-radius: 8px;
    overflow-x: auto;
    white-space: pre-wrap;
    margin-top: 10px;
  }
  
  .example-heading {
    margin-top: 20px;
    color: var(--accent);
  }
  
  .tips-list {
    list-style-type: none;
    padding-left: 0;
  }
  
  .tip-item {
    margin-bottom: 12px;
    padding-left: 25px;
    position: relative;
  }
  
  .tip-item::before {
    content: '✓';
    position: absolute;
    left: 0;
    top: 2px;
    color: var(--success);
    font-weight: bold;
  }
  
  .scope {
    background-color: var(--button-secondary-bg);
    padding: 4px 10px;
    border-radius: 4px;
    font-family: monospace;
  }
  
  .scope-list {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }
</style>
{% endblock %}
</file>

<file path="views/login.njk">
{% extends "layout.njk" %}

{% block title %}Login{% endblock %}

{% block content %}
<div class="card login-card">
  <div class="card-header">
    <h1>Welcome to Enspira</h1>
  </div>
  
  {% if error %}
  <div class="alert alert-error">{{ error }}</div>
  {% endif %}
  
  <form action="/api/v1/auth/login" method="POST">
    <div class="form-group">
      <label for="user_id">User ID</label>
      <input type="text" id="user_id" name="user_id" required>
    </div>
    
    <div class="form-group">
      <label for="password">Password</label>
      <input type="password" id="password" name="password" required>
    </div>
    
    <button type="submit" class="btn btn-primary">Login</button>
  </form>
</div>
{% endblock %}

{% block extraStyles %}
<style>
  .login-card {
    max-width: 500px;
    margin: 40px auto;
  }
</style>
{% endblock %}
</file>

<file path="views/settings.njk">
{% extends "layout.njk" %}

{% block title %}User Settings{% endblock %}

{% block content %}
<div class="card">
  <div class="card-header">
    <h1>User Settings</h1>
  </div>
  
  <p>Customize your account settings and preferences for Enspira.</p>
  
  {% if success %}
  <div class="alert alert-success">
    {{ success }}
  </div>
  {% endif %}
  
  {% if error %}
  <div class="alert alert-error">
    {{ error }}
  </div>
  {% endif %}
  
  <div class="tabs">
    <div class="tab active" data-target="profile-tab">Profile</div>
    <div class="tab" data-target="socials-tab">Social Media</div>
    <div class="tab" data-target="security-tab">Security</div>
    <div class="tab" data-target="preferences-tab">Preferences</div>
  </div>
  
  <!-- Profile Settings -->
  <div id="profile-tab" class="tab-content active">
    <form action="/api/v1/settings/profile" method="POST" data-async>
      <div class="form-group">
        <label for="display_name">Display Name</label>
        <input type="text" id="display_name" name="display_name" value="{{ user.display_name }}" required>
        <p>The name displayed in the Enspira interface.</p>
      </div>
      
      <div class="form-group">
        <label for="user_name">Character Reference Name</label>
        <input type="text" id="user_name" name="user_name" value="{{ user.user_name }}" required>
        <p>The name your AI assistant will use to refer to you.</p>
      </div>
      
      <div class="form-group">
        <label for="email">Email Address</label>
        <input type="email" id="email" name="email" value="{{ user.email }}">
        <p>Your email address for notifications and account recovery.</p>
      </div>
      
      <div class="form-group">
        <label for="timeZone">Time Zone</label>
        <select id="timeZone" name="timeZone">
          <option value="">Select Time Zone</option>
          {% for tz in timeZones %}
            <option value="{{ tz.value }}" {% if user.timeZone == tz.value %}selected{% endif %}>{{ tz.label }}</option>
          {% endfor %}
        </select>
        <p>Your local time zone for scheduling and events.</p>
      </div>
      
      <button type="submit" class="btn btn-primary">Save Profile</button>
    </form>
  </div>
  
  <!-- Social Media Settings -->
  <div id="socials-tab" class="tab-content">
    <form action="/api/v1/settings/socials" method="POST" data-async>
      <div class="form-group">
        <label for="twitter">X (Twitter)</label>
        <input type="text" id="twitter" name="socials[twitter]" value="{{ user.socials.twitter }}">
        <p>Your X/Twitter username (without @).</p>
      </div>
      
      <div class="form-group">
        <label for="tiktok">TikTok</label>
        <input type="text" id="tiktok" name="socials[tiktok]" value="{{ user.socials.tiktok }}">
        <p>Your TikTok username.</p>
      </div>
      
      <div class="form-group">
        <label for="youtube">YouTube</label>
        <input type="text" id="youtube" name="socials[youtube]" value="{{ user.socials.youtube }}">
        <p>Your YouTube channel name or ID.</p>
      </div>
      
      <div class="form-group">
        <label for="instagram">Instagram</label>
        <input type="text" id="instagram" name="socials[instagram]" value="{{ user.socials.instagram }}">
        <p>Your Instagram username.</p>
      </div>
      
      <div class="form-group">
        <label for="twitch">Twitch</label>
        <input type="text" id="twitch" name="socials[twitch]" value="{{ user.socials.twitch }}">
        <p>Your Twitch username.</p>
      </div>
      
      <div class="form-group">
        <label for="kick">Kick</label>
        <input type="text" id="kick" name="socials[kick]" value="{{ user.socials.kick }}">
        <p>Your Kick username.</p>
      </div>
      
      <button type="submit" class="btn btn-primary">Save Social Media</button>
    </form>
  </div>
  
  <!-- Security Settings -->
  <div id="security-tab" class="tab-content">
    <form action="/api/v1/settings/password" method="POST" data-async>
      <div class="form-group">
        <label for="current_password">Current Password</label>
        <input type="password" id="current_password" name="current_password" required>
        <p>Your current password for verification.</p>
      </div>
      
      <div class="form-group">
        <label for="new_password">New Password</label>
        <input type="password" id="new_password" name="new_password" required>
        <p>Your new password. Use a strong, unique password.</p>
      </div>
      
      <div class="form-group">
        <label for="confirm_password">Confirm New Password</label>
        <input type="password" id="confirm_password" name="confirm_password" required>
        <p>Re-enter your new password to confirm.</p>
      </div>
      
      <button type="submit" class="btn btn-primary">Change Password</button>
    </form>
  </div>
  
  <!-- Preferences Settings -->
  <div id="preferences-tab" class="tab-content">
    <form action="/api/v1/settings/preferences" method="POST" data-async>
      <div class="form-group">
        <label for="store_all_chat">Store All Chat Messages</label>
        <select id="store_all_chat" name="store_all_chat">
          <option value="true" {% if user.store_all_chat %}selected{% endif %}>Enabled</option>
          <option value="false" {% if not user.store_all_chat %}selected{% endif %}>Disabled</option>
        </select>
        <p>When enabled, all chat messages will be stored for context, not just messages directed at your assistant.</p>
      </div>
      
      <div class="form-group">
        <label for="tts_enabled">Text-to-Speech</label>
        <select id="tts_enabled" name="tts_enabled">
          <option value="true" {% if user.tts_enabled %}selected{% endif %}>Enabled</option>
          <option value="false" {% if not user.tts_enabled %}selected{% endif %}>Disabled</option>
        </select>
        <p>Enable or disable text-to-speech for your assistant.</p>
      </div>
      
      <div class="form-group">
        <label for="ttsEqPref">TTS Voice Quality Preset</label>
        <select id="ttsEqPref" name="ttsEqPref">
          <option value="clarity" {% if user.ttsEqPref == 'clarity' %}selected{% endif %}>Clarity</option>
          <option value="warm" {% if user.ttsEqPref == 'warm' %}selected{% endif %}>Warm</option>
          <option value="bright" {% if user.ttsEqPref == 'bright' %}selected{% endif %}>Bright</option>
          <option value="broadcast" {% if user.ttsEqPref == 'broadcast' %}selected{% endif %}>Broadcast</option>
        </select>
        <p>Choose a preset for your assistant's voice quality.</p>
      </div>
      
      <div class="form-group">
        <label for="ttsUpsamplePref">TTS Audio Upsampling</label>
        <select id="ttsUpsamplePref" name="ttsUpsamplePref">
          <option value="true" {% if user.ttsUpsamplePref %}selected{% endif %}>Enabled</option>
          <option value="false" {% if not user.ttsUpsamplePref %}selected{% endif %}>Disabled</option>
        </select>
        <p>Enable or disable audio upsampling for better voice quality (uses more CPU).</p>
      </div>
      
      <button type="submit" class="btn btn-primary">Save Preferences</button>
    </form>
  </div>
</div>
{% endblock %}

{% block extraStyles %}
<style>
  .form-group {
    margin-bottom: 24px;
  }
  
  .form-group label {
    display: block;
    font-weight: 600;
    margin-bottom: 8px;
  }
  
  .form-group p {
    margin-top: 4px;
    font-size: 0.9em;
    color: var(--secondary-text);
  }
  
  .form-group input,
  .form-group select {
    width: 100%;
    max-width: 500px;
  }
  
  .tabs {
    margin-bottom: 20px;
  }
</style>
{% endblock %}
</file>

<file path="views/world.njk">
{% extends "layout.njk" %}

{% block title %}World Editor{% endblock %}

{% block content %}
<div class="card">
  <div class="card-header">
    <h1>World Editor</h1>
  </div>
  
  <p>Define the context and environment for your AI assistant. These settings help create the world in which your assistant exists and operates.</p>
  
  <div class="tabs">
    <div class="tab active" data-target="world-info-tab">World Information</div>
    <div class="tab" data-target="player-info-tab">Player Information</div>
    <div class="tab" data-target="scenario-tab">Scenario</div>
    <div class="tab" data-target="bot-config-tab">Bot Configuration</div>
  </div>
  
  <div id="world-info-tab" class="tab-content active">
    <form action="/api/v1/world/info" method="POST" data-async>
      <div class="form-group">
        <label for="world_info">World Information</label>
        <textarea id="world_info" name="world_info" rows="15" required>{{ worldInfo }}</textarea>
        <p>Describe the setting, background, lore, and context where your assistant exists. This could include fictional elements, time period, relevant history, or any other details that help establish the world.</p>
      </div>
      
      <div class="form-group">
        <label for="weather_enabled">Enable Weather</label>
        <select id="weather_enabled" name="weather_enabled">
          <option value="true" {% if character.weather %}selected{% endif %}>Enabled</option>
          <option value="false" {% if not character.weather %}selected{% endif %}>Disabled</option>
        </select>
        <p>When enabled, your assistant will have access to real-time weather information based on your location.</p>
      </div>
      
      <button type="submit" class="btn btn-primary">Save World Information</button>
    </form>
  </div>
  
  <div id="player-info-tab" class="tab-content">
    <form action="/api/v1/world/player" method="POST" data-async>
      <div class="form-group">
        <label for="player_info">Player Information</label>
        <textarea id="player_info" name="player_info" rows="15" required>{{ playerInfo }}</textarea>
        <p>Information about you (the streamer) that the assistant should know. This could include your preferences, streaming style, topics to focus on or avoid, personal details you're comfortable sharing, etc.</p>
      </div>
      
      <button type="submit" class="btn btn-primary">Save Player Information</button>
    </form>
  </div>
  
  <div id="scenario-tab" class="tab-content">
    <form action="/api/v1/world/scenario" method="POST" data-async>
      <div class="form-group">
        <label for="scenario">Scenario</label>
        <textarea id="scenario" name="scenario" rows="15" required>{{ scenario }}</textarea>
        <p>Describe the specific situation or context in which the assistant is participating. This could be the premise of your stream, the assistant's role, or the ongoing narrative.</p>
      </div>
      
      <button type="submit" class="btn btn-primary">Save Scenario</button>
    </form>
  </div>
  
  <div id="bot-config-tab" class="tab-content">
    <form action="/api/v1/world/bot-config" method="POST" data-async>
      <div class="form-group">
        <label for="commands_list">Chat Commands</label>
        <textarea id="commands_list" name="commands_list" rows="5">{{ commandsList }}</textarea>
        <p>List of chat commands your bot should recognize but not respond to (one per line, e.g., !discord, !socials).</p>
      </div>
      
      <div class="form-group">
        <label for="aux_bots">Auxiliary Bots</label>
        <textarea id="aux_bots" name="aux_bots" rows="5">{{ auxBots }}</textarea>
        <p>List of other bot usernames in your chat that your assistant should ignore (one per line, e.g., Nightbot, StreamElements).</p>
      </div>
      
      <button type="submit" class="btn btn-primary">Save Bot Configuration</button>
    </form>
  </div>
</div>
{% endblock %}

{% block extraScripts %}
<script>
  // Auto-resize textareas as content grows
  document.addEventListener('DOMContentLoaded', () => {
    const textareas = document.querySelectorAll('textarea');
    textareas.forEach(textarea => {
      const adjustHeight = () => {
        textarea.style.height = 'auto';
        textarea.style.height = (textarea.scrollHeight) + 'px';
      };
      
      // Initial adjustment
      adjustHeight();
      
      // Adjust on input
      textarea.addEventListener('input', adjustHeight);
      
      // Adjust when tab is shown
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
          setTimeout(adjustHeight, 10);
        });
      });
    });
  });
</script>
{% endblock %}
</file>

<file path=".cache_ggshield">
{"last_found_secrets": [{"name": "X-API-Key Secret - commit://11c6c9bf712f664abba77430c40c05dfbef277bf/api-helper.js", "match": "cdffb8af31330a4950b3ed169ccb734b93d10f4980bffddc814bf4598f1e4359"}]}
</file>

<file path="response-monitor.js">
// response-monitor.js
import { logger } from './create-global-logger.js';
import fs from 'fs-extra';
import path from 'path';

// Simple in-memory stats
const responseStats = {
  totalRequests: 0,
  largeResponses: 0,  // Responses over 50KB
  hugeResponses: 0,   // Responses over 500KB
  emptyResponses: 0,  // Empty or failed responses
  lastReset: Date.now(),
  largeResponseTimestamps: [], // Track when large responses occurred
  responseSizes: []  // Store recent response sizes for analysis
};

// Keep only the most recent 100 response sizes
const MAX_HISTORY = 100;

/**
 * Records statistics about a response
 * @param {string} responseType - The type of response (e.g., 'chat', 'event', 'voice')
 * @param {any} responseBody - The response body
 * @param {string} userId - The user ID
 * @param {boolean} success - Whether the request was successful
 */
export function recordResponseStats(responseType, responseBody, userId, success = true) {
  responseStats.totalRequests++;
  
  // Handle empty or failed responses
  if (!success || !responseBody || responseBody.error) {
    responseStats.emptyResponses++;
    logger.log("Monitor", `Empty/failed ${responseType} response recorded for user ${userId}`);
    return;
  }
  
  // Calculate response size
  let responseSize = 0;
  if (typeof responseBody === 'string') {
    responseSize = responseBody.length;
  } else if (responseBody.response && typeof responseBody.response === 'string') {
    responseSize = responseBody.response.length;
  } else {
    responseSize = JSON.stringify(responseBody).length;
  }
  
  // Record the size
  responseStats.responseSizes.push({
    timestamp: Date.now(),
    size: responseSize,
    type: responseType,
    userId
  });
  
  // Trim history if needed
  if (responseStats.responseSizes.length > MAX_HISTORY) {
    responseStats.responseSizes.shift();
  }
  
  // Track large responses
  if (responseSize > 50000) { // 50KB
    responseStats.largeResponses++;
    responseStats.largeResponseTimestamps.push(Date.now());
    
    // Only keep the last 20 timestamps
    if (responseStats.largeResponseTimestamps.length > 20) {
      responseStats.largeResponseTimestamps.shift();
    }
    
    logger.log("Monitor", `Large ${responseType} response (${(responseSize/1024).toFixed(2)}KB) recorded for user ${userId}`);
    
    // Check for response burst (more than 5 large responses in 5 minutes)
    const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
    const recentLargeResponses = responseStats.largeResponseTimestamps.filter(
      timestamp => timestamp > fiveMinutesAgo
    );
    
    if (recentLargeResponses.length > 5) {
      logger.log("Monitor", `WARNING: Burst of large responses detected (${recentLargeResponses.length} in 5 minutes)`);
    }
  }
  
  // Track huge responses
  if (responseSize > 500000) { // 500KB
    responseStats.hugeResponses++;
    logger.log("Monitor", `ALERT: Huge ${responseType} response (${(responseSize/1024).toFixed(2)}KB) for user ${userId}`);
    
    // If you want to save examples of huge responses for analysis
    try {
      const logsDir = path.join(process.cwd(), 'logs', 'huge_responses');
      fs.ensureDirSync(logsDir);
      const filePath = path.join(logsDir, `huge_response_${Date.now()}_${responseType}_${userId}.json`);
      fs.writeJSONSync(filePath, {
        type: responseType,
        userId,
        timestamp: new Date().toISOString(),
        size: responseSize,
        sample: typeof responseBody === 'string' 
          ? responseBody.substring(0, 10000) 
          : JSON.stringify(responseBody).substring(0, 10000)
      }, { spaces: 2 });
    } catch (err) {
      logger.log("Monitor", `Error saving huge response sample: ${err.message}`);
    }
  }
}

/**
 * Gets current response statistics
 * @returns {Object} The current response statistics
 */
export function getResponseStats() {
  // Calculate some additional metrics
  const uptime = Math.floor((Date.now() - responseStats.lastReset) / 1000);
  
  // Calculate percentiles if we have data
  let p50 = 0, p95 = 0, p99 = 0;
  if (responseStats.responseSizes.length > 0) {
    // Sort by size
    const sortedSizes = [...responseStats.responseSizes]
      .map(item => item.size)
      .sort((a, b) => a - b);
    
    const getPercentile = (arr, p) => {
      const index = Math.floor(arr.length * p / 100);
      return arr[index];
    };
    
    p50 = getPercentile(sortedSizes, 50);
    p95 = getPercentile(sortedSizes, 95);
    p99 = getPercentile(sortedSizes, 99);
  }
  
  return {
    ...responseStats,
    uptime,
    emptyResponseRate: responseStats.totalRequests 
      ? (responseStats.emptyResponses / responseStats.totalRequests * 100).toFixed(2)
      : 0,
    largeResponseRate: responseStats.totalRequests 
      ? (responseStats.largeResponses / responseStats.totalRequests * 100).toFixed(2)
      : 0,
    responseSizePercentiles: {
      p50: (p50 / 1024).toFixed(2) + ' KB',
      p95: (p95 / 1024).toFixed(2) + ' KB',
      p99: (p99 / 1024).toFixed(2) + ' KB'
    }
  };
}

/**
 * Resets the response statistics
 */
export function resetResponseStats() {
  Object.assign(responseStats, {
    totalRequests: 0,
    largeResponses: 0,
    hugeResponses: 0,
    emptyResponses: 0,
    lastReset: Date.now(),
    largeResponseTimestamps: [],
    responseSizes: []
  });
  
  logger.log("Monitor", "Response statistics have been reset");
}

/**
 * Adds the response monitoring middleware to a Fastify instance
 * @param {FastifyInstance} fastify - The Fastify instance to add the middleware to
 */
export function addResponseMonitoring(fastify) {
  // Add response hook
  fastify.addHook('onResponse', (request, reply, done) => {
    try {
      // Get the route
      const route = request.routeOptions?.url || request.url;
      
      // Only monitor actual API endpoints
      if (route.includes('/v1/') && ['POST', 'PUT'].includes(request.method)) {
        const responseTime = reply.getResponseTime();
        const userId = reply.request.headers?.authorization 
          ? reply.request.headers.authorization.split(' ')[1]
          : 'unknown';
        
        // Record response code
        if (reply.statusCode >= 400) {
          recordResponseStats(
            route.split('/').pop(), 
            { error: `HTTP ${reply.statusCode}` }, 
            userId, 
            false
          );
        }
        
        // Log slow responses
        if (responseTime > 5000) {
          logger.log("Monitor", `Slow response detected: ${responseTime.toFixed(0)}ms for ${route}`);
        }
      }
    } catch (err) {
      // Don't let monitoring errors affect the application
      logger.log("Monitor", `Error in response monitoring: ${err.message}`);
    }
    
    done();
  });
  
  // Add status endpoint
  fastify.get('/admin/response-stats', async (request, reply) => {
    // Optional basic auth for this endpoint
    const auth = request.headers.authorization;
    const validAuth = 'Basic ' + Buffer.from('admin:admin123').toString('base64');
    
    if (auth !== validAuth) {
      reply.status(401).send({ error: 'Unauthorized' });
      return;
    }
    
    reply.send(getResponseStats());
  });
  
  // Add reset endpoint
  fastify.post('/admin/response-stats/reset', async (request, reply) => {
    // Optional basic auth for this endpoint
    const auth = request.headers.authorization;
    const validAuth = 'Basic ' + Buffer.from('admin:admin123').toString('base64');
    
    if (auth !== validAuth) {
      reply.status(401).send({ error: 'Unauthorized' });
      return;
    }
    
    resetResponseStats();
    reply.send({ success: true, message: 'Response statistics have been reset' });
  });
  
  // Log initial setup
  logger.log("Monitor", "Response monitoring has been enabled");
}
</file>

<file path="restart-helper.js">
// restart-helper.js
// This script is used to restart the main application
// It's executed as a detached child process when the restart command is issued

import { spawn } from 'child_process';
import { setTimeout } from 'timers/promises';

// Wait for the parent process to exit
await setTimeout(1000);

// Start the application again
const app = spawn('node', ['main.js'], {
  detached: true,
  stdio: 'inherit'
});

// Detach from the child process so it can run independently
app.unref();

// Exit this helper
process.exit(0);
</file>

<file path="start.bat">
@echo off
node main.js
</file>

<file path="twitch-webhook-tester.js">
// twitch-webhook-tester.js
import axios from 'axios';
import crypto from 'crypto';
import { retrieveConfigValue } from './config-helper.js';
import { returnAuthObject } from './api-helper.js';
import { logger } from './create-global-logger.js';

/**
 * Utility to test Twitch EventSub webhooks by sending mock notifications
 * to your local webhook endpoint
 */
class TwitchWebhookTester {
  constructor() {
    this.messageId = crypto.randomUUID();
    this.timestamp = new Date().toISOString();
  }

  /**
   * Initialize the tester with user-specific data
   * @param {string} userId - The user ID to test with
   * @returns {Promise<boolean>} - Whether initialization succeeded
   */
  async initialize(userId) {
    try {
      // Get the user's data
      this.user = await returnAuthObject(userId);
      if (!this.user) {
        logger.error("Twitch Tester", `User ${userId} not found`);
        return false;
      }

      // Check if user has Twitch integration
      if (!this.user.twitch_tokens?.streamer?.twitch_user_id) {
        logger.error("Twitch Tester", `User ${userId} has no Twitch ID configured`);
        return false;
      }

      // Get webhook secret
      this.webhookSecret = this.user.twitch_tokens.streamer.webhook_secret;
      if (!this.webhookSecret) {
        logger.error("Twitch Tester", `No webhook secret found for user ${userId}`);
        return false;
      }

      // Get the local webhook URL
      const serverEndpoint = await retrieveConfigValue("server.endpoints.internal");
      const serverPort = await retrieveConfigValue("server.port");
      this.webhookUrl = `http://${serverEndpoint}:${serverPort}/api/v1/twitch/eventsub/${userId}`;

      this.twitchUserId = this.user.twitch_tokens.streamer.twitch_user_id;
      this.twitchUserName = this.user.twitch_tokens.streamer.twitch_display_name || this.user.twitch_name;
      
      logger.log("Twitch Tester", `Initialized for user ${userId} (${this.twitchUserName})`);
      return true;
    } catch (error) {
      logger.error("Twitch Tester", `Initialization error: ${error.message}`);
      return false;
    }
  }

  /**
   * Sign a message with the webhook secret using HMAC SHA-256
   * @param {string} messageId - The message ID
   * @param {string} timestamp - The timestamp
   * @param {string} payload - The JSON payload as a string
   * @returns {string} - The signature
   */
  signMessage(messageId, timestamp, payload) {
    const hmacMessage = messageId + timestamp + payload;
    const signature = crypto.createHmac('sha256', this.webhookSecret)
      .update(hmacMessage)
      .digest('hex');
    return `sha256=${signature}`;
  }

  /**
   * Send a test notification to the webhook endpoint
   * @param {object} payload - The notification payload
   * @param {string} type - The notification type
   * @returns {Promise<object>} - The response
   */
  async sendNotification(payload, type = 'notification') {
    try {
      // Convert payload to string
      const stringPayload = JSON.stringify(payload);
      
      // Sign the message
      const signature = this.signMessage(this.messageId, this.timestamp, stringPayload);
      
      // Set up headers like Twitch would
      const headers = {
        'Content-Type': 'application/json',
        'Twitch-Eventsub-Message-Id': this.messageId,
        'Twitch-Eventsub-Message-Timestamp': this.timestamp,
        'Twitch-Eventsub-Message-Signature': signature,
        'Twitch-Eventsub-Message-Type': type,
        'Twitch-Eventsub-Subscription-Version': '1'
      };
      
      logger.log("Twitch Tester", `Sending ${payload.subscription.type} test notification to ${this.webhookUrl}`);
      
      // Send the request
      const response = await axios.post(this.webhookUrl, payload, { headers });
      
      return {
        success: true,
        status: response.status,
        statusText: response.statusText,
        data: response.data,
        messageSent: payload
      };
    } catch (error) {
      logger.error("Twitch Tester", `Error sending notification: ${error.message}`);
      return {
        success: false,
        error: error.message,
        status: error.response?.status,
        statusText: error.response?.statusText,
        data: error.response?.data,
        messageSent: payload
      };
    }
  }

  /**
   * Test a follow event
   * @param {object} options - Additional options
   * @returns {Promise<object>} - The response
   */
  async testFollow(options = {}) {
    const followerName = options.followerName || 'TestFollower';
    const followerId = options.followerId || '987654321';
    
    const payload = {
      subscription: {
        id: crypto.randomUUID(),
        type: 'channel.follow',
        version: '2',
        status: 'enabled',
        cost: 1,
        condition: {
          broadcaster_user_id: this.twitchUserId,
          moderator_user_id: this.twitchUserId
        },
        transport: {
          method: 'webhook',
          callback: 'https://example.com/webhook'
        },
        created_at: new Date().toISOString()
      },
      event: {
        user_id: followerId,
        user_name: followerName,
        user_login: followerName.toLowerCase(),
        broadcaster_user_id: this.twitchUserId,
        broadcaster_user_name: this.twitchUserName,
        broadcaster_user_login: this.twitchUserName.toLowerCase(),
        followed_at: new Date().toISOString()
      }
    };
    
    return this.sendNotification(payload);
  }

  /**
   * Test a chat message event
   * @param {object} options - Additional options
   * @returns {Promise<object>} - The response
   */
  async testChatMessage(options = {}) {
    const chatterName = options.chatterName || 'TestChatter';
    const chatterId = options.chatterId || '123456789';
    const message = options.message || `Hello @${this.twitchUserName}, this is a test message!`;
    const isFirstMessage = options.isFirstMessage || false;
    
    const payload = {
      subscription: {
        id: crypto.randomUUID(),
        type: 'channel.chat.message',
        version: '1',
        status: 'enabled',
        cost: 1,
        condition: {
          broadcaster_user_id: this.twitchUserId,
          user_id: chatterId
        },
        transport: {
          method: 'webhook',
          callback: 'https://example.com/webhook'
        },
        created_at: new Date().toISOString()
      },
      event: {
        broadcaster_user_id: this.twitchUserId,
        broadcaster_user_login: this.twitchUserName.toLowerCase(),
        broadcaster_user_name: this.twitchUserName,
        chatter: {
          user_id: chatterId,
          user_login: chatterName.toLowerCase(),
          user_name: chatterName,
          color: "#FF0000",
          badges: []
        },
        message: {
          text: message,
          fragments: [
            {
              type: "text",
              text: message,
              cheermote: null
            }
          ],
          is_first: isFirstMessage
        },
        sent_at: new Date().toISOString()
      }
    };
    
    return this.sendNotification(payload);
  }

  /**
   * Test a subscription event
   * @param {object} options - Additional options
   * @returns {Promise<object>} - The response
   */
  async testSubscription(options = {}) {
    const subscriberName = options.subscriberName || 'TestSubscriber';
    const subscriberId = options.subscriberId || '123456789';
    const tier = options.tier || '1000';
    const isGift = options.isGift || false;
    
    const payload = {
      subscription: {
        id: crypto.randomUUID(),
        type: 'channel.subscribe',
        version: '1',
        status: 'enabled',
        cost: 1,
        condition: {
          broadcaster_user_id: this.twitchUserId
        },
        transport: {
          method: 'webhook',
          callback: 'https://example.com/webhook'
        },
        created_at: new Date().toISOString()
      },
      event: {
        user_id: subscriberId,
        user_login: subscriberName.toLowerCase(),
        user_name: subscriberName,
        broadcaster_user_id: this.twitchUserId,
        broadcaster_user_login: this.twitchUserName.toLowerCase(),
        broadcaster_user_name: this.twitchUserName,
        tier: tier,
        is_gift: isGift
      }
    };
    
    return this.sendNotification(payload);
  }

  /**
   * Test a stream online event
   * @param {object} options - Additional options
   * @returns {Promise<object>} - The response
   */
  async testStreamOnline(options = {}) {
    const streamType = options.streamType || 'live';
    
    const payload = {
      subscription: {
        id: crypto.randomUUID(),
        type: 'stream.online',
        version: '1',
        status: 'enabled',
        cost: 1,
        condition: {
          broadcaster_user_id: this.twitchUserId
        },
        transport: {
          method: 'webhook',
          callback: 'https://example.com/webhook'
        },
        created_at: new Date().toISOString()
      },
      event: {
        id: crypto.randomUUID(),
        broadcaster_user_id: this.twitchUserId,
        broadcaster_user_login: this.twitchUserName.toLowerCase(),
        broadcaster_user_name: this.twitchUserName,
        type: streamType,
        started_at: new Date().toISOString()
      }
    };
    
    return this.sendNotification(payload);
  }

  /**
   * Test a channel update event
   * @param {object} options - Additional options
   * @returns {Promise<object>} - The response
   */
  async testChannelUpdate(options = {}) {
    const title = options.title || 'Test Stream Title';
    const categoryName = options.categoryName || 'Just Chatting';
    const categoryId = options.categoryId || '509658';
    
    const payload = {
      subscription: {
        id: crypto.randomUUID(),
        type: 'channel.update',
        version: '1',
        status: 'enabled',
        cost: 1,
        condition: {
          broadcaster_user_id: this.twitchUserId
        },
        transport: {
          method: 'webhook',
          callback: 'https://example.com/webhook'
        },
        created_at: new Date().toISOString()
      },
      event: {
        broadcaster_user_id: this.twitchUserId,
        broadcaster_user_login: this.twitchUserName.toLowerCase(),
        broadcaster_user_name: this.twitchUserName,
        title: title,
        language: 'en',
        category_id: categoryId,
        category_name: categoryName,
        is_mature: false
      }
    };
    
    return this.sendNotification(payload);
  }

  /**
   * Test a raid event
   * @param {object} options - Additional options
   * @returns {Promise<object>} - The response
   */
  async testRaid(options = {}) {
    const raiderName = options.raiderName || 'TestRaider';
    const raiderId = options.raiderId || '987654321';
    const viewers = options.viewers || 42;
    
    const payload = {
      subscription: {
        id: crypto.randomUUID(),
        type: 'channel.raid',
        version: '1',
        status: 'enabled',
        cost: 1,
        condition: {
          to_broadcaster_user_id: this.twitchUserId
        },
        transport: {
          method: 'webhook',
          callback: 'https://example.com/webhook'
        },
        created_at: new Date().toISOString()
      },
      event: {
        from_broadcaster_user_id: raiderId,
        from_broadcaster_user_login: raiderName.toLowerCase(),
        from_broadcaster_user_name: raiderName,
        to_broadcaster_user_id: this.twitchUserId,
        to_broadcaster_user_login: this.twitchUserName.toLowerCase(),
        to_broadcaster_user_name: this.twitchUserName,
        viewers: viewers
      }
    };
    
    return this.sendNotification(payload);
  }
}

/**
 * Command-line interface to test Twitch webhooks
 */
async function runCLI() {
  // Parse command line arguments
  const args = process.argv.slice(2);
  
  // Show help if no args or help requested
  if (args.length === 0 || args.includes('--help') || args.includes('-h')) {
    console.log(`
Twitch EventSub Webhook Tester
==============================

Usage: node twitch-webhook-tester.js <command> <userId> [options]

Commands:
  follow        Test a channel.follow event
  chat          Test a channel.chat.message event
  sub           Test a channel.subscribe event
  online        Test a stream.online event
  update        Test a channel.update event
  raid          Test a channel.raid event

Options:
  --help, -h    Show this help message
  --firstmsg    For chat messages, mark as first message from user
  --message     Custom message for chat events
  --name        Custom name for the event source (follower, subscriber, etc.)
  --viewers     Number of viewers for raid events
  --title       Stream title for channel update events
  --game        Game/category name for channel update events

Example:
  node twitch-webhook-tester.js chat my_user_id --message "Hello @streamer!" --name "TestUser"
  node twitch-webhook-tester.js follow my_user_id --name "NewFollower123"
  node twitch-webhook-tester.js raid my_user_id --name "RaidingChannel" --viewers 100
    `);
    return;
  }

  // Extract command and userId
  const [command, userId] = args;
  
  // Parse options
  const options = {};
  for (let i = 2; i < args.length; i += 2) {
    if (args[i].startsWith('--')) {
      const key = args[i].substring(2);
      const value = args[i + 1];
      
      // Handle boolean flags (no value)
      if (!value || value.startsWith('--')) {
        options[key] = true;
        i -= 1; // Adjust index since we didn't consume a value
      } else {
        options[key] = value;
      }
    }
  }
  
  // Map some options to expected property names
  if (options.name) {
    if (command === 'follow') options.followerName = options.name;
    if (command === 'chat') options.chatterName = options.name;
    if (command === 'sub') options.subscriberName = options.name;
    if (command === 'raid') options.raiderName = options.name;
  }
  
  if (options.game) options.categoryName = options.game;
  if (options.firstmsg) options.isFirstMessage = true;
  
  // Initialize tester
  const tester = new TwitchWebhookTester();
  const initSuccess = await tester.initialize(userId);
  
  if (!initSuccess) {
    console.log('Failed to initialize webhook tester. Check logs for details.');
    return;
  }
  
  // Execute the specified command
  let result;
  switch (command) {
    case 'follow':
      result = await tester.testFollow(options);
      break;
    case 'chat':
      result = await tester.testChatMessage(options);
      break;
    case 'sub':
      result = await tester.testSubscription(options);
      break;
    case 'online':
      result = await tester.testStreamOnline(options);
      break;
    case 'update':
      result = await tester.testChannelUpdate(options);
      break;
    case 'raid':
      result = await tester.testRaid(options);
      break;
    default:
      console.log(`Unknown command: ${command}`);
      return;
  }
  
  if (result.success) {
    console.log(`✅ Successfully sent ${command} test event`);
    console.log(`Status: ${result.status} ${result.statusText}`);
  } else {
    console.log(`❌ Failed to send ${command} test event`);
    console.log(`Error: ${result.error}`);
    if (result.status) {
      console.log(`Status: ${result.status} ${result.statusText}`);
    }
  }
}

// If this file is run directly, execute the CLI
if (import.meta.url === import.meta.resolve('./twitch-webhook-tester.js')) {
  runCLI();
}

export default TwitchWebhookTester;
</file>

<file path="websocket-test-client.js">
#!/usr/bin/env node

/**
 * Simple WebSocket test client for Enspira VTuber integration
 * Tests connection, authentication, and basic message flow
 */

import WebSocket from 'ws';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

class WebSocketTestClient {
  constructor(serverUrl, authToken) {
    this.serverUrl = serverUrl;
    this.authToken = authToken;
    this.ws = null;
    this.isConnected = false;
    this.isAuthenticated = false;
    this.messageCount = 0;
    
    console.log('🔧 WebSocket Test Client initialized');
    console.log(`   Server URL: ${this.serverUrl}`);
    console.log(`   Auth Token: ${this.authToken ? 'Provided' : 'NOT PROVIDED'}`);
  }

  /**
   * Connect to the WebSocket server
   */
  async connect() {
    return new Promise((resolve, reject) => {
      try {
        console.log(`\n🔌 Attempting to connect to: ${this.serverUrl}`);
        
        // Configure WebSocket options for self-signed certificates
        const wsOptions = {
          rejectUnauthorized: false, // Allow self-signed certificates
          headers: {
            'User-Agent': 'Enspira-WebSocket-Test-Client/1.0'
          }
        };

        this.ws = new WebSocket(this.serverUrl, wsOptions);
        
        this.ws.on('open', () => {
          console.log('✅ WebSocket connection established successfully!');
          this.isConnected = true;
          resolve();
        });

        this.ws.on('message', (data) => {
          this.handleMessage(data);
        });

        this.ws.on('close', (code, reason) => {
          console.log(`\n❌ WebSocket connection closed: ${code} - ${reason}`);
          this.isConnected = false;
          this.isAuthenticated = false;
        });

        this.ws.on('error', (error) => {
          console.error(`\n❌ WebSocket error: ${error.message}`);
          console.error('Full error:', error);
          reject(error);
        });

        // Set connection timeout
        setTimeout(() => {
          if (!this.isConnected) {
            this.ws?.close();
            reject(new Error('Connection timeout after 10 seconds'));
          }
        }, 10000);

      } catch (error) {
        console.error('❌ Error creating WebSocket:', error);
        reject(error);
      }
    });
  }

  /**
   * Handle incoming messages from server
   */
  handleMessage(data) {
    try {
      const message = JSON.parse(data.toString());
      this.messageCount++;
      
      console.log(`\n📨 Message #${this.messageCount} received:`);
      console.log(`   Type: ${message.type}`);
      console.log(`   Timestamp: ${message.timestamp || 'N/A'}`);

      switch (message.type) {
        case 'connection-established':
          console.log(`   ✅ Connection established with client ID: ${message.client_id}`);
          break;

        case 'auth-required':
          console.log('   🔐 Server requesting authentication...');
          this.sendAuthentication();
          break;

        case 'auth-success':
          console.log('   ✅ Authentication successful!');
          console.log(`   User ID: ${message.user_id || 'Unknown'}`);
          this.isAuthenticated = true;
          this.startTests();
          break;

        case 'auth-failed':
          console.error('   ❌ Authentication failed:', message.message);
          break;

        case 'ping':
          console.log('   🏓 Received ping, sending pong...');
          this.sendMessage({ type: 'pong' });
          break;

        case 'pong':
          console.log('   🏓 Pong received - connection alive');
          break;

        case 'connection-test-response':
          console.log('   ✅ Connection test successful:', message.message);
          break;

        case 'response-queued':
          console.log(`   ⏳ AI response queued with ID: ${message.response_id}`);
          break;

        case 'full-text':
          console.log(`   💬 AI Response: "${message.text}"`);
          break;

        case 'model-info-received':
          console.log('   ✅ Model info acknowledged:', message.message);
          break;

        case 'error':
          console.error('   ❌ Server error:', message.message);
          break;

        default:
          console.log(`   ❓ Unknown message type: ${message.type}`);
          if (message.message) {
            console.log(`   Message: ${message.message}`);
          }
      }
    } catch (error) {
      console.error('❌ Error parsing message:', error.message);
      console.error('Raw message:', data.toString());
    }
  }

  /**
   * Send authentication token to server
   */
  sendAuthentication() {
    console.log('📤 Sending authentication...');
    this.sendMessage({
      type: 'auth',
      auth_token: this.authToken
    });
  }

  /**
   * Send a message to the WebSocket server
   */
  sendMessage(message) {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      const jsonMessage = JSON.stringify(message);
      this.ws.send(jsonMessage);
      console.log(`📤 Sent: ${message.type}`);
    } else {
      console.error('❌ Cannot send message: WebSocket not connected');
      console.log(`   WebSocket state: ${this.ws?.readyState || 'undefined'}`);
    }
  }

  /**
   * Run a series of tests to verify WebSocket functionality
   */
  async startTests() {
    console.log('\n🧪 Starting WebSocket functionality tests...\n');

    try {
      // Test 1: Connection test
      await this.delay(1000);
      console.log('🔬 Test 1: Connection test');
      this.sendMessage({ type: 'connection-test' });

      // Test 2: Model info
      await this.delay(2000);
      console.log('🔬 Test 2: Sending model info');
      this.sendMessage({
        type: 'model-info',
        model_info: {
          name: 'Test VTuber Model',
          version: '1.0.0',
          expressions: ['neutral', 'happy', 'sad', 'surprised']
        }
      });

      // Test 3: Text input
      await this.delay(2000);
      console.log('🔬 Test 3: Sending text input');
      this.sendMessage({
        type: 'text-input',
        text: 'Hello, this is a test message from the WebSocket test client!'
      });

      // Test 4: Ping manually
      await this.delay(3000);
      console.log('🔬 Test 4: Manual ping test');
      this.sendMessage({ type: 'ping' });

      // Test 5: Another text input
      await this.delay(2000);
      console.log('🔬 Test 5: Another text input test');
      this.sendMessage({
        type: 'text-input',
        text: 'Can you confirm that the WebSocket connection is working properly?'
      });

      console.log('\n✅ All tests sent! Waiting for responses...\n');
      
      // Keep connection alive for responses
      setTimeout(() => {
        console.log('\n🔚 Test sequence completed. Closing connection...');
        this.disconnect();
      }, 15000);

    } catch (error) {
      console.error('❌ Error during tests:', error);
      this.disconnect();
    }
  }

  /**
   * Utility function to add delays between tests
   */
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Disconnect from WebSocket server
   */
  disconnect() {
    if (this.ws) {
      console.log('🔌 Disconnecting...');
      this.ws.close(1000, 'Test completed');
      this.ws = null;
    }
  }
}

/**
 * Main test function
 */
async function runWebSocketTest() {
  console.log('🚀 Enspira WebSocket Test Client Starting...\n');
  
  // Configuration - update these values for your setup
  const SERVER_PORT = 443; // Update with your server port
  const SERVER_HOST = 'enspira.tools'; // Update with your server host  
  const USE_HTTPS = true; // Set to true if using HTTPS/WSS
  const AUTH_TOKEN = 'd194dc9c75eaa9695d826f069a769bbf5eaf85a4bd8f7d50'; // Update with a valid auth token

  const protocol = USE_HTTPS ? 'wss' : 'ws';
  const serverUrl = `${protocol}://${SERVER_HOST}:${SERVER_PORT}/ws-client`;

  console.log('📋 Configuration:');
  console.log(`   Server URL: ${serverUrl}`);
  console.log(`   Protocol: ${protocol.toUpperCase()}`);
  console.log(`   Auth Token: ${AUTH_TOKEN && AUTH_TOKEN !== 'your-test-auth-token-here' ? 'Valid token provided' : 'NO VALID TOKEN'}`);

  if (!AUTH_TOKEN || AUTH_TOKEN === 'your-test-auth-token-here') {
    console.warn('\n⚠️  WARNING: No valid auth token provided!');
    console.warn('   Authentication will fail unless you update AUTH_TOKEN');
    console.warn('   Get a valid token from your Enspira API keys configuration\n');
  }

  const testClient = new WebSocketTestClient(serverUrl, AUTH_TOKEN);

  try {
    await testClient.connect();
    console.log('⏳ Waiting for server messages...');
    // Tests will start automatically after authentication
  } catch (error) {
    console.error('\n❌ Test failed with error:', error.message);
    
    // Provide detailed troubleshooting
    console.log('\n🔧 Troubleshooting steps:');
    console.log('1. 📡 Ensure your Enspira server is running');
    console.log(`2. 🔌 Verify server is listening on ${SERVER_HOST}:${SERVER_PORT}`);
    console.log('3. 🛡️  Check firewall allows connections on this port');
    console.log('4. 🔍 Check server logs for WebSocket errors');
    
    if (error.message.includes('ECONNREFUSED')) {
      console.log('5. ❌ Connection refused - server may not be running');
    }
    
    if (error.message.includes('certificate') || error.message.includes('SSL')) {
      console.log('5. 🔒 SSL/Certificate issue - try setting USE_HTTPS = false');
    }
    
    if (error.message.includes('timeout')) {
      console.log('5. ⏰ Connection timeout - server may be slow to respond');
    }

    console.log('\n💡 Quick test: Try accessing your server status page first');
    console.log(`   ${USE_HTTPS ? 'https' : 'http'}://${SERVER_HOST}:${SERVER_PORT}/ws-status`);
    
    process.exit(1);
  }
}

// Run the test
console.log('Starting WebSocket test client...\n');
runWebSocketTest().catch(error => {
  console.error('Fatal error:', error);
  process.exit(1);
});
</file>

<file path="views/character-details.njk">
{% extends "layout.njk" %}

{% block title %}{{ character.name }}{% endblock %}

{% block content %}
<div class="card character-header">
  <div class="character-avatar-large">
    <img src="{{ character.image }}" alt="{{ character.name }} Avatar" class="fade-in-image">
  </div>
  <div class="character-meta">
    <h1>{{ character.name }}</h1>
    <p class="author">by: {{ character.author }}</p>
    <p class="summary">{{ character.summary }}</p>
    <form action="/api/v1/gallery/{{ character.id }}/use" method="POST" data-async>
      <button type="submit" class="btn btn-primary btn-use-char">Use This Character</button>
    </form>
  </div>
</div>

<div class="card">
  <h2>Personality</h2>
  <div class="character-content-public">
    {% if character.personality.publicFmt %}
      {{ character.personality.publicFmt }}
    {% else %}
      <pre class="character-content">{{ character.personality }}</pre>
    {% endif %}
  </div>
</div>

<div class="card">
  <h2>Description</h2>
  <div class="character-content-public">
    {% if character.char_description.publicFmt %}
      {{ character.char_description.publicFmt }}
    {% else %}
      <pre class="character-content">{{ character.char_description }}</pre>
    {% endif %}
  </div>
</div>
{% endblock %}

{% block extraStyles %}
<style>
  .character-header {
    display: flex;
    gap: 30px;
    align-items: flex-start; /* Align items to the top */
  }

  .character-avatar-large {
    flex-shrink: 0;
    width: 200px;
    height: 200px;
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid var(--border);
    background-color: var(--background);
  }

  .character-avatar-large img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: top center; /* Align to top */
    display: block;
    opacity: 0; /* Start invisible */
    transition: opacity 0.5s ease-in-out;
  }
  
  .character-avatar-large img.loaded {
    opacity: 1; /* Fade in when loaded */
  }

  .character-meta {
    flex-grow: 1;
  }

  .character-meta h1 {
    margin-top: 0;
    margin-bottom: 5px;
  }

  .character-meta .author {
    color: var(--secondary-text);
    font-style: italic;
    margin-bottom: 15px;
  }

  .character-meta .summary {
    color: var(--primary-text);
    margin-bottom: 20px;
    font-size: 1.05em;
  }

  .character-content {
    background-color: var(--input-bg);
    padding: 15px;
    border-radius: 6px;
    white-space: pre-wrap; /* Allows wrapping */
    word-wrap: break-word; /* Ensures long words break */
    font-family: monospace;
    border: 1px solid var(--border);
  }
  
  .character-content-public {
    background-color: var(--input-bg);
    padding: 15px;
    border-radius: 6px;
    border: 1px solid var(--border);
    line-height: 1.5;
  }

  .btn-use-char {
    margin-top: 10px; /* Add some space above the button */
  }

  @media (max-width: 600px) {
    .character-header {
      flex-direction: column;
      align-items: center;
      text-align: center;
    }

    .character-avatar-large {
      width: 150px;
      height: 150px;
      margin-bottom: 15px;
    }
  }
</style>
{% endblock %}

{% block extraScripts %}
<script>
  // Add fade-in functionality for images
  document.addEventListener('DOMContentLoaded', () => {
    const images = document.querySelectorAll('.fade-in-image');
    
    images.forEach(img => {
      // For images that are already loaded from cache
      if (img.complete) {
        img.classList.add('loaded');
      } else {
        // For images that need to be loaded
        img.addEventListener('load', () => {
          img.classList.add('loaded');
        });
        
        // Fallback in case image fails to load
        img.addEventListener('error', () => {
          img.classList.add('loaded');
        });
      }
    });
  });
</script>
{% endblock %}
</file>

<file path="views/gallery.njk">
{% extends "layout.njk" %}

{% block title %}Character Gallery{% endblock %}

{% block content %}
<div class="card">
  <div class="card-header">
    <h1>Character Gallery</h1>
  </div>
  <p>Choose a pre-defined character preset for your AI assistant. Click on a character to see more details and apply the preset.</p>
</div>

{% if presets %}
<div class="gallery-grid">
  {% for preset in presets %}
  <a href="/web/gallery/{{ preset.id }}" class="card preset-card">
    <div class="preset-image">
      <img src="{{ preset.image }}" alt="{{ preset.name }} Avatar" loading="lazy" class="fade-in-image">
    </div>
    <div class="preset-info">
      <h3 class="preset-name">{{ preset.name }}</h3>
      <p class="preset-author">by: {{ preset.author }}</p>
    </div>
  </a>
  {% endfor %}
</div>
{% else %}
<div class="card">
  <p>No character presets found. Please check the 'presets' directory.</p>
</div>
{% endif %}
{% endblock %}

{% block extraStyles %}
<style>
  .gallery-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
    gap: 20px;
    margin-top: 20px;
  }

  .preset-card {
    text-decoration: none;
    color: var(--primary-text);
    transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    display: flex;
    flex-direction: column;
    overflow: hidden; /* Ensure image corners are rounded */
    padding: 0; /* Remove default card padding */
  }

  .preset-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
    text-decoration: none;
    color: var(--accent-hover);
  }

  .preset-image {
    width: 100%;
    aspect-ratio: 1 / 1; /* Square aspect ratio for images */
    background-color: var(--background); /* Fallback color */
    overflow: hidden;
    position: relative;
  }

  .preset-image img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: top center; /* Align to top */
    display: block;
    border-bottom: 1px solid var(--border);
    opacity: 0; /* Start with invisible image */
    transition: opacity 0.4s ease-in-out;
  }

  .preset-image img.loaded {
    opacity: 1; /* Fade in when loaded class is added */
  }

  .preset-info {
    padding: 15px;
    text-align: center;
  }

  .preset-name {
    margin: 0 0 5px 0;
    font-size: 1.1em;
  }

  .preset-author {
    font-size: 0.9em;
    color: var(--secondary-text);
    margin: 0;
  }
</style>
{% endblock %}

{% block extraScripts %}
<script>
  // Add onload event handlers to all fade-in images
  document.addEventListener('DOMContentLoaded', () => {
    const images = document.querySelectorAll('.fade-in-image');
    
    images.forEach(img => {
      // For images that are already loaded from cache
      if (img.complete) {
        img.classList.add('loaded');
      } else {
        // For images that need to be loaded
        img.addEventListener('load', () => {
          img.classList.add('loaded');
        });
        
        // Fallback in case image fails to load
        img.addEventListener('error', () => {
          img.classList.add('loaded');
          // Optionally set a placeholder or error image
          // img.src = '/api/placeholder/200/200';
        });
      }
    });
  });
</script>
{% endblock %}
</file>

<file path="chat-handler.js">
// chat-handler.js - Optimized Version
import { respondToChat, respondToEvent, addChatMessageAsVector } from './ai-logic.js';
import { containsCharacterName, containsAuxBotName, isCommandMatch } from './prompt-helper.js';
import { logger } from './create-global-logger.js';
import { returnAuthObject } from './api-helper.js';
import { sendChatMessage } from './twitch-eventsub-manager.js';

// Response cache to prevent duplicate responses
const responseCache = new Map();
const RESPONSE_CACHE_TTL = 30000; // 30 seconds
const MAX_CACHE_SIZE = 1000;

// Rate limiting for chat responses
const rateLimitMap = new Map();
const RATE_LIMIT_WINDOW = 60000; // 1 minute
const MAX_RESPONSES_PER_MINUTE = 10;

/**
 * Clean up old cache entries and rate limit data
 */
function cleanupCache() {
  const now = Date.now();
  
  // Clean response cache
  for (const [key, data] of responseCache.entries()) {
    if (now > data.expiresAt) {
      responseCache.delete(key);
    }
  }
  
  // Clean rate limit data
  for (const [userId, data] of rateLimitMap.entries()) {
    if (now > data.windowStart + RATE_LIMIT_WINDOW) {
      rateLimitMap.delete(userId);
    }
  }
  
  // Enforce max cache size
  if (responseCache.size > MAX_CACHE_SIZE) {
    const oldestKeys = Array.from(responseCache.keys()).slice(0, 100);
    oldestKeys.forEach(key => responseCache.delete(key));
  }
}

// Run cleanup every 5 minutes
setInterval(cleanupCache, 5 * 60 * 1000);

/**
 * Check if user is within rate limits
 */
function checkRateLimit(userId) {
  const now = Date.now();
  const userLimit = rateLimitMap.get(userId);
  
  if (!userLimit) {
    rateLimitMap.set(userId, {
      count: 1,
      windowStart: now,
    });
    return true;
  }
  
  // Reset window if expired
  if (now > userLimit.windowStart + RATE_LIMIT_WINDOW) {
    userLimit.count = 1;
    userLimit.windowStart = now;
    return true;
  }
  
  // Check if within limits
  if (userLimit.count >= MAX_RESPONSES_PER_MINUTE) {
    return false;
  }
  
  userLimit.count++;
  return true;
}

/**
 * Generate cache key for responses
 */
function generateCacheKey(message, user, userId, type = 'chat') {
  return `${type}_${userId}_${user}_${message}`.toLowerCase();
}

/**
 * Check response cache
 */
function getCachedResponse(cacheKey) {
  const cached = responseCache.get(cacheKey);
  if (cached && Date.now() < cached.expiresAt) {
    return cached.response;
  }
  return null;
}

/**
 * Store response in cache
 */
function setCachedResponse(cacheKey, response) {
  responseCache.set(cacheKey, {
    response,
    expiresAt: Date.now() + RESPONSE_CACHE_TTL,
  });
}

/**
 * Central handler for all chat messages from any source (API or EventSub)
 * @param {object} chatData - Normalized chat message data
 * @param {string} userId - The system user ID
 * @param {boolean} autoRespond - Whether to automatically send Twitch chat responses
 * @returns {Promise<object>} - Processing result with response if applicable
 */
export async function handleChatMessage(chatData, userId, autoRespond = false) {
  try {
    const user = await returnAuthObject(userId);
    if (!user) {
      logger.error("Chat", `User ${userId} not found`);
      return { success: false, error: "User not found" };
    }

    const { message, user: chatUser, firstMessage = false } = chatData;
    const formattedDate = new Date().toLocaleString();

    // Pre-processing checks with early returns
    const fromBot = await containsAuxBotName(chatUser, userId);
    if (fromBot) {
      logger.log("Chat", `Ignoring message from bot: ${chatUser}`);
      return { success: true, ignored: true, reason: "bot_user" };
    }

    const isCommand = await isCommandMatch(message, userId);
    if (isCommand) {
      logger.log("Chat", `Ignoring command message: ${message}`);
      return { success: true, ignored: true, reason: "command" };
    }

    // Check rate limits early
    if (!checkRateLimit(userId)) {
      logger.warn("Chat", `Rate limit exceeded for user ${userId}`);
      return { success: true, ignored: true, reason: "rate_limited" };
    }

    // Check for character mentions
    const mentionsChar = await containsCharacterName(message, userId);

    // Handle character mentions
    if (mentionsChar) {
      return await handleCharacterMention(chatData, userId, autoRespond, formattedDate);
    }

    // Handle first-time chatters
    if (firstMessage) {
      return await handleFirstTimeChatter(chatData, userId, autoRespond, formattedDate);
    }

    // Handle regular messages (store for context if enabled)
    return await handleRegularMessage(chatData, userId, formattedDate);

  } catch (error) {
    logger.error("Chat", `Error in chat handler: ${error.message}`);
    return { success: false, error: error.message };
  }
}

/**
 * Handle character mentions with caching and error recovery
 */
async function handleCharacterMention(chatData, userId, autoRespond, formattedDate) {
  const { message, user: chatUser } = chatData;
  
  // Check cache first
  const cacheKey = generateCacheKey(message, chatUser, userId, 'mention');
  const cachedResponse = getCachedResponse(cacheKey);
  
  if (cachedResponse) {
    logger.log("Chat", `Using cached response for mention from ${chatUser}`);
    
    // Still send to chat if autoRespond is enabled
    if (autoRespond) {
      const chatResponse = await sendChatMessage(cachedResponse.response, userId);
      return { ...cachedResponse, chatResponse };
    }
    
    return cachedResponse;
  }

  logger.log("Chat", `Processing mention from ${chatUser}: ${message}`);

  try {
    // Get AI response with timeout
    const aiResponsePromise = respondToChat({ message, user: chatUser }, userId);
    const timeoutPromise = new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Response timeout')), 30000)
    );

    const aiResponse = await Promise.race([aiResponsePromise, timeoutPromise]);

    if (!aiResponse.success) {
      logger.error("Chat", `Error getting AI response: ${aiResponse.error}`);
      
      // Return fallback response
      const fallbackResponse = "I'm having trouble processing that right now. Could you try again?";
      return await sendResponseAndStore(fallbackResponse, chatData, userId, autoRespond, formattedDate, 'mention_fallback');
    }

    const response = {
      success: true,
      processed: true,
      response: aiResponse.text,
      thoughtProcess: aiResponse.thoughtProcess || null,
    };

    // Cache the successful response
    setCachedResponse(cacheKey, response);

    // Store conversation in vector memory (async)
    const summaryString = `On ${formattedDate}, ${chatUser} said: "${message}". You responded by saying: ${aiResponse.text}`;
    
    addChatMessageAsVector(
      summaryString,
      message,
      chatUser,
      formattedDate,
      aiResponse.text,
      userId
    ).catch(err => logger.error("Chat", `Error storing chat vector: ${err.message}`));

    // Send to Twitch chat if autoRespond is enabled
    if (autoRespond && aiResponse.text) {
      try {
        const chatResponse = await sendChatMessage(aiResponse.text, userId);
        response.chatResponse = chatResponse;
        
        if (!chatResponse.success) {
          logger.error("Chat", `Failed to send chat response: ${chatResponse.error}`);
        }
      } catch (chatError) {
        logger.error("Chat", `Error sending chat message: ${chatError.message}`);
        response.chatResponse = { success: false, error: chatError.message };
      }
    }

    response.summaryString = summaryString;
    return response;

  } catch (error) {
    logger.error("Chat", `Error processing character mention: ${error.message}`);
    
    // Return error response
    const fallbackResponse = "I'm experiencing some technical difficulties. Please try again later.";
    return await sendResponseAndStore(fallbackResponse, chatData, userId, autoRespond, formattedDate, 'mention_error');
  }
}

/**
 * Handle first-time chatters with event processing
 */
async function handleFirstTimeChatter(chatData, userId, autoRespond, formattedDate) {
  const { message, user: chatUser } = chatData;
  
  // Check cache for first-time chatter responses
  const cacheKey = generateCacheKey(message, chatUser, userId, 'first_time');
  const cachedResponse = getCachedResponse(cacheKey);
  
  if (cachedResponse) {
    logger.log("Chat", `Using cached first-time chatter response for ${chatUser}`);
    
    if (autoRespond) {
      const chatResponse = await sendChatMessage(cachedResponse.response, userId);
      return { ...cachedResponse, chatResponse };
    }
    
    return cachedResponse;
  }

  logger.log("Chat", `Processing first-time chatter event from ${chatUser}`);

  try {
    // Create event data for first-time chatter
    const eventData = {
      eventType: 'chat',
      eventData: {
        user: chatUser,
        message: message,
        firstMessage: true
      }
    };

    // Process through event system with timeout
    const eventResponsePromise = respondToEvent(eventData, userId);
    const timeoutPromise = new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Event response timeout')), 25000)
    );

    const eventResponse = await Promise.race([eventResponsePromise, timeoutPromise]);

    if (!eventResponse?.response) {
      logger.error("Chat", `Error getting event response for first-time chatter`);
      
      // Fallback to generic welcome
      const fallbackResponse = `Welcome to the stream, ${chatUser}! Thanks for saying hello!`;
      return await sendResponseAndStore(fallbackResponse, chatData, userId, autoRespond, formattedDate, 'first_time_fallback');
    }

    const response = {
      success: true,
      processed: true,
      firstTimeChatter: true,
      response: eventResponse.response,
      thoughtProcess: eventResponse.thoughtProcess,
    };

    // Cache the response
    setCachedResponse(cacheKey, response);

    // Store in vector memory (async)
    const summaryString = `On ${formattedDate} ${chatUser} sent their first message: "${message}". You responded by saying: ${eventResponse.response}`;
    
    addChatMessageAsVector(
      summaryString,
      message,
      chatUser,
      formattedDate,
      eventResponse.response,
      userId
    ).catch(err => logger.error("Chat", `Error storing first-time chat vector: ${err.message}`));

    // Send to Twitch chat if autoRespond is enabled
    if (autoRespond) {
      try {
        const chatResponse = await sendChatMessage(eventResponse.response, userId);
        response.chatResponse = chatResponse;
        
        if (!chatResponse.success) {
          logger.error("Chat", `Failed to send first-time chatter response: ${chatResponse.error}`);
        }
      } catch (chatError) {
        logger.error("Chat", `Error sending first-time chatter message: ${chatError.message}`);
        response.chatResponse = { success: false, error: chatError.message };
      }
    }

    response.summaryString = summaryString;
    return response;

  } catch (error) {
    logger.error("Chat", `Error processing first-time chatter: ${error.message}`);
    
    // Fallback response
    const fallbackResponse = `Welcome to the stream, ${chatUser}! Great to have you here!`;
    return await sendResponseAndStore(fallbackResponse, chatData, userId, autoRespond, formattedDate, 'first_time_error');
  }
}

/**
 * Handle regular messages (no mention, not first time)
 */
async function handleRegularMessage(chatData, userId, formattedDate) {
  const { message, user: chatUser } = chatData;
  
  try {
    const user = await returnAuthObject(userId);
    
    // Only store if user has this setting enabled
    if (user.store_all_chat) {
      const summaryString = `On ${formattedDate} ${chatUser} said: "${message}"`;
      
      // Store asynchronously without blocking
      addChatMessageAsVector(
        summaryString,
        message,
        chatUser,
        formattedDate,
        "", // No response
        userId
      ).catch(err => logger.error("Chat", `Error storing regular chat: ${err.message}`));
    }

    return {
      success: true,
      processed: false,
      requiresResponse: false,
      summaryString: `On ${formattedDate} ${chatUser} said: "${message}"`,
    };
    
  } catch (error) {
    logger.error("Chat", `Error handling regular message: ${error.message}`);
    return {
      success: true,
      processed: false,
      requiresResponse: false,
      error: error.message,
    };
  }
}

/**
 * Helper function to send response and store data
 */
async function sendResponseAndStore(responseText, chatData, userId, autoRespond, formattedDate, type) {
  const { message, user: chatUser } = chatData;
  
  const response = {
    success: true,
    processed: true,
    response: responseText,
    type: type,
  };

  // Store in vector memory (async)
  const summaryString = `On ${formattedDate}, ${chatUser} said: "${message}". You responded by saying: ${responseText}`;
  
  addChatMessageAsVector(
    summaryString,
    message,
    chatUser,
    formattedDate,
    responseText,
    userId
  ).catch(err => logger.error("Chat", `Error storing ${type} vector: ${err.message}`));

  // Send to chat if autoRespond is enabled
  if (autoRespond) {
    try {
      const chatResponse = await sendChatMessage(responseText, userId);
      response.chatResponse = chatResponse;
    } catch (chatError) {
      logger.error("Chat", `Error sending ${type} message: ${chatError.message}`);
      response.chatResponse = { success: false, error: chatError.message };
    }
  }

  response.summaryString = summaryString;
  return response;
}

/**
 * Normalizes chat messages from various sources into a standard format
 * @param {object} messageData - Raw message from EventSub or API
 * @returns {object} - Standardized chat object
 */
export function normalizeMessageFormat(messageData) {
  // From EventSub webhook
  if (messageData.chatter && messageData.message && messageData.message.text) {
    return {
      user: messageData.chatter.user_name,
      userId: messageData.chatter.user_id,
      message: messageData.message.text,
      firstMessage: messageData.message.is_first || false,
      badges: messageData.chatter.badges?.map(badge => badge.set_id) || [],
      emotes: messageData.message.fragments
        ?.filter(f => f.type === 'emote')
        .map(e => ({ id: e.id, code: e.text })) || [],
      emoteCount: messageData.message.fragments?.filter(f => f.type === 'emote').length || 0,
      color: messageData.chatter.color,
      source: 'eventsub'
    };
  }
  
  // From API or other sources
  return {
    user: messageData.user,
    userId: messageData.userId || null,
    message: messageData.message,
    firstMessage: messageData.firstMessage || false,
    badges: messageData.badges || [],
    emotes: messageData.emotes || [],
    emoteCount: messageData.emoteCount || 0,
    color: messageData.color || null,
    source: messageData.source || 'api'
  };
}

/**
 * Process batch of chat messages efficiently
 * @param {Array} messages - Array of chat messages to process
 * @param {string} userId - User ID
 * @param {boolean} autoRespond - Whether to auto-respond
 * @returns {Promise<Array>} - Array of processing results
 */
export async function handleChatMessageBatch(messages, userId, autoRespond = false) {
  if (!Array.isArray(messages) || messages.length === 0) {
    return [];
  }

  // Process messages with concurrency limit
  const batchSize = 3;
  const results = [];

  for (let i = 0; i < messages.length; i += batchSize) {
    const batch = messages.slice(i, i + batchSize);
    
    const batchPromises = batch.map(async (messageData) => {
      try {
        const normalized = normalizeMessageFormat(messageData);
        return await handleChatMessage(normalized, userId, autoRespond);
      } catch (error) {
        logger.error("Chat", `Error processing batch message: ${error.message}`);
        return { success: false, error: error.message };
      }
    });

    const batchResults = await Promise.allSettled(batchPromises);
    
    // Convert Promise.allSettled results to actual results
    const processedResults = batchResults.map(result => 
      result.status === 'fulfilled' ? result.value : { success: false, error: result.reason.message }
    );
    
    results.push(...processedResults);

    // Small delay between batches to avoid overwhelming the system
    if (i + batchSize < messages.length) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }

  return results;
}

/**
 * Get chat handler statistics
 */
export function getChatHandlerStats() {
  return {
    responseCache: {
      size: responseCache.size,
      maxSize: MAX_CACHE_SIZE,
    },
    rateLimits: {
      activeUsers: rateLimitMap.size,
      windowMs: RATE_LIMIT_WINDOW,
      maxPerWindow: MAX_RESPONSES_PER_MINUTE,
    },
    cacheTtl: RESPONSE_CACHE_TTL,
  };
}

/**
 * Clear all caches (useful for testing or troubleshooting)
 */
export function clearChatHandlerCache() {
  responseCache.clear();
  rateLimitMap.clear();
  logger.log("Chat", "Chat handler caches cleared");
}
</file>

<file path="template-engine.js">
// template-engine.js
import path from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import fs from 'fs-extra';
import { logger } from './create-global-logger.js';
import nunjucks from 'nunjucks';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export async function setupTemplating(fastify) {
  // Ensure templates directory exists
  const templatesDir = path.join(process.cwd(), 'views');
  await fs.ensureDir(templatesDir);
  
  // Move templates from pages to views if needed
  const pagesDir = path.join(process.cwd(), 'pages');
  if (await fs.pathExists(pagesDir)) {
    const pageFiles = await fs.readdir(pagesDir);
    for (const file of pageFiles) {
      const sourcePath = path.join(pagesDir, file);
      const destPath = path.join(templatesDir, file);
      
      // Skip if destination already exists
      if (!(await fs.pathExists(destPath))) {
        await fs.copy(sourcePath, destPath);
        logger.log("Templates", `Copied template: ${file}`);
      }
    }
  }
  
  // Create Nunjucks environment directly
  const njkEnv = nunjucks.configure(templatesDir, {
    autoescape: true,
    throwOnUndefined: false,
    trimBlocks: true,
    lstripBlocks: true
  });
  
  // Add template helpers/filters
  njkEnv.addFilter('json', (obj) => JSON.stringify(obj, null, 2));
  njkEnv.addFilter('dateFormat', async (date, format = 'MMMM Do YYYY, h:mm a') => {
    if (!date) return '';
    const moment = (await import('moment')).default;
    return moment(date).format(format);
  });
  njkEnv.addFilter('startsWithMarkdown', (text) => {
    if (!text) return false;
    const trimmedText = text.trim();
    // Check for common markdown patterns
    return /^(#|\*|\-|\d+\.|>|\[|\`|\!\[)/.test(trimmedText);
  });
  
  // Basic markdown renderer for simple cases
  njkEnv.addFilter('renderMarkdown', (text) => {
    if (!text) return '';
    
    let html = text;
    
    // Headers
    html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>');
    html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>');
    html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>');
    
    // Lists
    html = html.replace(/^\- (.*$)/gm, '<li>$1</li>');
    html = html.replace(/^(\d+)\. (.*$)/gm, '<li>$2</li>');
    
    // Wrap list items in ul/ol
    html = html.replace(/(<li>.*<\/li>)\s+(?!<li>)/gs, '<ul>$1</ul>');
    
    // Bold and italics
    html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
    
    // Paragraphs (non-list, non-header text)
    html = html.replace(/^(?!<h|<ul|<li|<ol)(.*$)/gm, '<p>$1</p>');
    
    return html;
  });
  
  // Add direct view rendering to Fastify
  fastify.decorate('renderView', (template, data = {}) => {
    return njkEnv.render(template, { 
      ...data, 
      appName: 'Enspira',
      year: new Date().getFullYear()
    });
  });
  
  // Add direct view rendering to reply object
  fastify.decorateReply('view', function(template, data = {}) {
    const html = njkEnv.render(template, { 
      ...data, 
      appName: 'Enspira',
      year: new Date().getFullYear()
    });
    return this.type('text/html').send(html);
  });
  
  logger.log("System", "Template engine configured successfully");
  return fastify;
}
</file>

<file path="views/dashboard.njk">
{% extends "layout.njk" %}
{% block title %}
  Dashboard
{% endblock title %}
{% block content %}
  <!-- Welcome Card -->
  <div class="card">
    <div class="card-header">
      <h1>Welcome to Enspira, {{ user.display_name }}</h1>
    </div>
    <p>Manage your Enspira Co-Star for your Twitch channel.</p>
    <!-- AI Assistant Settings -->
    <div class="two-column">
      <div class="card">
        <h2>Character Settings</h2>
        <p>Customize your AI assistant's personality, appearance, and behavior.</p>
        <a href="/web/character" class="btn btn-primary">Edit Character</a>
      </div>
      <div class="card">
        <h2>World Settings</h2>
        <p>Set up the environment and context for your AI assistant.</p>
        <a href="/web/world" class="btn btn-primary">Edit World</a>
      </div>
    </div>
  </div>
  <!-- Stream Status Card -->
  <div class="card stream-card">
    <div class="stream-status-indicator {% if streamStatus.online %}online{% else %}offline{% endif %}">
      <span class="status-indicator"></span>
      <span>{% if streamStatus.online %}Live{% else %}Offline{% endif %}</span>
    </div>
    
    <h2>Stream Status</h2>
    
    {% if streamStatus.online %}
      <div class="stream-content">
        {% if streamStatus.thumbnail %}
          <div class="stream-thumbnail">
            <img src="{{ streamStatus.thumbnail }}" alt="Stream Thumbnail" class="fade-in-image">
          </div>
        {% endif %}
        <div class="stream-details">
          <h3 class="stream-title">{{ streamStatus.title }}</h3>
          <div class="stream-game">
            <span>Playing:</span> {{ streamStatus.game }}
          </div>
          <div class="stream-time">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="10"></circle>
              <polyline points="12 6 12 12 16 14"></polyline>
            </svg>
            <span>{{ streamStatus.duration }}</span>
          </div>
          <div class="stream-metrics">
            <div class="metric">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                <circle cx="9" cy="7" r="4"></circle>
                <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
              </svg>
              <span>{{ streamStatus.viewers }} viewers</span>
            </div>
            <div class="metric">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
              </svg>
              <span>{{ followerCount }} followers</span>
            </div>
          </div>
        </div>
      </div>
    {% else %}
      <div class="stream-info offline">
        <div class="offline-details">
          <div class="metric">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
            </svg>
            <span>{{ followerCount }} followers</span>
          </div>
          {% if lastGame and lastGame != 'None' %}
            <div class="last-game">
              <span>Last played:</span> {{ lastGame }}
            </div>
            {% if user.current_game.thumbnail_url %}
              <div class="offline-thumbnail">
                <img src="{{ user.current_game.thumbnail_url }}" alt="Last Stream Thumbnail" class="fade-in-image">
              </div>
            {% endif %}
          {% endif %}
        </div>
      </div>
    {% endif %}
  </div>
  <!-- Twitch Integration Card -->
  <div class="card">
    <h2>Twitch Integration</h2>
    <p>Connect your Twitch streamer and bot accounts.</p>
    <div class="two-column">
      <div>
        <h3>Streamer Account</h3>
        {% if streamerConnected %}
          <p class="alert alert-success">Connected as: {{ streamerName }}</p>
        {% else %}
          <p class="alert alert-error">Not connected</p>
        {% endif %}
        <!-- Direct link to connect streamer account -->
        <a href="/api/v1/auth/twitch/connect?type=streamer" class="btn btn-secondary">
          {% if streamerConnected %}
            Reconnect Streamer Account
          {% else %}
            Connect Streamer Account
          {% endif %}
        </a>
      </div>
      <div>
        <h3>Bot Account</h3>
        {% if botConnected %}
          <p class="alert alert-success">Connected as: {{ botName }}</p>
        {% else %}
          <p class="alert alert-error">Not connected</p>
        {% endif %}
        <!-- Direct link to connect bot account -->
        <a href="/api/v1/auth/twitch/connect?type=bot" class="btn btn-secondary">
          {% if botConnected %}
            Reconnect Bot Account
          {% else %}
            Connect Bot Account
          {% endif %}
        </a>
      </div>
    </div>
  </div>
  <!-- Quick Stats Card -->
  <div class="card">
    <h2>Quick Stats</h2>
    <div class="two-column">
      <div>
        <h3>Chat Messages</h3>
        <p>{{ stats.chatMessages }} messages processed</p>
      </div>
    </div>
  </div>
  <!-- Help Card -->
  <div class="card">
    <div class="card-header">
      <h1>Resources, Tips and Tricks</h1>
    </div>
    <p>Find more help to enhance your AI co-star's character here.</p>
    <!-- AI Assistant Settings -->
    <div class="four-column">
      <div class="card">
        <h2>Want to read up?</h2>
        <p>Check out our source code over at Github!</p>
        <a href="https://github.com/prolix-oc/Refyne" class="btn btn-primary">GitHub</a>
      </div>
      <div class="card">
        <h2>Want more ideas?</h2>
        <p>Join the Discord community for tips.</p>
        <a href="https://discord.com/invite/pMnZ7DaUK3" class="btn btn-primary">Join Up</a>
      </div>
      <div class="card">
        <h2>Visual learner?</h2>
        <p>Drop by my YouTube for videos soon!</p>
        <a href="https://youtube.com/@prolix_gg" class="btn btn-primary">Tune In</a>
      </div>
      <div class="card">
        <h2>Still Confused?</h2>
        <p>Check out our dedicated help section.</p>
        <a href="/web/help" class="btn btn-primary">Get Help</a>
      </div>
    </div>
  </div>
  
{% endblock content %}
{% block extraStyles %}
  <style>
  .stream-card {
    position: relative;
    padding-top: 30px;
  }

  .stream-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
  }

  .stream-status-indicator {
    position: absolute;
    top: 15px;
    right: 15px;
    display: flex;
    align-items: center;
    font-weight: bold;
    padding: 5px 10px;
    border-radius: 16px;
    background-color: rgba(40, 40, 40, 0.6);
    z-index: 1;
  }

  .stream-status-indicator.online {
    color: #56d364;
  }

  .stream-status-indicator.offline {
    color: #f85149;
  }

  .status-indicator {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-right: 6px;
  }

  .stream-status-indicator.online .status-indicator {
    background-color: #56d364;
    box-shadow: 0 0 0 2px rgba(86, 211, 100, 0.3);
    animation: pulse 2s infinite;
  }

  .stream-status-indicator.offline .status-indicator {
    background-color: #f85149;
  }

  .stream-content {
    display: flex;
    gap: 15px;
  }

  .stream-thumbnail {
    width: 320px;
    height: 180px;
    overflow: hidden;
    border-radius: 4px;
    flex-shrink: 0;
  }

  .stream-thumbnail img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
    opacity: 0;
    transition: opacity 0.4s ease-in;
  }

  .stream-thumbnail img.loaded {
    opacity: 1;
  }

  .stream-details {
    flex: 1;
  }

  .stream-title {
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 18px;
  }

  .stream-game {
    margin-bottom: 15px;
    color: var(--accent);
  }

  .stream-time {
    display: flex;
    align-items: center;
    color: var(--secondary-text);
    margin-bottom: 15px;
  }

  .stream-time svg {
    margin-right: 5px;
  }

  .stream-metrics {
    display: flex;
    gap: 20px;
  }

  .metric {
    display: flex;
    align-items: center;
  }

  .metric svg {
    margin-right: 5px;
    color: var(--accent);
  }

  .offline-details {
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .last-game {
    color: var(--secondary-text);
  }

  .offline-thumbnail {
    margin-top: 15px;
    width: 100%;
    max-width: 320px;
    height: auto;
    aspect-ratio: 16/9;
    overflow: hidden;
    border-radius: 4px;
  }

  .offline-thumbnail img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    opacity: 0;
    transition: opacity 0.4s ease-in;
  }

  .offline-thumbnail img.loaded {
    opacity: 1;
  }

  @keyframes pulse {
    0% {
      box-shadow: 0 0 0 0 rgba(86, 211, 100, 0.7);
    }
    70% {
      box-shadow: 0 0 0 5px rgba(86, 211, 100, 0);
    }
    100% {
      box-shadow: 0 0 0 0 rgba(86, 211, 100, 0);
    }
  }

  @media (max-width: 768px) {
    .stream-card-header {
      flex-direction: column;
      align-items: flex-start;
    }
    
    .stream-status-indicator {
      top: 50px; /* Position below the title on mobile */
      right: 15px;
    }

    .stream-content {
      flex-direction: column;
    }

    .stream-thumbnail {
      width: 100%;
      height: auto;
      aspect-ratio: 16/9;
    }
  }
  </style>
{% endblock extraStyles %}
{% block extraScripts %}
  <script>
  document.addEventListener('DOMContentLoaded', () => {
    const images = document.querySelectorAll('.fade-in-image');
    
    images.forEach(img => {
      // For images that are already loaded from cache
      if (img.complete) {
        img.classList.add('loaded');
      } else {
        // For images that need to be loaded
        img.addEventListener('load', () => {
          img.classList.add('loaded');
        });
        
        // Fallback in case image fails to load
        img.addEventListener('error', () => {
          img.classList.add('loaded');
        });
      }
    });
  });
  </script>
{% endblock extraScripts %}
</file>

<file path="views/layout.njk">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{% block title %}{{ pageTitle }}{% endblock %} - Enspira</title>
    <style>
      :root {
        --background: #0d1117;
        --card-bg: #161b22;
        --primary-text: #e6edf3;
        --secondary-text: #8b949e;
        --accent: #58a6ff;
        --accent-hover: #79c0ff;
        --error: #f85149;
        --success: #56d364;
        --border: #30363d;
        --input-bg: #0d1117;
        --button-bg: #238636;
        --button-hover: #2ea043;
        --button-secondary-bg: #21262d;
        --button-secondary-hover: #30363d;
        --nav-bg: #161b22;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        background-color: var(--background);
        color: var(--primary-text);
        line-height: 1.6;
        overflow-x: hidden;
      }

      .container {
        width: 100%;
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 20px;
      }

      header {
        background-color: var(--nav-bg);
        border-bottom: 1px solid var(--border);
        padding: 15px 0;
        position: sticky;
        top: 0;
        z-index: 100;
      }

      .header-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .logo {
        font-size: 24px;
        font-weight: bold;
        color: var(--primary-text);
        text-decoration: none;
        display: flex;
        align-items: center;
      }

      .logo svg {
        margin-right: 10px;
      }

      nav ul {
        display: flex;
        list-style: none;
        gap: 20px;
        align-items: center;
      }

      nav a {
        color: var(--primary-text);
        text-decoration: none;
        font-weight: 500;
        padding: 8px 12px;
        border-radius: 6px;
        transition:
          background-color 0.2s,
          color 0.2s;
        display: flex;
        align-items: center;
        height: 100%;
      }

      nav a:hover {
        background-color: var(--button-secondary-hover);
        text-decoration: none;
        color: var(--primary-text);
      }

      nav a.active {
        background-color: var(--button-secondary-bg);
      }

      main {
        padding: 40px 0;
        min-height: calc(100vh - 140px);
      }

      .card {
        background-color: var(--card-bg);
        border-radius: 10px;
        border: 1px solid var(--border);
        padding: 20px;
        margin-bottom: 20px;
      }

      .card-header {
        margin-bottom: 20px;
        padding-bottom: 10px;
        border-bottom: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      h1 {
        font-size: 24px;
        font-weight: 600;
        margin-bottom: 20px;
      }

      h2 {
        font-size: 20px;
        font-weight: 600;
        margin-bottom: 15px;
      }

      h3 {
        font-size: 16px;
        font-weight: 600;
        margin-bottom: 10px;
      }

      p {
        margin-bottom: 15px;
        color: var(--secondary-text);
      }

      a {
        color: var(--accent);
        text-decoration: none;
      }

      a:hover {
        color: var(--accent-hover);
        text-decoration: underline;
      }

      .btn {
        display: inline-block;
        padding: 8px 16px;
        font-size: 14px;
        font-weight: 500;
        border-radius: 6px;
        transition: background-color 0.2s;
        border: none;
        cursor: pointer;
        text-align: center;
      }

      .btn-primary {
        background-color: var(--button-bg);
        color: white;
      }

      .btn-primary:hover {
        background-color: var(--button-hover);
        text-decoration: none;
      }

      .btn-secondary {
        background-color: var(--button-secondary-bg);
        color: var(--primary-text);
      }

      .btn-secondary:hover {
        background-color: var(--button-secondary-hover);
        text-decoration: none;
      }

      .form-group {
        margin-bottom: 20px;
      }

      label {
        display: block;
        margin-bottom: 8px;
        font-weight: 500;
      }

      input[type="text"],
      input[type="password"],
      input[type="email"],
      textarea,
      select {
        width: 100%;
        padding: 10px 12px;
        border-radius: 6px;
        border: 1px solid var(--border);
        background-color: var(--input-bg);
        color: var(--primary-text);
        font-size: 14px;
        transition: border-color 0.2s;
      }

      textarea {
        min-height: 150px;
        resize: vertical;
      }

      input:focus,
      textarea:focus,
      select:focus {
        outline: none;
        border-color: var(--accent);
      }

      .alert {
        padding: 12px 16px;
        border-radius: 6px;
        margin-bottom: 20px;
      }

      .alert-success {
        background-color: rgba(86, 211, 100, 0.1);
        border: 1px solid var(--success);
        color: var(--success);
      }

      .alert-error {
        background-color: rgba(248, 81, 73, 0.1);
        border: 1px solid var(--error);
        color: var(--error);
      }

      footer {
        padding: 20px 0;
        border-top: 1px solid var(--border);
        font-size: 14px;
        color: var(--secondary-text);
      }

      .footer-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .tabs {
        display: flex;
        border-bottom: 1px solid var(--border);
        margin-bottom: 20px;
      }

      .tab {
        padding: 10px 20px;
        cursor: pointer;
        border-bottom: 2px solid transparent;
      }

      .tab.active {
        border-bottom-color: var(--accent);
        color: var(--accent);
      }

      .tab-content {
        display: none;
      }

      .tab-content.active {
        display: block;
      }

      .two-column {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
      }

      .three-column {
        display: grid;
        grid-template-columns: repeat(3, minmax(280px, 1fr));
        grid-gap: 20px;
      }

      @media (max-width: 768px) {
        .two-column {
          grid-template-columns: 1fr;
        }
        .three-column {
          grid-template-columns: 1fr;
        }
        nav ul {
          gap: 10px;
        }
      }

      .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: var(--accent);
        animation: spin 1s ease-in-out infinite;
      }
      .four-column {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 20px;
      }

@media (max-width: 1200px) {
  .four-column {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 600px) {
  .four-column {
    grid-template-columns: 1fr;
  }
}
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* Fix for nested cards in dashboard */
      .card .card {
        margin-bottom: 0;
      }
      
      /* Fix for two-column inside cards */
      .card > .two-column > .card {
        height: 100%;
        display: flex;
        flex-direction: column;
      }
      
      .card > .two-column > .card p {
        flex-grow: 1;
      }
    </style>
    {% block extraStyles %}{% endblock %}
  </head>
  <body>
    <header>
      <div class="container header-content">
        <a href="/web/dashboard" class="logo">
          <svg
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path d="M12 2L2 7L12 12L22 7L12 2Z" fill="#58a6ff" />
            <path
              d="M2 17L12 22L22 17"
              stroke="#58a6ff"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
            <path
              d="M2 12L12 17L22 12"
              stroke="#58a6ff"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
          <span>Enspira</span>
        </a>
        <nav>
          <ul>
            <li>
              <a href="/web/dashboard" class="{% if dashboardActive %}active{% endif %}">Dashboard</a>
            </li>
            <li>
              <a href="/web/character" class="{% if characterActive %}active{% endif %}">Character</a>
            </li>
            <li>
              <a href="/web/world" class="{% if worldActive %}active{% endif %}">World</a>
            </li>
            <li>
              <a href="/web/help" class="{% if helpActive %}active{% endif %}">Help</a>
            </li>
            <li>
              <a href="/web/gallery" class="{% if galleryActive %}active{% endif %}">Gallery</a>
            </li>
            <li>
              <a href="/web/settings" class="{% if settingsActive %}active{% endif %}">Settings</a>
            </li>
            <li>
              <a href="/web/auth/logout" class="btn btn-secondary">Logout</a>
            </li>
          </ul>
        </nav>
      </div>
    </header>

    <main>
      <div class="container">
        {% block content %}{% endblock %}
      </div>
    </main>

    <footer>
      <div class="container footer-content">
        <div>Enspira &copy; {{ year }}</div>
        <div>
          <a href="https://github.com/prolix-oc/Enspira" target="_blank">GitHub</a>
        </div>
      </div>
    </footer>

    <script>
      // Common JavaScript functions
      document.addEventListener("DOMContentLoaded", () => {
        // Tab handling
        const tabGroups = document.querySelectorAll(".tabs");
        tabGroups.forEach((tabGroup) => {
          const tabs = tabGroup.querySelectorAll(".tab");
          const tabContents = document.querySelectorAll(".tab-content");

          tabs.forEach((tab) => {
            tab.addEventListener("click", () => {
              // Remove active class from all tabs in this group
              tabGroup.querySelectorAll(".tab").forEach((t) => t.classList.remove("active"));

              // Add active class to clicked tab
              tab.classList.add("active");

              // Show corresponding tab content
              const target = tab.getAttribute("data-target");
              document.querySelectorAll(".tab-content").forEach((content) => {
                if (content.id === target) {
                  content.classList.add("active");
                } else {
                  content.classList.remove("active");
                }
              });
            });
          });
        });

        // Form submission handling
        const forms = document.querySelectorAll("form[data-async]");
        forms.forEach((form) => {
          form.addEventListener("submit", async (e) => {
            e.preventDefault();

            const formData = new FormData(form);
            const submitBtn = form.querySelector('button[type="submit"]');
            
            // If no submit button found, just proceed
            if (!submitBtn) {
              processForm();
              return;
            }
            
            const originalBtnText = submitBtn.textContent;

            // Show loading state
            submitBtn.disabled = true;
            submitBtn.innerHTML = '<span class="loading"></span> Processing...';

            // Process the form
            processForm();

            // Function to process the form submission
            async function processForm() {
              try {
                const response = await fetch(form.action, {
                  method: form.method || "POST",
                  body: formData,
                  headers: {
                    Accept: "application/json",
                  },
                });

                const result = await response.json();

                if (response.ok) {
                  // Show success message
                  const existingAlert = form.querySelector('.alert');
                  if (existingAlert) {
                    existingAlert.remove();
                  }
                  
                  const alertEl = document.createElement("div");
                  alertEl.className = "alert alert-success";
                  alertEl.textContent = result.message || "Changes saved successfully!";
                  form.prepend(alertEl);

                  // Remove alert after 3 seconds
                  setTimeout(() => alertEl.remove(), 3000);

                  // If there's a redirect URL, navigate there
                  if (result.redirect) {
                    window.location.href = result.redirect;
                  }
                } else {
                  // Show error message
                  const existingAlert = form.querySelector('.alert');
                  if (existingAlert) {
                    existingAlert.remove();
                  }
                  
                  const alertEl = document.createElement("div");
                  alertEl.className = "alert alert-error";
                  alertEl.textContent = result.error || "An error occurred. Please try again.";
                  form.prepend(alertEl);
                }
              } catch (error) {
                console.error("Error:", error);
                
                const existingAlert = form.querySelector('.alert');
                if (existingAlert) {
                  existingAlert.remove();
                }
                
                const alertEl = document.createElement("div");
                alertEl.className = "alert alert-error";
                alertEl.textContent = "An unexpected error occurred. Please try again.";
                form.prepend(alertEl);
              } finally {
                // Restore button state if it exists
                if (submitBtn) {
                  submitBtn.disabled = false;
                  submitBtn.textContent = originalBtnText;
                }
              }
            }
          });
        });

        // Image loading for fade-in images
        const fadeImages = document.querySelectorAll('.fade-in-image');
        if (fadeImages.length > 0) {
          fadeImages.forEach(img => {
            if (img.complete) {
              img.classList.add('loaded');
            } else {
              img.addEventListener('load', () => img.classList.add('loaded'));
              img.addEventListener('error', () => img.classList.add('loaded'));
            }
          });
        }
      });
    </script>

    {% block extraScripts %}{% endblock %}
  </body>
</html>
</file>

<file path="config-helper.js">
import fs from "fs-extra";
import path from "path";
import { fileURLToPath } from "url";
import { dirname } from "path";
import levenshtein from "fast-levenshtein";
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const configFilePath = path.join(__dirname, "./config/config.json");
let configCache = null;
let originalConfigTypes = {}; // Store original data types

/**
 * Loads the configuration file into memory.
 * @returns {Promise<void>}
 */
async function loadConfig() {
  if (configCache) return configCache;  // Prevent loading if already loaded
  
  try {
    configCache = await fs.readJSON(configFilePath)
    await storeOriginalTypes(configCache)
    return configCache
  } catch (err) {
    configCache = {}
    return configCache;
  }
}

/**
 * Converts a string value to the original type.
 * @param {string} value - The user input value as a string.
 * @param {string} originalType - The expected type (e.g., "number", "boolean").
 * @returns {any} - The converted value.
 */
function convertValueToOriginalType(value, originalType) {
  switch (originalType) {
    case "number":
      return parseFloat(value);
    case "boolean":
      return value === "true" || value === "1" || value === 1 || value === true;
    case "string":
      return value;
    default:
      return value;
  }
}

function findClosestKey(inputPath, config, threshold = 2) {
  const keys = extractAllPaths(config);
  const lowerInputPath = inputPath.toLowerCase();

  const exactMatch = keys.find(key => key.toLowerCase() === lowerInputPath);
  if (exactMatch) return exactMatch;

  const closestMatch = keys.reduce(
    (bestMatch, key) => {
      const distance = levenshtein.get(lowerInputPath, key.toLowerCase());
      if (distance < bestMatch.distance) {
        return { key, distance };
      }
      return bestMatch;
    },
    { key: null, distance: Infinity }
  );

  return closestMatch.distance <= threshold ? closestMatch.key : null;
}

function extractAllPaths(obj, parentKey = "") {
  let paths = [];
  for (const key in obj) {
    const fullPath = parentKey ? `${parentKey}.${key}` : key;
    if (typeof obj[key] === "object" && obj[key] !== null) {
      paths = paths.concat(extractAllPaths(obj[key], fullPath));
    } else {
      paths.push(fullPath);
    }
  }
  return paths;
}

/**
 * Saves a value to the configuration and writes it to disk.
 * @param {string} path - The path to the value to save (e.g., "samplers.topK").
 * @param {string} userInput - The user-provided value as a string.
 * @returns {Promise<boolean>} - A promise that resolves to true if successful, false otherwise.
 */
async function saveConfigValue(path, userInput) {
  if (!configCache) {
    await loadConfig();
  }

  const inferredPath = findClosestKey(path, configCache);
  if (!inferredPath) {
    return false;
  }

  const pathParts = inferredPath.split(".");
  let obj = configCache;
  for (let i = 0; i < pathParts.length - 1; i++) {
    const part = pathParts[i];
    if (!obj[part] || typeof obj[part] !== "object") {
      obj[part] = {};
    }
    obj = obj[part];
  }

  const key = pathParts[pathParts.length - 1];
  const originalType = originalConfigTypes[inferredPath];

  if (!originalType) {
    throw new Error(`Unknown configuration path: ${inferredPath}`);
  }

  let convertedValue;
  try {
    convertedValue = convertValueToOriginalType(userInput, originalType);
  } catch (error) {
    return false;
  }

  obj[key] = convertedValue;

  try {
    await saveConfigToDisk()
    await reloadConfig()
    return true;
  } catch (error) {
    return false;
  }
}

async function storeOriginalTypes(obj, parentKey = "") {
  for (const key in obj) {
    const value = obj[key];
    const fullPath = parentKey ? `${parentKey}.${key}` : key;

    if (typeof value === "object" && value !== null) {
      await storeOriginalTypes(value, fullPath);
    } else {
      originalConfigTypes[fullPath] = typeof value;
    }
  }
}

async function reloadConfig() {
  configCache = null;
  await loadConfig();
}


/**
 * Retrieves a value from the configuration using a dot notation path.
 * @param {string} path - The path to the desired value (e.g., "samplers.topK").
 * @returns {Promise<any>} - A promise that resolves to the value at the specified path, or undefined if not found.
 */
async function retrieveConfigValue(path) {
  await reloadConfig();
  const pathParts = path.split(".");
  let value = configCache;
  for (const part of pathParts) {
    if (value[part] === undefined) {
      return undefined; // Value not found
    }
    value = value[part];
  }
  if (typeof value === "object" && value !== null) {
    return value;
  }
  // Get the original type from the stored types
  const originalType = originalConfigTypes[path];

  // Convert the value to the original type if possible
  if (originalType) {
      try {
          return convertValueToOriginalType(value, originalType);
      } catch (error) {
          return value;
      }
  } else {
      // If no original type is found, return the value as is
      return value;
  }
}


/**
 * Writes the current configuration to disk.
 * @returns {Promise<void>}
 */
async function saveConfigToDisk() {
  try {
    if (configCache) {
      await fs.writeJSON(configFilePath, configCache, { spaces: 2 });
    } else {
    }
  } catch (error) {
  }
}

export { loadConfig, retrieveConfigValue, saveConfigToDisk, saveConfigValue };
</file>

<file path="create-global-logger.js">
import { getLogger } from './logger.js';

// Export the shared logger instance so it can be imported by other modules
export const logger = getLogger();

// Define a function to ensure the global logger is set up
export function ensureGlobalLogger() {
  if (!global.logger && global._sharedObjects && global._sharedObjects.logger) {
    global.logger = global._sharedObjects.logger;
  }
  
  return global.logger || logger;
}

// Ensure the global logger is available
ensureGlobalLogger();

// For modules that need direct console access, provide a console wrapper
export const logConsole = Object.fromEntries(
  ['log', 'info', 'warn', 'error', 'debug'].map(level => [
    level, 
    (message) => logger[level](level === 'log' || level === 'error' ? "Console" : null, message)
  ])
);
</file>

<file path="config/config.example.json">
{
  "server": {
    "cookieSecret": "",
    "authFilePath": "./auth/auth_keys.json",
    "port": 3002,
    "authRequired": true,
    "endpoints": {
      "external": "http://localhost:3002",
      "internal": "::"
    },
    "externalScraper": {
      "enabled": false,
      "endpoint": "",
      "deviceType": "",
      "caching": ""
    }
  },
  "brave": {
    "apiKey": ""
  },
  "milvus": {
    "collections": {
      "intelligence": "",
      "voice": "",
      "chat": "",
      "user": ""
    },
    "endpoint": "",
    "localTextDirectory": "./data"
  },
  "twitch": {
    "maxChatsToSave": 40,
    "maxCharLimit": 500,
    "clientId": "",
    "clientSecret": "",
    "redirectUri": "",
    "scopes": {
      "streamer": [
        "bits:read",
        "analytics:read:games",
        "analytics:read:extensions",
        "channel:edit:commercial",
        "channel:read:subscriptions",
        "channel:read:hype_train",
        "channel:read:goals",
        "channel:read:redemptions",
        "channel:read:charity",
        "channel:read:polls",
        "channel:read:predictions",
        "channel:manage:broadcast",
        "channel:manage:raids",
        "channel:manage:ads",
        "channel:manage:raids",
        "channel:moderate",
        "channel:read:stream_key",
        "chat:read",
        "moderator:read:followers",
        "moderator:read:chatters",
        "user:write:chat"
      ],
      "bot": [
        "bits:read",
        "chat:read",
        "chat:edit",
        "moderator:read:chatters",
        "moderator:read:followers",
        "moderator:read:shoutouts",
        "moderator:manage:announcements",
        "moderator:read:suspicious_users",
        "moderator:manage:chat_messages",
        "moderator:read:guest_star",
        "moderator:manage:guest_star",
        "moderator:read:moderators",
        "moderator:manage:shoutouts",
        "user:read:email",
        "user:read:chat",
        "user:write:chat"
      ]
    }
  },
  "models": {
    "summary": {
      "enabled": true,
      "endpoint": "",
      "apiKey": "",
      "model": "",
      "modelType": "",
      "maxTokens": 131072
    },
    "query": {
      "endpoint": "",
      "apiKey": "",
      "model": "",
      "modelType": "",
      "maxTokens": 4096
    },
    "chat": {
      "author": "",
      "organization": "",
      "endpoint": "",
      "apiKey": "",
      "model": "",
      "modelType": "",
      "maxTokens": 12288
    },
    "embedding": {
      "endpoint": "1",
      "apiKey": "",
      "apiKeyType": "",
      "model": "",
      "dimensions": 1024,
      "embeddingType": ""
    },
    "rerank": {
      "endpoint": "",
      "apiKey": "",
      "apiKeyType": "",
      "model": ""
    },
    "classifier": {
      "endpoint": "",
      "apiKey": "",
      "apiKeyType": "",
      "model": ""
    },
    "conversion": {
      "endpoint": "",
      "apiKey": "",
      "model": "",
      "modelType": "",
      "maxTokens": 131072
    },
    "rerankTransform": {
      "endpoint": "",
      "apiKey": "",
      "model": "",
      "modelType": "",
      "maxTokens": 4096
    },
    "moderator": {
      "endpoint": "",
      "apiKey": "",
      "apiKeyType": "",
      "model": "",
      "modelType": "",
      "maxTokens": 4096
    }
  },
  "samplers": {
    "chat": {
      "topK": -1,
      "maxTokens": 1024,
      "generateWindow": 1024,
      "topP": 0.95,
      "typicalP": 1,
      "minP": 0.05,
      "temperature": 0.1,
      "minTokens": 90,
      "repetitionPenalty": 1,
      "presencePenalty": 1,
      "xtcThreshold": 0.1,
      "xtcProbability": 0.2,
      "dynTemp": true,
      "dynTempMin": 0.07,
      "dynTempMax": 0.13
    },
    "tool": {
      "topK": -1,
      "topP": 0.9,
      "minP": 0.05,
      "temperature": 0.4,
      "maxTokens": 1024,
      "generateWindow": 1024
    }
  },
  "funFacts": {
    "key": ""
  },
  "ttsPreference": "",
  "alltalk": {
    "ttsGenEndpoint": {
      "internal": "",
      "external": ""
    },
    "ttsServeEndpoint": {
      "internal": "",
      "external": ""
    },
    "healthcheck": {
      "internal": "",
      "external": ""
    }
  },
  "fishTTS": {
    "ttsGenEndpoint": {
      "internal": "",
      "external": ""
    },
    "ttsServeEndpoint": {
      "internal": "",
      "external": ""
    },
    "healthcheck": {
      "internal": "",
      "external": ""
    }
  }
}
</file>

<file path="views/character.njk">
{% extends "layout.njk" %}
{% block title %}Character Editor{% endblock %}
{% block content %}
  <div class="card">
    <div class="card-header">
      <h1>Character Editor</h1>
    </div>
    <p>
      Customize your AI assistant's personality, description, and behavior. These settings help define how your assistant interacts with your Twitch chat.
    </p>
    <div class="tabs">
      <div class="tab active" data-target="personality-tab">Personality</div>
      <div class="tab" data-target="description-tab">Description</div>
      <div class="tab" data-target="example-messages-tab">Example Messages</div>
      <div class="tab" data-target="features-tab">Features</div>
    </div>
    <div id="personality-tab" class="tab-content active">
      <form action="/api/v1/character/personality" method="POST" data-async>
        <div class="form-group">
          <label for="bot_name">Character Name</label>
          <input type="text"
                 id="bot_name"
                 name="bot_name"
                 value="{{ character.bot_name }}"
                 required>
          <p>This is the name your AI assistant will use.</p>
        </div>
        <div class="form-group">
          <label for="personality">Personality</label>
          <textarea id="personality" name="personality" rows="12" required>{{ characterPersonality }}</textarea>
          <p>Describe your assistant's personality traits, mannerisms, speaking style, interests, and attitudes.</p>
        </div>
        <button type="submit" class="btn btn-primary">Save Personality</button>
      </form>
    </div>
    <div id="description-tab" class="tab-content">
      <form action="/api/v1/character/description" method="POST" data-async>
        <div class="form-group">
          <label for="description">Physical Description</label>
          <textarea id="description" name="description" rows="12" required>{{ characterDescription }}</textarea>
          <p>Describe your assistant's appearance, physical attributes, clothing, and other visual aspects.</p>
        </div>
        <button type="submit" class="btn btn-primary">Save Description</button>
      </form>
    </div>
    <div id="example-messages-tab" class="tab-content">
      <form action="/api/v1/character/examples" method="POST" data-async>
        <div class="form-group">
          <label for="examples">Example Interactions</label>
          <textarea id="examples" name="examples" rows="15" required>{{ characterExamples }}</textarea>
          <p>
            Provide examples of how your assistant would respond to different situations. This helps establish the assistant's tone and style. Format as:
          </p>
          <pre style="background-color: var(--input-bg); padding: 10px; margin-top: 5px; border-radius: 6px;">
{{ character.bot_name }}: [Example response]

{{ character.bot_name }}: [Another response]</pre>
        </div>
        <button type="submit" class="btn btn-primary">Save Examples</button>
      </form>
    </div>
  </div>
  <div id="features-tab" class="tab-content">
    <form action="/api/v1/character/features" method="POST" data-async>
      <div class="form-group">
        <label for="funFacts">Fun Facts</label>
        <select id="funFacts" name="funFacts">
          <option value="true" {% if character.funFacts %}selected{% endif %}>Enabled</option>
          <option value="false" {% if not character.funFacts %}selected{% endif %}>Disabled</option>
        </select>
        <p>Enable your AI assistant to occasionally share interesting fun facts in chat.</p>
      </div>
      <div class="form-group">
        <label for="funFactsInterval">Fun Facts Interval (minutes)</label>
        <input type="number"
               id="funFactsInterval"
               name="funFactsInterval"
               value="{{ character.funFactsInterval or '30' }}"
               min="5"
               max="240">
        <p>How often should your assistant share fun facts? (5-240 minutes)</p>
      </div>
      <div class="form-group">
        <label for="tts_enabled">Text-to-Speech</label>
        <select id="tts_enabled" name="tts_enabled">
          <option value="true" {% if character.tts_enabled %}selected{% endif %}>Enabled</option>
          <option value="false" {% if not character.tts_enabled %}selected{% endif %}>Disabled</option>
        </select>
        <p>Enable your AI assistant to use text-to-speech for voice responses.</p>
      </div>
      <div class="form-group">
        <label for="ttsEqPref">Voice Quality Preset</label>
        <select id="ttsEqPref"
                name="ttsEqPref"
                {% if not character.tts_enabled %}disabled{% endif %}>
          <option value="clarity"
                  {% if character.ttsEqPref == 'clarity' %}selected{% endif %}>Clarity</option>
          <option value="warm"
                  {% if character.ttsEqPref == 'warm' %}selected{% endif %}>Warm</option>
          <option value="bright"
                  {% if character.ttsEqPref == 'bright' %}selected{% endif %}>Bright</option>
          <option value="broadcast"
                  {% if character.ttsEqPref == 'broadcast' %}selected{% endif %}>Broadcast</option>
        </select>
        <p>Choose a preset for your assistant's voice quality.</p>
      </div>
      <div class="form-group">
        <label for="ttsUpsamplePref">Audio Upsampling</label>
        <select id="ttsUpsamplePref"
                name="ttsUpsamplePref"
                {% if not character.tts_enabled %}disabled{% endif %}>
          <option value="true" {% if character.ttsUpsamplePref %}selected{% endif %}>Enabled</option>
          <option value="false"
                  {% if not character.ttsUpsamplePref %}selected{% endif %}>Disabled</option>
        </select>
        <p>Enable audio upsampling for better voice quality (uses more CPU).</p>
      </div>
      <button type="submit" class="btn btn-primary">Save Features</button>
    </form>
    <div class="card" style="margin-top: 20px;">
      <h3>Custom Voice Upload</h3>
      <p>Upload up to 4 WAV audio samples of your character's voice. Files must be mono, 16-bit, 22050Hz, 44100Hz, or 48000Hz, ≤20 seconds, and under 3MB each.</p>
      
      {% if character.speaker_file %}
      <div class="alert alert-success">
        <p>Voice samples configured: <strong>{{ character.speaker_file }}</strong></p>
      </div>
      {% endif %}
      
      <div class="file-input-wrapper">
        <label for="voice-file-input" class="btn btn-secondary">Browse Files</label>
        <span id="file-select-text">No file selected</span>
        <input type="file" id="voice-file-input" accept="audio/wav" style="display: none;">
      </div>
      
      <button type="button" id="add-file-btn" class="btn btn-secondary" disabled style="margin-top: 10px;">Add File</button>
      
      <div id="validation-message" class="alert alert-error" style="display: none; margin-top: 10px;"></div>
      
      <div id="selected-files-container" style="margin-top: 15px; display: none;">
        <h4>Selected Files</h4>
        <table class="file-list-table" style="width: 100%; border-collapse: collapse;">
          <thead>
            <tr>
              <th style="text-align: left; padding: 8px; border-bottom: 1px solid var(--border);">Filename</th>
              <th style="text-align: left; padding: 8px; border-bottom: 1px solid var(--border);">Size</th>
              <th style="text-align: left; padding: 8px; border-bottom: 1px solid var(--border);">Actions</th>
            </tr>
          </thead>
          <tbody id="file-list-table">
            <!-- Files will be added here dynamically -->
          </tbody>
        </table>
      </div>
      
      <button type="button" id="upload-btn" class="btn btn-primary" style="margin-top: 15px;" disabled>Upload Voice Samples</button>
    </div>
  </div>

  <style>
    input[type="file"].form-control {
        padding: 6px;
        background-color: var(--input-bg);
        color: var(--primary-text);
        border: 1px solid var(--border);
        border-radius: 6px;
        width: 100%;
        max-width: 500px;
        margin-top: 5px;
      }
      
    .form-text {
      display: block;
      margin-top: 5px;
      color: var(--secondary-text);
    }

    .file-input-wrapper {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    #file-select-text {
      color: var(--secondary-text);
      margin-left: 5px;
      flex-grow: 1;
    }
    
    .file-list-table {
      background-color: var(--input-bg);
      border-radius: 6px;
      overflow: hidden;
    }
    
    .file-list-table tbody tr {
      border-bottom: 1px solid var(--border);
    }
    
    .file-list-table tbody tr:last-child {
      border-bottom: none;
    }
    
    .file-list-table td {
      padding: 8px;
    }
    
    .file-action-btn {
      background-color: var(--button-secondary-bg);
      color: var(--primary-text);
      border: none;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .file-action-btn:hover {
      background-color: var(--button-secondary-hover);
    }
    
    .remove-file-btn {
      color: var(--error);
    }
  </style>
{% endblock %}
{% block extraScripts %}
<script>
  document.addEventListener('DOMContentLoaded', () => {
    const fileInput = document.getElementById('voice-file-input');
    const fileSelectText = document.getElementById('file-select-text');
    const addFileBtn = document.getElementById('add-file-btn');
    const fileListTable = document.getElementById('file-list-table');
    const selectedFilesContainer = document.getElementById('selected-files-container');
    const validationMessage = document.getElementById('validation-message');
    const uploadBtn = document.getElementById('upload-btn');
    
    // Array to store selected files with their data
    const selectedFiles = [];
    
    // When file is selected in the file input
    fileInput.addEventListener('change', async (e) => {
      validationMessage.style.display = 'none';
      
      if (fileInput.files.length > 0) {
        const file = fileInput.files[0];
        fileSelectText.textContent = file.name;
        
        // Check file size
        if (file.size > 3 * 1024 * 1024) {
          validationMessage.textContent = 'File exceeds 3MB size limit';
          validationMessage.style.display = 'block';
          addFileBtn.disabled = true;
          return;
        }
        
        // Check file extension
        if (!file.name.toLowerCase().endsWith('.wav')) {
          validationMessage.textContent = 'Only WAV files are accepted';
          validationMessage.style.display = 'block';
          addFileBtn.disabled = true;
          return;
        }
        
        addFileBtn.disabled = false;
      } else {
        fileSelectText.textContent = 'No file selected';
        addFileBtn.disabled = true;
      }
    });
    
    // Add file button click
    addFileBtn.addEventListener('click', async () => {
      if (fileInput.files.length === 0) return;
      
      const file = fileInput.files[0];
      
      // Check if we already have 4 files
      if (selectedFiles.length >= 4) {
        validationMessage.textContent = 'Maximum 4 files allowed';
        validationMessage.style.display = 'block';
        return;
      }
      
      // Check if file with same name already exists
      if (selectedFiles.some(f => f.name === file.name)) {
        validationMessage.textContent = 'A file with this name is already added';
        validationMessage.style.display = 'block';
        return;
      }
      
      try {
        // Read file as base64
        const base64 = await readFileAsBase64(file);
        
        // Add file to our array
        selectedFiles.push({
          name: file.name,
          size: file.size,
          data: base64
        });
        
        // Add to UI
        addFileToTable(file);
        
        // Reset file input
        fileInput.value = '';
        fileSelectText.textContent = 'No file selected';
        addFileBtn.disabled = true;
        
        // Show container if this is the first file
        if (selectedFiles.length === 1) {
          selectedFilesContainer.style.display = 'block';
        }
        
        // Enable upload button if we have files
        updateUploadButtonState();
      } catch (error) {
        console.error('Error reading file:', error);
        validationMessage.textContent = 'Error reading file';
        validationMessage.style.display = 'block';
      }
    });
    
    // Function to read file as base64
    function readFileAsBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }
    
    // Function to add a file to the table
    function addFileToTable(file) {
      const row = document.createElement('tr');
      row.id = `file-row-${file.name.replace(/[^a-z0-9]/gi, '-')}`;
      
      const sizeKB = (file.size / 1024).toFixed(1);
      
      row.innerHTML = `
        <td>${file.name}</td>
        <td>${sizeKB} KB</td>
        <td>
          <button type="button" class="file-action-btn remove-file-btn" data-filename="${file.name}">
            Remove
          </button>
        </td>
      `;
      
      fileListTable.appendChild(row);
      
      // Add event listener to remove button
      row.querySelector('.remove-file-btn').addEventListener('click', function() {
        const filename = this.getAttribute('data-filename');
        removeFile(filename);
      });
    }
    
    // Function to remove a file
    function removeFile(filename) {
      // Remove from array
      const index = selectedFiles.findIndex(f => f.name === filename);
      if (index > -1) {
        selectedFiles.splice(index, 1);
      }
      
      // Remove from UI
      const row = document.getElementById(`file-row-${filename.replace(/[^a-z0-9]/gi, '-')}`);
      if (row) {
        row.remove();
      }
      
      // Hide container if no files left
      if (selectedFiles.length === 0) {
        selectedFilesContainer.style.display = 'none';
      }
      
      // Update upload button state
      updateUploadButtonState();
    }
    
    // Update upload button enabled/disabled state
    function updateUploadButtonState() {
      uploadBtn.disabled = selectedFiles.length === 0;
    }
    
    // Handle upload button click - send data via AJAX
    uploadBtn.addEventListener('click', async () => {
      if (selectedFiles.length === 0) {
        validationMessage.textContent = 'Please add at least one file';
        validationMessage.style.display = 'block';
        return;
      }
      
      // Show loading state
      uploadBtn.disabled = true;
      uploadBtn.innerHTML = '<span class="loading"></span> Uploading...';
      
      try {
        // Send files to server
        const response = await fetch('/api/v1/character/voice-upload', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ files: selectedFiles })
        });
        
        // Handle response
        if (response.redirected) {
          window.location.href = response.url;
        } else {
          const data = await response.json();
          if (data.success) {
            window.location.href = '/web/character?success=Voice+files+uploaded+successfully';
          } else {
            validationMessage.textContent = data.error || 'Upload failed';
            validationMessage.style.display = 'block';
            uploadBtn.disabled = false;
            uploadBtn.textContent = 'Upload Voice Samples';
          }
        }
      } catch (error) {
        console.error('Upload error:', error);
        validationMessage.textContent = 'Error uploading files';
        validationMessage.style.display = 'block';
        uploadBtn.disabled = false;
        uploadBtn.textContent = 'Upload Voice Samples';
      }
    });
  });
</script>
{% endblock %}
</file>

<file path="logger.js">
// logger.js - Updated with fixed error handling
import moment from "moment";
import fs from 'fs/promises';

// Create logs directory if it doesn't exist
try {
  await fs.mkdir('./logs', { recursive: true });
} catch (err) {
  // Directory likely already exists, ignore
}

export const createLogger = (
  withUI = false,
  logBox = null,
  screen = null,
) => {
  const getTimestamp = () => moment().format("MM/DD/YY [at] HH:mm");

  const formatLogMessage = (source, message) => {
    const timestamp = getTimestamp();
    const formattedMessage =
      typeof message === "string" ? message : JSON.stringify(message);
    return `{gray-fg}${timestamp}{/} [${source}] ${formattedMessage}`;
  };

  const logToScreen = (source, message) => {
    if (withUI && logBox && screen) {
      const formattedLog = formatLogMessage(source, message);
      logBox.pushLine(formattedLog);
      screen.render();
    }
  };

  const logToFile = async (source, message, type) => {
    try {
      const timestamp = getTimestamp();
      const formattedMessage = typeof message === "string" ? message : JSON.stringify(message);
      const logEntry = `${timestamp} [${source}] [${type}] ${formattedMessage}\n`;
      
      // Append to daily log file
      const today = moment().format('YYYY-MM-DD');
      await fs.appendFile(`./logs/${today}.log`, logEntry);
      
      // Also append to type-specific log if it's an error or warning
      if (type === 'error' || type === 'warn') {
        await fs.appendFile(`./logs/${type}.log`, logEntry);
      }
    } catch (err) {
      // If we can't log to file, at least try to show it on screen
      if (withUI && logBox && screen) {
        logBox.pushLine(`{red-fg}Error writing to log file: ${err.message}{/}`);
        screen.render();
      }
    }
  };

  const writeTrace = async (trace, dest) => {
    try {
      await fs.writeFile(`./logs/${dest}`, trace + '\n');
    } catch (err) {
      if (withUI && logBox && screen) {
        logBox.pushLine(`{red-fg}Error writing trace to file: ${err.message}{/}`);
        screen.render();
      }
    }
  };

  const logMessage = (source, message, type = "info") => {
    // Log to UI
    logToScreen(source, message);
    
    // Log to file
    logToFile(source, message, type);
  };

  return {
    log: (source, message, type = "info") => logMessage(source, message, type),
    system: (message) => logMessage("System", message, "info"),
    error: (source, message) => logMessage(source, message, "error"),
    warn: (source, message) => logMessage(source, message, "warn"),
    info: (source, message) => logMessage(source, message, "info"),
    debug: (source, message) => logMessage(source, message, "debug"),
    trace: (trace, dest) => writeTrace(trace, dest)
  };
};

// Get the global logger if available, otherwise create a basic one
export function getLogger() {
  if (global._sharedObjects && global._sharedObjects.logger) {
    return global._sharedObjects.logger;
  }
  
  if (global.logger) {
    return global.logger;
  }
  
  // Fallback logger
  return createLogger(false);
}

// Export a shared logger instance to be used by modules
export const logger = getLogger();
</file>

<file path="main.js">
// main.js - Main application file without using cluster
import blessed from "neo-blessed";
import { createLogger } from "./logger.js";
import * as aiHelper from "./ai-logic.js";
import { saveAuthToDisk, updateUserParameter } from "./api-helper.js";
import { saveConfigToDisk, retrieveConfigValue, saveConfigValue } from "./config-helper.js";
import { fork } from "child_process";

// Capture original console methods
const originalConsole = {
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error,
  debug: console.debug
};

// Setup the UI
const screen = blessed.screen({
  fastCSR: true,
  terminal: "xterm-256color",
  fullUnicode: true,
  dockBorders: true,
  autoPadding: true,
  ignoreDockContrast: false,
});

// Set application title
screen.title = "🌟 Enspira";

// Create UI components
const statusBar = blessed.box({
  top: 0,
  left: 0,
  width: "100%",
  height: 1,
  border: {
    type: "line",
  },
  style: {
    border: {
      fg: "green",
    },
  },
});

const servicesText = blessed.text({
  parent: statusBar,
  top: 0,
  left: 1,
  content: "{bold}Services: {gray-fg}?{/gray-fg}{/bold}",
  tags: true,
});

const apiStatusText = blessed.text({
  parent: statusBar,
  left: `69%`,
  top: 0,
  content: "{left}REST: {gray-fg}?{/gray-fg}{/left}",
  tags: true,
});

const dbStatus = blessed.text({
  parent: statusBar,
  left: `80%`,
  top: 0,
  content: "{left}DB: {gray-fg}?{/gray-fg}{/left}",
  tags: true,
});

const llmStackStatus = blessed.text({
  parent: statusBar,
  left: `90%`,
  top: 0,
  content: "{left}LLM: {gray-fg}?{/gray-fg}{/left}",
  tags: true,
});

const logBox = blessed.log({
  top: 3,
  left: 0,
  bottom: 6,
  width: "100%",
  height: `97%-${statusBar.height + 3}`,
  label: "Logs",
  border: {
    type: "line",
  },
  style: {
    border: {
      fg: "cyan",
    },
  },
  tags: true,
  scrollable: true,
  alwaysScroll: true,
  scrollbar: {
    ch: " ",
    track: {
      bg: "grey",
    },
    style: {
      inverse: true,
    },
  },
  keys: true,
  mouse: true,
  vi: true,
});

const inputBar = blessed.textbox({
  bottom: 0,
  left: 0,
  width: "100%",
  height: 3,
  label: "Command",
  border: {
    type: "line",
  },
  style: {
    border: {
      fg: "magenta",
    },
  },
  inputOnFocus: true,
});

// Add components to screen
screen.append(logBox);
screen.append(inputBar);
screen.append(statusBar);

// Create the logger and set it globally
const logger = createLogger(true, logBox, screen);
global.logger = logger;

// Make logger available as a module export for other modules to import
if (!global._sharedObjects) {
  global._sharedObjects = {};
}
global._sharedObjects.logger = logger;

console.log = (...args) => logger.log("Console", args.join(' '));
console.info = (...args) => logger.info(args.join(' '));
console.warn = (...args) => logger.warn(args.join(' '));
console.error = (...args) => logger.error(args.join(' '));
console.debug = (...args) => logger.debug(args.join(' '));

// Setup status bar update function
function updateStatusBar(apiActive = false, dbConnected = false, llmStackConnected = 0) {
  try {
    const apiStatus = apiActive
      ? "{left}REST: {green-fg}✓{/green-fg} Up{/left}"
      : "{left}REST: {red-fg}❌{/red-fg} Down{/left}";

    // Update DB status
    try {
      if (dbStatus) {
        screen.clearRegion(
          dbStatus.left,
          dbStatus.top,
          dbStatus.width,
          dbStatus.height
        );
        dbStatus.setContent(dbConnected
          ? `{left}DB: {green-fg}✓{/green-fg} Up{/left}`
          : `{left}DB: {red-fg}❌{/red-fg} Down{/left}`
        );
      }
    } catch (dbError) {
      logger.error("UI", `Error updating DB status: ${dbError.message}`);
    }

    // Update LLM stack status
    try {
      if (servicesText && llmStackStatus) {
        switch (llmStackConnected) {
          case 0:
            screen.title = "🌟 [DOWN] Enspira";
            servicesText.setContent(`{bold}Services: {red-fg}Down{/red-fg}{/bold}`);
            llmStackStatus.setContent(`{left}LLM: {red-fg}❌{/red-fg} Down{/left}`);
            break;
          case 1:
            screen.title = "🌟 [DEGRADED] Enspira";
            servicesText.setContent(`{bold}Services: {yellow-fg}Degraded{/yellow-fg}{/bold}`);
            llmStackStatus.setContent(`{left}LLM: {yellow-fg}⚠{/yellow-fg}{/left}`);
            break;
          case 2:
            screen.title = "🌟 [HEALTHY] Enspira";
            servicesText.setContent(`{bold}Services: {green-fg}All Online{/green-fg}{/bold}`);
            llmStackStatus.setContent(`{left}LLM: {green-fg}✓{/green-fg} Up{/left}`);
            break;
          default:
            break;
        }
      }
    } catch (llmError) {
      logger.error("UI", `Error updating LLM status: ${llmError.message}`);
    }

    // Update API status
    try {
      if (apiStatusText) {
        apiStatusText.setContent(apiStatus);
      }
    } catch (apiError) {
      logger.error("UI", `Error updating API status: ${apiError.message}`);
    }

    // Render screen only once at the end
    try {
      screen.render();
    } catch (renderError) {
      logger.error("UI", `Error rendering screen: ${renderError.message}`);
    }
  } catch (error) {
    logger.error("UI", `Error in updateStatusBar: ${error.message}`);
    // Don't propagate UI errors
  }
}

// Handle scrolling and navigation events
logBox.on("wheelup", () => {
  logBox.scroll(-1);
  screen.render();
});

logBox.on("wheeldown", () => {
  logBox.scroll(1);
  screen.render();
});

logBox.key(["pageup"], () => {
  logBox.scroll(-logBox.height);
  screen.render();
});

logBox.key(["pagedown"], () => {
  logBox.scroll(logBox.height);
  screen.render();
});

logBox.key(["enter"], () => {
  inputBar.focus();
  screen.render();
});

screen.key(["i"], () => {
  inputBar.focus();
  inputBar.readInput();
  screen.render();
});

screen.key(["up", "down"], () => {
  logBox.focus();
  screen.render();
});

// Variable to track whether we're shutting down
let isShuttingDown = false;

// Function to reset the app module cache
function clearModuleCache() {
  Object.keys(require.cache).forEach(function (key) {
    if (!key.includes('node_modules')) {
      delete require.cache[key];
    }
  });
}

// Application restart function
async function restartApplication() {
  logger.log("System", "Restarting application...");

  // Clean up and save anything important
  await saveAuthToDisk();
  await saveConfigToDisk();

  // For ES modules, we'll use a different approach with child_process
  const restartProcess = fork('./restart-helper.js', [], {
    detached: true,
    stdio: 'ignore'
  });

  restartProcess.unref();
  process.exit(0);
}

// Function to perform a clean shutdown
async function shutdown() {
  if (isShuttingDown) return;

  isShuttingDown = true;
  logger.log("System", "Saving data before shutdown...");

  try {
    await saveAuthToDisk();
    await saveConfigToDisk();
    logger.log("System", "All data saved. Shutting down...");

    // Give time for message to display
    setTimeout(() => {
      process.exit(0);
    }, 500);
  } catch (error) {
    logger.error("System", `Error during shutdown: ${error.message}`);
    process.exit(1);
  }
}

// Handle command input
inputBar.on("submit", async (text) => {
  if (!text.trim()) {
    inputBar.clearValue();
    screen.render();
    return;
  }

  const firstWord = text.trim().split(/\s+/)[0].toLowerCase();
  const args = text.trim().slice(firstWord.length).trim();

  inputBar.clearValue();
  screen.render();

  try {
    switch (firstWord) {
      case "exit":
        shutdown();
        break;

      case "restart":
        logger.log("System", "Restarting framework...");
        restartApplication();
        break;

      case "flush_chat":
        await saveChatContextToDisk(args);
        break;

      case "setpass":
        if (!args) {
          logger.log("System", `Please specify a user ID and password.`);
          break;
        }

        const passArgs = args.split(' ');
        if (passArgs.length < 2) {
          logger.log("System", `Please provide both a user ID and password.`);
          break;
        }

        const userIds = passArgs[0];
        const plainPassword = passArgs.slice(1).join(' '); // Handle passwords with spaces

        try {
          // Import hashPassword function from routes/v1.js
          const { hashPassword } = await import('./routes/v1.js');
          const passwordData = await hashPassword(plainPassword);

          // Update user parameters with hashed password data
          const hashUpdate = await updateUserParameter(
            userIds,
            "webPasswordHash",
            passwordData.hash
          );

          const saltUpdate = await updateUserParameter(
            userIds,
            "webPasswordSalt",
            passwordData.salt
          );

          const iterUpdate = await updateUserParameter(
            userIds,
            "webPasswordIterations",
            passwordData.iterations
          );

          if (hashUpdate && saltUpdate && iterUpdate) {
            logger.log("System", `Password updated successfully for user ${userIds}`);
          } else {
            logger.log("System", `Failed to update password for user ${userIds}`);
          }
        } catch (passError) {
          logger.error("System", `Error setting password: ${passError.message}`);
        }
        break;

      case "test_chats":
        const testChats = await aiHelper.returnRecentChats(args, true);
        logger.log("Milvus", `Got the following content: ${JSON.stringify(testChats.chatList)} in ${testChats.executionTime} seconds.`);
        break;

      case "reload_db":
        if (!args) {
          logger.log("System", `Please specify a database to reload.`);
          break;
        }

        const items = args.split(" ");
        const collectionName = items[0];
        const userId = items[1];

        logger.log("System", `Issuing reload DB command...`);
        const done = await aiHelper.weGottaGoBald(collectionName, userId);

        if (done) {
          logger.log("System", `Database reload initiated.`);
        } else {
          logger.log("System", `Database reload failed.`);
        }
        break;

      case "get":
        if (!args) {
          logger.log("System", `Please specify a setting to retrieve.`);
          break;
        }

        const getSetValue = await retrieveConfigValue(args);
        logger.log("System", `'${args}' is set to: ${typeof (getSetValue) === "object" ?
          `${JSON.stringify(getSetValue, { spaces: 2 })}` : `${getSetValue}`}`);
        break;

      case "set":
        if (!args) {
          logger.log("System", `Please specify a setting and value to set.`);
          break;
        }

        const choices = args.split(' ');
        if (choices.length < 2) {
          logger.log("System", `Please provide both a setting name and value.`);
          break;
        }

        const didSave = await saveConfigValue(choices[0], choices[1]);
        didSave ?
          logger.log("Config", `Value '${choices[1]}' for parameter '${choices[0]}' saved.`) :
          logger.log("Config", `Value '${choices[1]}' for parameter '${choices[0]}' failed to save.`);
        break;

      case "setuser":
        if (!args) {
          logger.log("System", `Please specify a user, setting, and value.`);
          break;
        }

        const userChoices = args.split(' ');
        if (userChoices.length < 3) {
          logger.log("System", `Please provide a user ID, setting name, and value.`);
          break;
        }

        const updated = await updateUserParameter(userChoices[0], userChoices[1], userChoices[2]);
        updated ?
          logger.log("Config", `Value '${userChoices[2]}' for parameter '${userChoices[1]}' for user '${userChoices[0]}' saved.`) :
          logger.log("Config", `Value '${userChoices[2]}' for parameter '${userChoices[1]}' for user '${userChoices[0]}' failed to save.`);
        break;

      case "augment":
        logger.log("System", `Sending augmentation request...`);
        const augArgs = args.split(' ');
        if (augArgs.length < 2) {
          logger.log("System", `Please provide both a query and subject.`);
          break;
        }
        await manualRetrieveWebContext(augArgs[0], augArgs[1]);
        break;

      case "reindex":
        logger.log("System", "Issuing RAG rebuild...");
        if (!args) {
          logger.log("System", `Please specify a user ID.`);
          break;
        }
        await aiHelper.startIndexingVectors(args);
        break;

      case "infer":
        if (!args) {
          logger.log("System", "Please enter a search inference");
          break;
        }
        logger.log("LLM", `Generating inference optimized search for term ${args}`);
        await aiHelper.inferSearchParam(args);
        break;

      default:
        logger.log("System", `Invalid command '${firstWord}'. Try again.`);
        break;
    }
  } catch (error) {
    logger.error("System", `Error executing command: ${error.message}`);
  }

  logBox.focus();
});

// Handle confirmation dialog setup
const showConfirmationBox = (title, message) => {
  return new Promise((resolve) => {
    const boxWidth = Math.floor(screen.width * 0.8);

    const lines = message.split("\n").reduce((acc, line) => {
      const wrappedLines = Math.ceil(line.length / (boxWidth - 4));
      return acc + wrappedLines;
    }, 0);

    const boxHeight = Math.min(lines + 5, Math.floor(screen.height * 0.5));
    const buttonHeight = 3;
    const totalHeight = boxHeight + buttonHeight;

    const confirmBox = blessed.box({
      parent: screen,
      border: "line",
      height: totalHeight,
      width: boxWidth,
      top: Math.floor((screen.height - totalHeight) / 2),
      left: Math.floor((screen.width - boxWidth) / 2),
      label: ` {bold}${title}{/bold} `,
      tags: true,
      keys: true,
      vi: true,
      style: {
        border: {
          fg: "yellow",
        },
        focus: {
          border: {
            fg: "green",
          },
        },
      },
    });

    const messageText = blessed.text({
      parent: confirmBox,
      content: message,
      top: 1,
      left: 1,
      shrink: true,
      width: boxWidth - 4,
      style: {
        fg: "white",
      },
    });

    const yesButton = blessed.button({
      parent: confirmBox,
      mouse: true,
      keys: true,
      shrink: true,
      padding: {
        left: 1,
        right: 1,
      },
      left: Math.floor(boxWidth * 0.25),
      top: totalHeight - buttonHeight + 1,
      name: "yes",
      content: "Yes",
      style: {
        bg: "green",
        focus: {
          bg: "white",
          fg: "black",
        },
      },
    });

    const noButton = blessed.button({
      parent: confirmBox,
      mouse: true,
      keys: true,
      shrink: true,
      padding: {
        left: 1,
        right: 1,
      },
      left: Math.floor(boxWidth * 0.55),
      top: totalHeight - buttonHeight + 1,
      name: "no",
      content: "No",
      style: {
        bg: "red",
        focus: {
          bg: "white",
          fg: "black",
        },
      },
    });

    yesButton.on("press", () => {
      confirmBox.destroy();
      screen.render();
      resolve(true);
    });

    noButton.on("press", () => {
      confirmBox.destroy();
      screen.render();
      resolve(false);
    });

    yesButton.key(["tab"], () => {
      noButton.focus();
    });

    noButton.key(["tab"], () => {
      yesButton.focus();
    });

    confirmBox.key(["enter"], () => {
      if (yesButton.hasFocus()) {
        yesButton.emit("press");
      } else {
        noButton.emit("press");
      }
    });

    yesButton.focus();

    yesButton.on("focus", () => {
      yesButton.style.bg = "white";
      yesButton.style.fg = "black";
      noButton.style.bg = "red";
      noButton.style.fg = "white";
    });

    noButton.on("focus", () => {
      noButton.style.bg = "white";
      noButton.style.fg = "black";
      yesButton.style.bg = "green";
      yesButton.style.fg = "white";
    });

    screen.render();
  });
};

// Handle process shutdown gracefully
process.on("SIGTERM", shutdown);
process.on("SIGINT", shutdown);

// Initialize and run the application
async function initializeApp() {
  try {
    // Log application startup
    logger.log("System", "Enspira application starting...");
    // Import and start the API server
    const { initializeApp: startApp } = await import('./index.js');

    // Start the application and get the server and status
    logger.log("System", "Starting REST server and initializing services...");
    const { server, status } = await startApp();

    // Process preflight status
    let failed = 0;
    let available = 0;
    Object.keys(status.llmStatuses).forEach(function (key) {
      if (status.llmStatuses[key] == true) {
        available += 1;
      } else {
        failed += 1;
      }
    });

    try {
      if (failed == available) {
        logger.log(
          "System",
          "Pre-flight checks failed for all LLM services. Check your URLs and API keys, and try again.",
        );
        updateStatusBar(status.restIsOnline, status.dbIsOnline, 0);
      } else if (failed < available && failed > 0) {
        logger.log(
          "System",
          "Some pre-flight checks failed for LLM services. Check your URLs and API keys, and try again.",
        );
        updateStatusBar(status.restIsOnline, status.dbIsOnline, 1);
      } else {
        logger.log("System", "All pre-flight checks for LLM services passed.");
        updateStatusBar(status.restIsOnline, status.dbIsOnline, 2);
      }
    } catch (uiError) {
      logger.error("System", `Error updating status bar UI: ${uiError.message}`);
      // Continue execution even if UI update fails
    }

    try {
      logger.log("System", "Importing Twitch EventSub manager...");
      const { registerAllUsersEventSub } = await import('./twitch-eventsub-manager.js');

      logger.log("System", "Registering Twitch EventSub subscriptions...");
      const eventSubResults = await registerAllUsersEventSub();
      logger.log("System", `EventSub registration complete: ${eventSubResults.success} successful, ${eventSubResults.failures} failed`);
    } catch (eventSubError) {
      logger.error("System", `Error with Twitch EventSub: ${eventSubError.message}`);
      // Continue execution even if EventSub registration fails
    }

    logger.log("System", "Enspira is fully initialized and ready!");
    return { server, status };
  } catch (error) {
    logger.error("System", `Failed to initialize application: ${error.message}`);
    try {
      updateStatusBar(false, false, 0);
    } catch (uiError) {
      // Ignore UI errors during failure state
    }
    throw error;
  }
}

// Start everything up
initializeApp();
</file>

<file path="mongodb-client.js">
// mongodb-client.js - New module for MongoDB operations
import mongoose from "mongoose";
import fs from "fs-extra";
import { retrieveConfigValue } from "./config-helper.js";
import { logger } from "./create-global-logger.js";

// Cache with TTL
const userCache = new Map();
const dirtyFlags = new Map();
let connectionEstablished = false;
let connectionRetries = 0;
const MAX_RETRIES = 5;

// mongodb-client.js - Updated schema with alternateSpell field
// Add this to the userSchema definition in mongodb-client.js

const userSchema = new mongoose.Schema(
  {
    // Required unique identifier
    user_id: { type: String, required: true, unique: true, index: true },

    // Authentication fields
    api_token: { type: String, index: true },
    webPasswordHash: String,
    webPasswordSalt: String,
    webPasswordIterations: { type: Number, default: 20480 },

    // User information
    email: String,
    user_name: String, // Used for system references
    display_name: String,

    // Twitch integration
    twitch_name: String,
    bot_name: String,
    bot_twitch: String,

    // FIXED: Add alternateSpell field for vocal interaction name replacements
    alternateSpell: {
      type: Array,
      default: [],
      validate: {
        validator: function (arr) {
          // Validate that each item is either a string or an object with from/to
          return arr.every(
            (item) =>
              typeof item === "string" ||
              (typeof item === "object" && item.from && item.to)
          );
        },
        message:
          "alternateSpell items must be strings or objects with from/to properties",
      },
    },

    // Token and integration data
    twitch_tokens: {
      streamer: {
        access_token: String,
        refresh_token: String,
        expires_at: Number,
        twitch_user_id: String,
        twitch_login: String,
        twitch_display_name: String,
        webhook_secret: String,
        subscriptions: Array,
        scopes: Array,
      },
      bot: {
        access_token: String,
        refresh_token: String,
        expires_at: Number,
        twitch_user_id: String,
        twitch_login: String,
        twitch_display_name: String,
        scopes: Array,
      },
    },

    // User preferences
    socials: {
      twitter: String,
      tiktok: String,
      youtube: String,
      instagram: String,
      twitch: String,
      kick: String,
    },

    // Stream and chat settings
    weather: { type: Boolean, default: false },
    store_all_chat: { type: Boolean, default: true },
    commands_list: { type: Array, default: [] },
    aux_bots: { type: Array, default: [] },

    // TTS settings
    tts_enabled: { type: Boolean, default: false },
    ttsEqPref: { type: String, default: "clarity" },
    ttsUpsamplePref: { type: Boolean, default: false },
    speaker_file: String,
    fishTTSVoice: String,

    // Fun facts settings
    funFacts: { type: Boolean, default: false },
    funFactsInterval: { type: Number, default: 30 },

    // Tracking fields
    lastIp: String,
    latitude: String,
    longitude: String,
    timeZone: String,

    // Stream status tracking
    current_game: Object,
    current_viewers: { type: Number, default: 0 },
    current_followers: { type: Number, default: 0 },
    stream_status: mongoose.Schema.Types.Mixed,

    // Feature flags
    global_strikes: { type: Boolean, default: false },
    global_bans: { type: Boolean, default: false },
    allow_beta_features: { type: Boolean, default: false },
    is_local: { type: Boolean, default: false },
    max_chats: { type: Number, default: 25 },
  },
  {
    strict: false, // Allow additional fields beyond schema
    timestamps: true, // Add createdAt and updatedAt automatically
    minimize: false, // Store empty objects
  }
);

// FIXED: Migration script to add alternateSpell field to existing users
async function migrateAlternateSpellField() {
  try {
    logger.log("MongoDB", "Starting migration for alternateSpell field...");

    // Update all users that don't have the alternateSpell field
    const result = await User.updateMany(
      { alternateSpell: { $exists: false } },
      { $set: { alternateSpell: [] } }
    );

    logger.log(
      "MongoDB",
      `Updated ${result.modifiedCount} users with alternateSpell field`
    );

    // For users with bot_name "Layla", add common alternate spellings
    const laylaUsers = await User.find({ bot_name: "Layla" });
    for (const user of laylaUsers) {
      if (!user.alternateSpell || user.alternateSpell.length === 0) {
        await User.updateOne(
          { user_id: user.user_id },
          {
            $set: {
              alternateSpell: ["Leila", "Lila", "Laila", "Leyla"],
            },
          }
        );
        logger.log(
          "MongoDB",
          `Added default alternate spellings for Layla user: ${user.user_id}`
        );
      }
    }

    return true;
  } catch (error) {
    logger.error(
      "MongoDB",
      `Error during alternateSpell migration: ${error.message}`
    );
    return false;
  }
}

// FIXED: Helper function to add alternate spelling to a user
export async function addAlternateSpelling(userId, alternateSpelling) {
  try {
    if (!connectionEstablished) {
      const connected = await connectToMongoDB();
      if (!connected) {
        logger.error(
          "MongoDB",
          "Cannot add alternate spelling: Database not connected"
        );
        return false;
      }
    }

    // Validate input
    if (
      typeof alternateSpelling !== "string" &&
      !(
        typeof alternateSpelling === "object" &&
        alternateSpelling.from &&
        alternateSpelling.to
      )
    ) {
      logger.error("MongoDB", "Invalid alternateSpelling format");
      return false;
    }

    // Add to user's alternateSpell array
    const result = await User.updateOne(
      { user_id: userId },
      { $addToSet: { alternateSpell: alternateSpelling } }
    );

    if (result.modifiedCount > 0) {
      // Update cache if user is cached
      if (userCache.has(userId)) {
        const cachedUser = userCache.get(userId);
        if (!cachedUser.data.alternateSpell) {
          cachedUser.data.alternateSpell = [];
        }
        cachedUser.data.alternateSpell.push(alternateSpelling);
        userCache.set(userId, {
          ...cachedUser,
          lastModified: Date.now(),
        });
      }

      logger.log(
        "MongoDB",
        `Added alternate spelling "${JSON.stringify(alternateSpelling)}" for user ${userId}`
      );
      return true;
    }

    return false;
  } catch (error) {
    logger.error(
      "MongoDB",
      `Error adding alternate spelling: ${error.message}`
    );
    return false;
  }
}

// FIXED: Helper function to remove alternate spelling from a user
export async function removeAlternateSpelling(userId, alternateSpelling) {
  try {
    if (!connectionEstablished) {
      const connected = await connectToMongoDB();
      if (!connected) {
        logger.error(
          "MongoDB",
          "Cannot remove alternate spelling: Database not connected"
        );
        return false;
      }
    }

    // Remove from user's alternateSpell array
    const result = await User.updateOne(
      { user_id: userId },
      { $pull: { alternateSpell: alternateSpelling } }
    );

    if (result.modifiedCount > 0) {
      // Update cache if user is cached
      if (userCache.has(userId)) {
        const cachedUser = userCache.get(userId);
        if (cachedUser.data.alternateSpell) {
          cachedUser.data.alternateSpell =
            cachedUser.data.alternateSpell.filter(
              (item) =>
                JSON.stringify(item) !== JSON.stringify(alternateSpelling)
            );
          userCache.set(userId, {
            ...cachedUser,
            lastModified: Date.now(),
          });
        }
      }

      logger.log(
        "MongoDB",
        `Removed alternate spelling "${JSON.stringify(alternateSpelling)}" for user ${userId}`
      );
      return true;
    }

    return false;
  } catch (error) {
    logger.error(
      "MongoDB",
      `Error removing alternate spelling: ${error.message}`
    );
    return false;
  }
}

async function migrateFromFileIfNeeded() {
  try {
    const count = await User.countDocuments({});
    if (count === 0) {
      logger.log("MongoDB", "Collection is empty, migrating from file...");

      const authFilePath = await retrieveConfigValue("server.authFilePath");
      if (fs.existsSync(authFilePath)) {
        const fileData = await fs.readJSON(authFilePath);

        if (Array.isArray(fileData) && fileData.length > 0) {
          // Transform the data before inserting
          const transformedData = fileData.map((user) => {
            // Create a clean copy of the user object
            const transformedUser = { ...user };

            // FIXED: Add alternateSpell field if it doesn't exist
            if (!transformedUser.alternateSpell) {
              transformedUser.alternateSpell = [];

              // Add default alternate spellings for common names
              if (transformedUser.bot_name === "Layla") {
                transformedUser.alternateSpell = [
                  "Leila",
                  "Lila",
                  "Laila",
                  "Leyla",
                ];
              }
            }

            // Fix stream_status if it exists but isn't in the right format
            if (
              transformedUser.stream_status &&
              typeof transformedUser.stream_status !== "object"
            ) {
              transformedUser.stream_status = {
                online: false,
                updated_at: new Date().toISOString(),
              };
            } else if (transformedUser.stream_status) {
              // Ensure it has the expected structure
              transformedUser.stream_status = {
                online: transformedUser.stream_status.online || false,
                started_at: transformedUser.stream_status.started_at || null,
                type: transformedUser.stream_status.type || null,
                title: transformedUser.stream_status.title || null,
                viewer_count: transformedUser.stream_status.viewer_count || 0,
                updated_at:
                  transformedUser.stream_status.updated_at ||
                  new Date().toISOString(),
              };
            }

            return transformedUser;
          });

          // Insert transformed data
          await User.insertMany(transformedData, { validateBeforeSave: false });
          logger.log(
            "MongoDB",
            `Migrated ${transformedData.length} users from file to MongoDB`
          );

          // Create backup of original file
          const backupPath = `${authFilePath}.bak.${Date.now()}`;
          await fs.copy(authFilePath, backupPath);
          logger.log(
            "MongoDB",
            `Created backup of original auth file at ${backupPath}`
          );
        }
      }
    } else {
      // FIXED: Run the alternateSpell migration for existing users
      await migrateAlternateSpellField();
    }
  } catch (error) {
    logger.error("MongoDB", `Migration error: ${error.message}`);
  }
}

const chatMessageSchema = new mongoose.Schema(
  {
    user_id: { type: String, required: true, index: true },
    username: { type: String, required: true },
    message: { type: String, required: true },
    message_id: { type: String, required: true, unique: true },
    timestamp: { type: Date, default: Date.now, index: true },
    ai_response: String,
    embedding_id: String, // Reference to Milvus if message has embedding
    is_important: { type: Boolean, default: false },
    metadata: mongoose.Schema.Types.Mixed,
  },
  {
    strict: false,
    timestamps: true,
  }
);

chatMessageSchema.index({ user_id: 1, timestamp: -1 });
chatMessageSchema.index({ username: 1, user_id: 1 });
chatMessageSchema.index({ message: "text", ai_response: "text" });

// Create indexes for performance
userSchema.index({ "twitch_tokens.streamer.twitch_user_id": 1 });
userSchema.index({ "twitch_tokens.bot.twitch_user_id": 1 });
userSchema.index({ user_id: 1 });

const User = mongoose.model("User", userSchema, "user_data");
const ChatMessage = mongoose.model(
  "ChatMessage",
  chatMessageSchema,
  "chat_messages"
);

// Connect to MongoDB
export async function connectToMongoDB() {
  try {
    if (connectionEstablished) return true;

    const mongoUri = await retrieveConfigValue("mongoDb.endpoint");
    const mongoUser = await retrieveConfigValue("mongoDb.user");
    const mongoPass = await retrieveConfigValue("mongoDb.password");
    const mongoDb =
      (await retrieveConfigValue("mongoDb.database")) || "enspira";

    // Build connection string with authentication if credentials exist
    let connectionString = mongoUri;
    if (mongoUser && mongoPass) {
      // Transform URI to include auth if not already formatted that way
      if (mongoUri.indexOf("@") === -1) {
        // Assuming mongoUri is in format: mongodb://host:port
        const uriParts = mongoUri.split("//");
        connectionString = `${uriParts[0]}//${mongoUser}:${encodeURIComponent(mongoPass)}@${uriParts[1]}`;
      }
    }

    // Add database name if not in the connection string
    if (connectionString.split("/").length <= 3) {
      connectionString = `${connectionString}/${mongoDb}`;
    }

    await mongoose.connect(connectionString, {
      serverSelectionTimeoutMS: 5000,
      connectTimeoutMS: 10000,
      socketTimeoutMS: 45000,
      maxPoolSize: 10,
    });

    connectionEstablished = true;
    logger.log("MongoDB", `Connected to MongoDB at ${mongoUri} successfully`);

    // Run migration if needed
    await migrateFromFileIfNeeded();

    // Set up cache cleanup interval
    setInterval(cleanupCache, 60000); // Check every minute

    return true;
  } catch (error) {
    logger.error("MongoDB", `Failed to connect to MongoDB: ${error.message}`);
    return false;
  }
}

function handleDisconnect() {
  if (connectionEstablished) {
    connectionEstablished = false;
    logger.error(
      "MongoDB",
      "Disconnected from database. Attempting to reconnect..."
    );

    // Attempt reconnection after a delay
    setTimeout(() => {
      connectToMongoDB().catch((err) => {
        logger.error("MongoDB", `Reconnection failed: ${err.message}`);
      });
    }, 5000);
  }
}

function handleConnectionError(err) {
  logger.error("MongoDB", `MongoDB connection error: ${err.message}`);

  if (connectionEstablished) {
    connectionEstablished = false;
    // Attempt reconnection will happen via the 'disconnected' event
  }
}

async function withCaching(key, fetchFn, options = {}) {
  const { ttl = 60000, forceFresh = false } = options;

  // Check cache first unless forceFresh is true
  if (!forceFresh && userCache.has(key)) {
    const cachedData = userCache.get(key);
    if (Date.now() < cachedData.expiry) {
      return cachedData.data;
    }
    userCache.delete(key);
  }

  // Try DB connection if needed
  if (!connectionEstablished) {
    const connected = await connectToMongoDB();
    if (!connected) {
      logger.error("MongoDB", `Cannot fetch data: Database not connected`);
      return null;
    }
  }

  // Fetch from database
  try {
    const data = await fetchFn();

    if (data) {
      // Cache for specified time
      userCache.set(key, {
        data,
        expiry: Date.now() + ttl,
        lastModified: Date.now(),
      });
    }

    return data;
  } catch (error) {
    logger.error("MongoDB", `Error fetching data for ${key}: ${error.message}`);
    return null;
  }
}

// Get user by ID with caching
export async function getUserById(userId) {
  try {
    return withCaching(userId, () => User.findOne({ user_id: userId }).lean());
  } catch (error) {
    logger.error("MongoDB", `Error fetching user ${userId}: ${error.message}`);
    return null;
  }
}

// Get all users
export async function getAllUsers() {
  try {
    if (!connectionEstablished) {
      // Try to connect if not already connected
      const connected = await connectToMongoDB();
      if (!connected) {
        logger.error("MongoDB", "Cannot get all users: Database not connected");
        return [];
      }
    }

    return await User.find({}).lean();
  } catch (error) {
    logger.error("MongoDB", `Error fetching all users: ${error.message}`);
    return [];
  }
}

// Update user data with path support
export async function updateUserData(userId, path, value) {
  try {
    if (!connectionEstablished) {
      // Try to connect if not already connected
      const connected = await connectToMongoDB();
      if (!connected) {
        logger.error(
          "MongoDB",
          `Cannot update user ${userId}: Database not connected`
        );
        return false;
      }
    }

    // Get the user from cache or DB
    let user = userCache.has(userId)
      ? userCache.get(userId).data
      : await getUserById(userId);

    if (!user) {
      logger.error("MongoDB", `Cannot update: User ${userId} not found`);
      return false;
    }

    // If path is empty, replace the entire object
    if (!path) {
      const result = await User.replaceOne({ user_id: userId }, value);

      if (result.modifiedCount > 0 || result.upsertedCount > 0) {
        // Update cache
        userCache.set(userId, {
          data: value,
          expiry: Date.now() + 60000,
          lastModified: Date.now(),
        });

        return true;
      }
      return false;
    }

    // Handle nested path updates
    const pathParts = path.split(".");
    let current = user;

    // Navigate to containing object
    for (let i = 0; i < pathParts.length - 1; i++) {
      const part = pathParts[i];

      if (current[part] === undefined) {
        current[part] = {};
      }

      current = current[part];
    }

    // Update the value
    const lastPart = pathParts[pathParts.length - 1];
    current[lastPart] = value;

    // Mark as dirty and update cache
    dirtyFlags.set(userId, true);
    userCache.set(userId, {
      data: user,
      expiry: Date.now() + 60000,
      lastModified: Date.now(),
    });

    // Write through for immediate persistence
    const updatePath = path ? { [`${path}`]: value } : user;
    await User.updateOne(
      { user_id: userId },
      { $set: updatePath },
      { upsert: true }
    );

    return true;
  } catch (error) {
    logger.error("MongoDB", `Error updating user ${userId}: ${error.message}`);
    return false;
  }
}

// Ensure path exists in user object
export async function ensureUserPath(userId, path) {
  try {
    if (!connectionEstablished) {
      // Try to connect if not already connected
      const connected = await connectToMongoDB();
      if (!connected) {
        logger.error(
          "MongoDB",
          `Cannot ensure path for user ${userId}: Database not connected`
        );
        return false;
      }
    }

    // Get the user
    let user = userCache.has(userId)
      ? userCache.get(userId).data
      : await getUserById(userId);

    if (!user) {
      logger.error("MongoDB", `Cannot ensure path: User ${userId} not found`);
      return false;
    }

    // Split the path into parts
    const pathParts = path.split(".");
    let current = user;
    let updateNeeded = false;

    // Create path objects as needed
    for (let i = 0; i < pathParts.length; i++) {
      const part = pathParts[i];

      if (!current[part]) {
        current[part] = {};
        updateNeeded = true;
      }

      current = current[part];
    }

    // Only update DB if we made changes
    if (updateNeeded) {
      // Update cache
      userCache.set(userId, {
        data: user,
        expiry: Date.now() + 60000,
        lastModified: Date.now(),
      });

      // Prepare update for database - we need to construct a $set operation for the path
      const setOperation = { $set: {} };
      setOperation.$set[path] = {};

      // Update database
      await User.updateOne({ user_id: userId }, setOperation, { upsert: true });
    }

    return true;
  } catch (error) {
    logger.error(
      "MongoDB",
      `Error ensuring path for user ${userId}: ${error.message}`
    );
    return false;
  }
}

// Clean up cache and flush changes
async function cleanupCache() {
  const now = Date.now();
  const promises = [];

  for (const [userId, cacheEntry] of userCache.entries()) {
    // Check if expired
    if (now >= cacheEntry.expiry) {
      // If dirty, save before removing
      if (dirtyFlags.get(userId)) {
        promises.push(
          User.replaceOne({ user_id: userId }, cacheEntry.data, {
            upsert: true,
          })
            .then(() => {
              logger.log(
                "MongoDB",
                `Flushed changes for user ${userId} before cache expiry`
              );
              dirtyFlags.delete(userId);
            })
            .catch((error) => {
              logger.error(
                "MongoDB",
                `Error flushing changes for user ${userId}: ${error.message}`
              );
            })
        );
      }

      // Remove from cache after promise is added
      userCache.delete(userId);
    }
  }

  // Wait for all save operations to complete
  if (promises.length > 0) {
    await Promise.allSettled(promises);
  }
}

export async function createUser(userData) {
  try {
    if (!connectionEstablished) {
      // Try to connect if not already connected
      const connected = await connectToMongoDB();
      if (!connected) {
        logger.error("MongoDB", "Cannot create user: Database not connected");
        return null;
      }
    }

    // Ensure user_id exists
    if (!userData.user_id) {
      logger.error("MongoDB", "Cannot create user: Missing user_id field");
      return null;
    }

    // Check if user already exists
    const existingUser = await User.findOne({ user_id: userData.user_id });
    if (existingUser) {
      logger.error(
        "MongoDB",
        `User with ID ${userData.user_id} already exists`
      );
      return null;
    }

    // Create new user
    const newUser = new User(userData);
    const savedUser = await newUser.save();

    // Add to cache
    userCache.set(userData.user_id, {
      data: savedUser.toObject(),
      expiry: Date.now() + 60000,
      lastModified: Date.now(),
    });

    logger.log("MongoDB", `Created new user with ID ${userData.user_id}`);
    return savedUser.toObject();
  } catch (error) {
    logger.error("MongoDB", `Error creating user: ${error.message}`);
    return null;
  }
}

// Flush all pending changes
export async function flushAllChanges() {
  if (!connectionEstablished) {
    logger.error("MongoDB", "Cannot flush changes: Database not connected");
    return false;
  }

  const promises = [];

  for (const [userId, cacheEntry] of userCache.entries()) {
    if (dirtyFlags.get(userId)) {
      promises.push(
        User.replaceOne({ user_id: userId }, cacheEntry.data, { upsert: true })
          .then(() => {
            logger.log("MongoDB", `Flushed changes for user ${userId}`);
            dirtyFlags.delete(userId);
          })
          .catch((error) => {
            logger.error(
              "MongoDB",
              `Error flushing changes for user ${userId}: ${error.message}`
            );
          })
      );
    }
  }

  // Wait for all save operations to complete
  if (promises.length > 0) {
    try {
      await Promise.allSettled(promises);
      return true;
    } catch (error) {
      logger.error(
        "MongoDB",
        `Error during flush operations: ${error.message}`
      );
      return false;
    }
  }

  return true;
}

export async function storeChatMessage(
  userId,
  messageData,
  generateEmbedding = false
) {
  try {
    const messageId = crypto.randomBytes(16).toString("hex");

    // Check if this is an important message that needs semantic search
    const isImportant =
      generateEmbedding ||
      messageData.firstMessage ||
      messageData.mentionsCharacter;

    // Create the message document
    const chatMessage = new ChatMessage({
      user_id: userId,
      username: messageData.username,
      message: messageData.message,
      message_id: messageId,
      timestamp: new Date(),
      ai_response: messageData.aiResponse || null,
      is_important: isImportant,
      metadata: {
        firstMessage: messageData.firstMessage || false,
        mentionsCharacter: messageData.mentionsCharacter || false,
        emoteCount: messageData.emoteCount || 0,
      },
    });

    // Save to MongoDB first
    await chatMessage.save();

    // If important, also store in Milvus for semantic search
    if (isImportant) {
      try {
        // Create the summary text for embedding
        const formattedDate = new Date().toLocaleString();
        const summaryString = `On ${formattedDate}, ${messageData.username} said in ${userId}'s Twitch chat: "${messageData.message}". ${messageData.aiResponse ? `You responded by saying: ${messageData.aiResponse}` : ""}`;

        // Store in Milvus
        const embeddingId = await storeInMilvus(
          userId,
          summaryString,
          messageData
        );

        // Update MongoDB with reference to Milvus entry
        if (embeddingId) {
          await ChatMessage.updateOne(
            { message_id: messageId },
            { $set: { embedding_id: embeddingId } }
          );
        }
      } catch (milvusError) {
        logger.error(
          "Milvus",
          `Error storing embedding: ${milvusError.message}`
        );
        // Continue anyway - we still have the message in MongoDB
      }
    }

    return { success: true, message_id: messageId };
  } catch (error) {
    logger.error("MongoDB", `Error storing chat message: ${error.message}`);
    return { success: false, error: error.message };
  }
}

// Chat count - Get total number of messages without retrieving documents
export async function getChatCount(userId) {
  try {
    const numChats = await ChatMessage.countDocuments({ user_id: userId });
    logger.log("Mongo", `Getting ${numChats} for ${userId}`);
  } catch (error) {
    logger.error("MongoDB", `Error counting chats: ${error.message}`);
    return 0;
  }
}

// Get recent chats with pagination
export async function getRecentChats(userId, limit = 25, skip = 0) {
  try {
    const messages = await ChatMessage.find({ user_id: userId })
      .sort({ timestamp: -1 })
      .skip(skip)
      .limit(limit)
      .lean();

    // Format for compatibility with existing code
    return messages.map((msg) => ({
      username: msg.username,
      raw_msg: msg.message,
      text_content: `${msg.username} sent the following message: ${msg.message}`,
      ai_message: msg.ai_response || "",
      time_stamp: new Date(msg.timestamp).getTime(),
    }));
  } catch (error) {
    logger.error("MongoDB", `Error fetching recent chats: ${error.message}`);
    return [];
  }
}

// Find relevant chat context (our hybrid implementation)
export async function findRelevantChatContext(
  userId,
  message,
  username,
  limit = 10,
  options = {}
) {
  const { useVectors = true, simpleTextSearch = true } = options;

  try {
    // Start with MongoDB text search (fast)
    let relevantMessages = [];

    if (simpleTextSearch) {
      // Use MongoDB text search for keyword matching
      relevantMessages = await ChatMessage.find(
        {
          user_id: userId,
          $text: { $search: message },
        },
        {
          score: { $meta: "textScore" },
        }
      )
        .sort({ score: { $meta: "textScore" } })
        .limit(limit)
        .lean();

      // Format for compatibility with existing code
      relevantMessages = relevantMessages.map((msg) => ({
        username: msg.username,
        raw_msg: msg.message,
        text_content: `${msg.username} sent the following message: ${msg.message}`,
        ai_message: msg.ai_response || "",
        time_stamp: new Date(msg.timestamp).getTime(),
      }));
    }

    // If we didn't find enough with text search and vectors are enabled, try Milvus
    if (useVectors && relevantMessages.length < Math.ceil(limit / 2)) {
      try {
        // Import the vector search function
        const { findRelevantChats } = await import("./ai-logic.js");

        // Use Milvus for semantic search
        const milvusResults = await findRelevantChats(
          message,
          username,
          userId,
          limit
        );

        // If we got Milvus results, either use them exclusively or merge
        if (milvusResults && milvusResults.length > 0) {
          if (relevantMessages.length === 0) {
            // Just use Milvus results if MongoDB found nothing
            return milvusResults;
          } else {
            // Merge results, prioritizing Milvus for semantic richness
            // Use a Map to deduplicate by filtering on raw_msg
            const messageMap = new Map();

            // Add Milvus results first (priority)
            milvusResults.forEach((msg) => {
              messageMap.set(msg.raw_msg, msg);
            });

            // Add MongoDB results if not already present
            relevantMessages.forEach((msg) => {
              if (!messageMap.has(msg.raw_msg)) {
                messageMap.set(msg.raw_msg, msg);
              }
            });

            // Convert back to array and limit to requested size
            return Array.from(messageMap.values()).slice(0, limit);
          }
        }
      } catch (milvusError) {
        logger.error("Chat", `Milvus search error: ${milvusError.message}`);
        // Continue with MongoDB results if Milvus fails
      }
    }

    return relevantMessages;
  } catch (error) {
    logger.error("Chat", `Error finding relevant context: ${error.message}`);
    return [];
  }
}

export async function checkDatabaseHealth() {
  try {
    if (!connectionEstablished) {
      // Try connecting
      const connected = await connectToMongoDB();
      if (!connected) {
        return { connected: false, error: "Failed to connect to database" };
      }
    }

    // Run a simple query to test connection
    await User.findOne({}).select("user_id").lean();

    return {
      connected: true,
      pendingWrites: dirtyFlags.size,
      cachedUsers: userCache.size,
      status:
        mongoose.connection.readyState === 1 ? "connected" : "disconnected",
    };
  } catch (error) {
    return {
      connected: false,
      error: error.message,
      status: mongoose.connection.readyState,
    };
  }
}

// Disconnect from MongoDB
export async function disconnect() {
  try {
    // Flush any pending changes
    await flushAllChanges();

    // Clear intervals
    clearInterval(cleanupCache);

    // Disconnect
    await mongoose.disconnect();
    connectionEstablished = false;
    logger.log("MongoDB", "Disconnected from MongoDB");
    return true;
  } catch (error) {
    logger.error(
      "MongoDB",
      `Error disconnecting from MongoDB: ${error.message}`
    );
    return false;
  }
}

process.on("SIGTERM", async () => {
  logger.log("MongoDB", "SIGTERM received, flushing changes and disconnecting");
  await flushAllChanges();
  await mongoose.disconnect();
});

process.on("SIGINT", async () => {
  logger.log("MongoDB", "SIGINT received, flushing changes and disconnecting");
  await flushAllChanges();
  await mongoose.disconnect();
});
</file>

<file path="token-helper.js">
import fs from "fs";
import path from "path";
import { Tokenizer } from "tokenizers";
import axios, { AxiosHeaders } from "axios";
import { retrieveConfigValue } from "./config-helper.js";

const tokenizerJsons = {};
const tokenizerInstances = {}; // Cache for Tokenizer instances

export const preloadAllTokenizers = () => {
  const resourcesPath = "./resources";
  const modelDirectories = fs
    .readdirSync(resourcesPath)
    .filter((file) =>
      fs.statSync(path.join(resourcesPath, file)).isDirectory(),
    );
  for (const modelDir of modelDirectories) {
    const tokenizerFilePath = path.join(resourcesPath, modelDir, "tokenizer.json");
    if (fs.existsSync(tokenizerFilePath)) {
      try {
        const tokenizerContent = fs.readFileSync(tokenizerFilePath, "utf-8");
        tokenizerJsons[modelDir] = tokenizerContent;
      } catch (error) {
        logger.log("Tokenizer", `Failed to load tokenizer for model ${modelDir}: ${error.message}`, "err");
      }
    } else {
      logger.log("Tokenizer", `Tokenizer file not found for model: ${modelDir}`, "err");
    }
  }
  logger.log("Tokenizer", `Loaded tokenizers: ${Object.keys(tokenizerJsons).join(", ")}`);
};

export const getTokenizerInstance = async (model) => {
  if (tokenizerInstances[model]) {
    return tokenizerInstances[model];
  }
  const tokenizerJson = tokenizerJsons[model];
  if (!tokenizerJson) {
    logger.log("Tokenizer", `Tokenizer JSON not found for model: ${model}`, "err");
    return null;
  }
  try {
    const instance = await Tokenizer.fromString(tokenizerJson);
    tokenizerInstances[model] = instance;
    return instance;
  } catch (error) {
    logger.log("Tokenizer", `Error creating tokenizer for model ${model}: ${error.message}`, "err");
    return null;
  }
};


export const getTokenizerJson = async (model) => tokenizerJsons[model];

export const getPromptCount = async (
  systemPrompt,
  userPrompt,
  modelType,
  contextPrompt = "",
) => {
  const tokenizerJson = await getTokenizerJson(modelType);
  if (!tokenizerJson) {
    logger.log(
      "Tokenizer",
      `Tokenizer not found for model type: ${modelType}`,
      "err",
    );
  }
  try {
    const tokenizer = await Tokenizer.fromString(tokenizerJson);

    const systemEncoded = await tokenizer.encode(JSON.stringify(systemPrompt));
    const userEncoded = await tokenizer.encode(JSON.stringify(userPrompt));
    const contextEncoded = contextPrompt
      ? await tokenizer.encode(JSON.stringify(contextPrompt))
      : { getLength: () => 0 };
    const tokenCount =
      systemEncoded.getLength() +
      userEncoded.getLength() +
      contextEncoded.getLength();
    return tokenCount;
  } catch (error) {
    logger.log(
      "error",
      `Error during tokenization for model ${modelType}: ${error.message}`,
    );
  }
};

export const getPromptTokens = async (
  requestBody,
  modelType
) => {
  const tokenizerJson = await getTokenizerJson(modelType);
  if (!tokenizerJson) {
    logger.log(
      "Tokenizer",
      `Tokenizer not found for model type: ${modelType}`,
      "err",
    );
  }
  try {
    const tokenizer = await Tokenizer.fromString(tokenizerJson);

    let totalTokens = 0
    for await (const message of requestBody.messages) {
      const messageContent = await tokenizer.encode(message.content)
      totalTokens += messageContent.getLength()
    }
    return totalTokens;
  } catch (error) {
    logger.log(
      "error",
      `Error during tokenization for model ${modelType}: ${error.message}`,
    );
  }
};

export const getOutputTokens = async (
  message,
  modelType
) => {
  const tokenizerJson = await getTokenizerJson(modelType);
  if (!tokenizerJson) {
    logger.log(
      "Tokenizer",
      `Tokenizer not found for model type: ${modelType}`,
      "err",
    );
  }
  try {
    const tokenizer = await Tokenizer.fromString(tokenizerJson);
    let totalTokens = 0
    const messageContent = await tokenizer.encode(message)
    totalTokens += messageContent.getLength()
    return totalTokens;
  } catch (error) {
    logger.log(
      "error",
      `Error during tokenization for model ${modelType}: ${error.message}`,
    );
  }
};

export const tokenizedFromRemote = async (message) => {
  const tokenizerUrl = await retrieveConfigValue("models.chat.endpoint") + "/tokenize"
  const modelName = await retrieveConfigValue("models.chat.model")
  try {
    const response = await axios.post(tokenizerUrl,
      {
        model: `${modelName}`,
        prompt: `${message}`
      },
      { 
        headers: {
          'Content-Type': 'application/json',
          'Accept-Encoding': 'gzip, deflate, br'
        },
      }
    )
    return response.data.count;
  } catch (error) {
    logger.log(
      "error",
      `Error during tokenization for model ${await retrieveConfigValue("models.chat.model")}: ${error.message}`,
    );
  }
}

export const promptTokenizedFromRemote = async (message) => {
  const baseURL = await retrieveConfigValue("models.chat.endpoint")
  const isVllm = await retrieveConfigValue("models.chat.isVllm")
  const modelName = await retrieveConfigValue("models.chat.model")
  let fullUrl = ""
  let reqBody = {}
  if (isVllm) {
    fullUrl = baseURL + "/tokenize"
    fullUrl = fullUrl.replace("/v1", "")
    reqBody = {
      messages: message,
      model: modelName
    }
  } else {
    fullUrl = baseURL + "/tokenize"
    reqBody = {
      messages: message,
      model: modelName
    }  
  }

  try {
    const response = await axios.post(fullUrl,
      reqBody,
      { 
        headers: {
          'Content-Type': 'application/json',
          'Accept-Encoding': 'gzip, deflate, br'
        },
      }
    )
    return response.data.count;
  } catch (error) {
    logger.log(
      "error",
      `Error during tokenization for model ${await retrieveConfigValue("models.chat.model")}: ${error.message}`,
    );
  }
}
</file>

<file path="auth/auth_keys.example.json">
[
  {
    "display_name": "Player Name",
    "email": "player@player.com",
    "user_id": "player1",
    "user_name": "Player",
    "twitch_name": "Player_TTV",
    "socials": {
      "ttv": "Player_TTV",
      "tt": "Player_TT",
      "yt": "Player YT"
    },
    "commands_list": [
      "!discord",
      "!socials",
      "!specs",
      "!changegame",
      "!changetitle"
    ],
    "tts_enabled": true,
    "bot_twitch": "@AiTwitchHandle",
    "speaker_file": "voice_path/",
    "rvc_model": "RVC_MODEL/RVC_Model.pth",
    "rvc_pitch": "0",
    "bot_name": "AiBot",
    "role": "ADMIN",
    "api_token": "",
    "api_token_type": "Bearer",
    "is_local": true,
    "latitude": "",
    "longitude": "",
    "timeZone": "",
    "lastIp": "",
    "weather": true,
    "max_chats": 40,
    "ttsEqPref": "",
    "ttsUpsamplePref": false,
    "twitch_tokens": {
      "bot": {
        "access_token": "",
        "refresh_token": "",
        "expires_at": 0
      },
      "streamer": {
        "access_token": "",
        "refresh_token": "",
        "expires_at": 0
      }
    },
    "current_game": {
      "online": false,
      "updated_at": ""
    },
    "fishTTSVoice": "",
    "current_followers": 0,
    "current_viewers": 0,
    "stream_status": {
      "online": false,
      "updated_at": ""
    },
    "webPasswordHash": "",
    "webPasswordSalt": "",
    "useFishTTS": false
  }
]
</file>

<file path="audio-processor.js">
// ffmpeg-processor.js - Fixed version with proper promise handling
import fs from 'fs-extra';
import path from 'path';
import { execFileSync } from 'child_process';
import { logger } from './create-global-logger.js';

/**
 * Processes audio using ffmpeg in a way that maximizes performance
 * @param {string} inputFilePath - Path to the input WAV file
 * @param {Object} options - Processing options
 * @returns {string} - Path to the processed file (synchronous return)
 */
export function processAudio(inputFilePath, options = {}) {
    const {
        enhanceVocals = true,
        outputDir = 'final',
        preset = 'clarity',
        userId = 'null'
    } = options;

    try {
        // Prepare paths
        const outputDirectory = path.resolve(process.cwd(), outputDir);
        const inputFileName = path.basename(inputFilePath, path.extname(inputFilePath));
        const outputFileName = `${userId}_${inputFileName}.wav`;
        const outputFilePath = path.join(outputDirectory, outputFileName);
        
        // Ensure output directory exists
        fs.ensureDirSync(outputDirectory);
        
        // Get filter string based on preset
        const filterString = enhanceVocals ? getPresetFilters(preset).join(',') : '';
        
        // Create the ffmpeg command
        const ffmpegCommand = `ffmpeg -y -i "${inputFilePath}" -af "${filterString}" -ar 48000 -ac 1 -codec:a pcm_s24le -threads 4 "${outputFilePath}"`;
        
        // Log the command
        logger.debug("Audio", `Executing command: ${ffmpegCommand}`);
        
        // Execute ffmpeg command synchronously
        execFileSync("ffmpeg", ["-nostdin", "-y", "-i", inputFilePath, "-af", filterString, "-ac", "1", "-threads", "8", outputFilePath], {
            stdio: ['ignore'] // Capture stderr only for errors
        });
        
        // Check that the output file exists
        if (!fs.existsSync(outputFilePath)) {
            throw new Error(`Output file was not created: ${outputFilePath}`);
        }
        
        logger.log("Audio", `Successfully processed audio to ${outputFilePath}`);
        return `/${outputFileName}`;
    } catch (error) {
        logger.error("Audio", `Error processing audio: ${error.message}`);
        throw error; // Re-throw to let caller handle it
    }
}

/**
 * Process multiple audio files in sequence
 * @param {Array<string>} inputFiles - Array of input file paths
 * @param {Object} options - Processing options
 * @returns {Array<string>} - Array of processed file paths
 */
export function batchProcessAudio(inputFiles, options = {}) {
    const results = [];
    for (const file of inputFiles) {
        const outputPath = processAudio(file, options);
        results.push(outputPath);
    }
    return results;
}

/**
 * Gets audio filters for the specified preset
 * @param {string} preset - Name of the preset
 * @returns {Array} - Array of filter strings
 */
function getPresetFilters(preset) {
    const basePresets = {
        clarity: [
            'highpass=f=150',
            'lowpass=f=11000',
            'equalizer=f=250:width_type=o:width=1:g=0.5',
            'equalizer=f=2500:width_type=o:width=1:g=1.5',
            'equalizer=f=4000:width_type=q:width=20:g=-2',
            'equalizer=f=6000:width_type=o:width=1:g=-1',
            'compand=0.2|0.3:1|1:-90/-60|-60/-40|-40/-30|-20/-20:6:0:-90:0.2',
            'loudnorm=I=-16:TP=-1.5:LRA=11'
        ],
        warmVocal: [
            'highpass=f=100',
            'lowpass=f=11000',
            'equalizer=f=200:width_type=o:width=1:g=2',
            'equalizer=f=600:width_type=o:width=1:g=1',
            'equalizer=f=3000:width_type=o:width=1.5:g=1',
            'equalizer=f=4000:width_type=q:width=20:g=-2',
            'compand=0.2|0.3:1|1:-90/-60|-60/-40|-40/-30|-20/-15:5:0:-90:0.3',
            'loudnorm=I=-16:TP=-1.5:LRA=10'
        ],
        brightVocal: [
            'highpass=f=130',
            'lowpass=f=12000',
            'equalizer=f=3000:width_type=o:width=1:g=2',
            'equalizer=f=4000:width_type=q:width=20:g=-2',
            'equalizer=f=6000:width_type=o:width=1:g=0.5',
            'equalizer=f=200:width_type=o:width=1:g=-1',
            'compand=0.1|0.2:1|1:-90/-60|-60/-40|-40/-30|-20/-15:5:0:-90:0.1',
            'loudnorm=I=-14:TP=-1.5:LRA=6'
        ],
        smoothVocal: [
            'highpass=f=80',
            'lowpass=f=11000',
            'highshelf=f=6000:g=-6',
            'equalizer=f=2000:width_type=o:width=1:g=1',
            'equalizer=f=4000:width_type=q:width=20:g=-2',
            'compand=0.3|0.5:1|1:-90/-60|-60/-40|-40/-30|-20/-15:4:0:-90:0.5',
            'loudnorm=I=-16:TP=-1.5:LRA=11'
        ],
        richVocal: [
            'highpass=f=70',
            'lowpass=f=11000',
            'equalizer=f=120:width_type=o:width=1.5:g=3',
            'equalizer=f=250:width_type=o:width=1.5:g=2.5',
            'equalizer=f=400:width_type=o:width=1:g=1.5',
            'equalizer=f=800:width_type=q:width=4:g=-0.5',
            'equalizer=f=2500:width_type=o:width=1:g=1',
            'equalizer=f=4000:width_type=q:width=20:g=-2',
            'compand=0.2|0.3:1|1:-90/-60|-60/-40|-40/-30|-20/-18:5:0:-90:0.3',
            'loudnorm=I=-16:TP=-1.5:LRA=10'
        ],
        broadcastSound: [
            'highpass=f=140',
            'lowpass=f=11000',
            'equalizer=f=120:width_type=o:width=1.5:g=3',
            'equalizer=f=250:width_type=o:width=1.5:g=2.5',
            'equalizer=f=500:width_type=o:width=1:g=1',
            'equalizer=f=800:width_type=o:width=1:g=-1',
            'equalizer=f=3000:width_type=o:width=1:g=2',
            'equalizer=f=4000:width_type=q:width=20:g=-2',
            'equalizer=f=6000:width_type=o:width=1:g=1',
            'compand=0.1|0.2:1|1:-90/-60|-60/-40|-40/-30|-30/-20|-20/-10:4:0:-90:0.2',
            'volume=1.0',
            'alimiter=limit=0.9:attack=5:release=20',
            'loudnorm=I=-14:TP=-1:LRA=8',
        ],
        femaleVocal: [
            'highpass=f=150',
            'lowpass=f=12000',
            'equalizer=f=200:width_type=o:width=1.5:g=1.5',
            'equalizer=f=400:width_type=o:width=1:g=1',
            'equalizer=f=1200:width_type=o:width=1:g=-1',
            'equalizer=f=2500:width_type=o:width=1:g=1.5',
            'equalizer=f=4000:width_type=q:width=20:g=-2',
            'equalizer=f=5000:width_type=o:width=1:g=1',
            'highshelf=f=8000:g=-2',
            'compand=0.2|0.4:1|1:-90/-60|-60/-40|-40/-30|-20/-18:4:0:-90:0.4',
            'loudnorm=I=-16:TP=-1.5:LRA=9',
            'adeclick=window=55:overlap=75:arorder=8:threshold=2:burst=2:method=add'
        ],
        deepBass: [
            'highpass=f=50',
            'lowpass=f=11000',
            'equalizer=f=80:width_type=o:width=1.2:g=4',
            'equalizer=f=200:width_type=o:width=1:g=2',
            'equalizer=f=500:width_type=q:width=4:g=-2',
            'equalizer=f=4000:width_type=q:width=20:g=-2',
            'compand=0.3|0.5:1|1:-90/-70|-70/-50|-50/-30|-20/-15:5:0:-90:0.3',
            'loudnorm=I=-17:TP=-2:LRA=12'
        ],
        telephone: [
            'highpass=f=300',
            'lowpass=f=3400',
            'equalizer=f=1000:width_type=o:width=0.7:g=4',
            'compand=0.1|0.1:1|1:-90/-40|-40/-20|-20/-10|-10/-5:3:0:-90:0.1',
            'loudnorm=I=-14:TP=-3:LRA=5'
        ],
        presenceBoost: [
            'highpass=f=150',
            'lowpass=f=11000',
            'equalizer=f=200:width_type=o:width=1:g=-1',
            'equalizer=f=2500:width_type=o:width=1.5:g=3',
            'equalizer=f=4000:width_type=q:width=20:g=-3',
            'equalizer=f=6000:width_type=o:width=1:g=2',
            'compand=0.1|0.2:1|1:-90/-60|-60/-40|-40/-30|-20/-15:6:0:-90:0.1',
            'loudnorm=I=-15:TP=-1.5:LRA=7'
        ],
        deBoom: [
            'highpass=f=100',
            'lowpass=f=11000',
            'equalizer=f=150:width_type=q:width=5:g=-4',
            'equalizer=f=300:width_type=q:width=4:g=-2',
            'equalizer=f=2500:width_type=o:width=1:g=1',
            'equalizer=f=4000:width_type=q:width=20:g=-2',
            'compand=0.2|0.3:1|1:-90/-60|-60/-40|-40/-30|-20/-18:6:0:-90:0.2',
            'loudnorm=I=-16:TP=-1.5:LRA=10'
        ],
        gentleCurve: [
            'highpass=f=100',
            'lowpass=f=11000',
            'equalizer=f=100:width_type=o:width=1.5:g=1',
            'equalizer=f=500:width_type=q:width=3:g=-1',
            'equalizer=f=3000:width_type=o:width=1.2:g=1',
            'equalizer=f=4000:width_type=q:width=20:g=-1',
            'compand=0.3|0.5:1|1:-90/-65|-65/-45|-45/-30|-20/-15:6:0:-90:0.3',
            'loudnorm=I=-16:TP=-1.5:LRA=11'
        ],
        thinToFull: [
            'highpass=f=85',
            'lowpass=f=11000',
            'equalizer=f=180:width_type=o:width=1.5:g=3',
            'equalizer=f=350:width_type=o:width=1.2:g=2',
            'equalizer=f=2800:width_type=o:width=1:g=1',
            'equalizer=f=4000:width_type=q:width=20:g=-2.5',
            'compand=0.2|0.4:1|1:-90/-60|-60/-40|-40/-30|-20/-17:5:0:-90:0.2',
            'loudnorm=I=-16.5:TP=-1.8:LRA=10'
        ]
    };
    
    return basePresets[preset] || basePresets.clarity;
}

/**
 * Cleans up files older than a specified number of days in a directory
 * @param {string} directory - Directory to clean up
 * @param {number} days - Delete files older than this many days (default: 5)
 * @return {Promise<number>} - Number of files deleted
 */
export async function cleanupOldFiles(directory, days = 5) {
    try {
        const now = Date.now();
        const cutoffTime = now - (days * 24 * 60 * 60 * 1000);

        const files = await fs.readdir(directory);
        let deletedCount = 0;

        for (const file of files) {
            const filePath = path.join(directory, file);

            try {
                const stats = await fs.stat(filePath);

                if (stats.isFile() && stats.ctimeMs < cutoffTime) {
                    await fs.unlink(filePath);
                    deletedCount++;
                }
            } catch (fileError) {
                logger.error("Audio", `Error processing file ${filePath}: ${fileError.message}`);
            }
        }

        return deletedCount;
    } catch (error) {
        logger.error("Audio", `Error cleaning up directory ${directory}: ${error.message}`);
        return 0;
    }
}

/**
 * Schedule automatic cleanup of a directory at regular intervals
 * @param {string} directory - Directory to clean up
 * @param {number} days - Delete files older than this many days (default: 5)
 * @param {number} intervalHours - How often to run cleanup in hours (default: 24)
 * @return {Object} - Timer object that can be cleared with clearInterval()
 */
export function scheduleCleanup(directory, days = 5, intervalHours = 24) {
    fs.mkdir(directory, { recursive: true })
        .catch(err => logger.error("Audio", `Error creating directory ${directory}: ${err.message}`));

    // Run cleanup immediately
    cleanupOldFiles(directory, days)
        .then(count => {
            if (count > 0) {
                logger.log("Audio", `Cleaned up ${count} old files from ${directory}`);
            }
        })
        .catch(err => logger.error("Audio", `Error in cleanup: ${err.message}`));

    const intervalMs = intervalHours * 60 * 60 * 1000;
    const timer = setInterval(() => {
        cleanupOldFiles(directory, days)
            .then(count => {
                if (count > 0) {
                    logger.log("Audio", `Cleaned up ${count} old files from ${directory}`);
                }
            })
            .catch(err => logger.error("Audio", `Error in scheduled cleanup: ${err.message}`));
    }, intervalMs);

    return timer;
}
</file>

<file path="data-helper.js">
import axios from "axios";
import {
  inferSearchParam,
  searchSearXNG,
  retrieveWebContext,
  rerankString,
} from "./ai-logic.js";
import fs from "fs-extra";
import { Readability } from "@mozilla/readability";
import { join } from "path";
import * as cheerio from 'cheerio';
import { JSDOM } from "jsdom";
import { retrieveConfigValue } from './config-helper.js'

const userAgentStrings = [
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.2227.0 Safari/537.36",
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.6 Safari/605.1.1",
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36 Edg/131.0.0.",
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36 Herring/97.1.8280.8"
];

/**
 * A structured error response for web RAG operations
 * @param {string} stage - The stage where the error occurred (e.g., 'search', 'retrieval')
 * @param {string} message - Human-readable error message
 * @param {object} [details] - Additional error details
 * @returns {object} - Structured error object
 */
export function createRagError(stage, message, details = null) {
  return {
    success: false,
    error: true,
    stage: stage,
    message: message,
    details: details,
    timestamp: new Date().toISOString()
  };
}

/**
 * Maintains a history of voice messages in a text file, adding new lines
 * and removing old ones to keep the file within a specified size limit.
 *
 * @param {string} newLine - The new line to add to the voice message history.
 * @returns {Promise<void>}
 */
async function maintainVoiceContext(newLine) {
  try {
    const chatContextPath = join(process.cwd(), "/world_info/voice_messages.txt");

    await fs.ensureFile(chatContextPath); // Ensures the file exists

    const currentContent = await fs.readFile(chatContextPath, "utf-8");
    const currentLines = currentContent.split("\n").filter(Boolean);

    currentLines.push("- " + newLine);

    // Remove oldest lines if the number of lines exceeds the limit
    while (currentLines.length > await retrieveConfigValue("twitch.maxChatsToSave")) {
      currentLines.shift();
    }

    await fs.writeFile(chatContextPath, currentLines.join("\n") + "\n");
  } catch (error) {
    logger.log("Voice Context", `Error maintaining voice context: ${error}`);
  }
}

/**
 * Reranks and filters a list of text contents based on their relevance to a given message.
 *
 * @param {Array} contextBody - An array of objects, each containing either 'text_content' or 'summary'.
 * @param {string} message - The message used for ranking relevance.
 * @param {string} userId - The ID of the user.
 * @param {boolean} requiresSearch - Indicates if a web search should be attempted if reranking results are poor.
 * @returns {Promise<string>} - A concatenated string of relevant content, or a default message if no relevant content is found.
 */
export async function resultsReranked(
  contextBody,
  message,
  userId,
  requiresSearch = false,
  cotReturn = false
) {
  try {
    if (!contextBody || !message) {
      logger.log("Embedding", "Missing contextBody or message parameter");
      return "- No additional information to provide.\n";
    }

    // Case 1: No documents at all - trigger web search immediately if allowed
    if (contextBody.length === 0) {
      logger.log("Embedding", "No context body provided for reranking.");
      
      if (requiresSearch) {
        logger.log("Embedding", "Attempting web search for additional context (no documents found)");
        const webResults = await startWebResults(message, userId);
        
        if (webResults && webResults.error) {
          if (webResults.optedOut) {
            return "- No additional context available for this query.\n";
          }
          logger.log("Search", `Web search failed: ${webResults.message}`);
          return "- Unable to find relevant information for this query.\n";
        }
        
        if (webResults) {
          return cotReturn ? [webResults] : webResults;
        }
        
        return "- No additional context provided for this section.";
      } else {
        return "- No additional context provided for this section.";
      }
    }
    
    // Process the documents for reranking
    let resultsRaw = [];
    let resultsTitle = [];
    
    if (!contextBody[0].relation) {
      resultsRaw = contextBody
        .map((item) => item.text_content || item.summary)
        .filter(Boolean);
      resultsTitle = contextBody
        .map((item) => item.relation)
        .filter(Boolean);
    } else {
      resultsRaw = contextBody
        .map((item) => item.text_content || item.summary)
        .filter(Boolean);
    }

    if (resultsRaw.length === 0) {
      logger.log("Embedding", "No valid content found in context body.");
      
      // Case 2: No valid content in documents - trigger web search if allowed
      if (requiresSearch) {
        logger.log("Embedding", "Attempting web search for additional context (no valid content)");
        const webResults = await startWebResults(message, userId);
        
        if (webResults && !webResults.error) {
          return cotReturn ? [webResults] : webResults;
        }
      }
      
      return "- No additional information to provide.\n";
    }

    // Get optimized query for reranking
    logger.log("Embedding", "Asking rerank helper to optimize...");
    let rerankOptimized = await rerankString(message, userId);
    
    if (rerankOptimized && rerankOptimized.error) {
      logger.log("Embedding", `Error optimizing rerank query: ${rerankOptimized.message}`);
      rerankOptimized = message;
    }

    // Perform the reranking
    const rerankData = {
      model: await retrieveConfigValue("models.rerank.model"),
      query: rerankOptimized,
      documents: resultsRaw,
      top_k: contextBody.length
    };

    logger.log("Embedding", `Starting rerank...`);
    
    try {
      const response = await axios.post(`${await retrieveConfigValue("models.rerank.endpoint")}/rerank`, rerankData, {
        headers: {
          "Content-Type": "application/json",
          "Accept-Encoding": "gzip, deflate, br",
          Connection: "keep-alive",
          Authorization: `Bearer ${await retrieveConfigValue("models.rerank.apiKey")}`
        },
        timeout: 10000,
      });

      logger.log("Embedding", `Rerank finished. Sorting results.`);
      const rerankedArray = response.data;

      // ADJUSTED RELEVANCE THRESHOLDS FOR LOGIT SCORES (-10 to 10 range)
      const HIGH_RELEVANCE_THRESHOLD = 6.0;    // Very high relevance (was 0.7)
      const ACCEPTABLE_THRESHOLD = 4.5;        // Good relevance (was 0.5)
      const LOW_RELEVANCE_THRESHOLD = 1.4;     // Low but possibly useful (new)
      
      // Count documents in each relevance category
      const highRelevanceCount = rerankedArray.filter(item => item.score >= HIGH_RELEVANCE_THRESHOLD).length;
      const acceptableCount = rerankedArray.filter(item => item.score >= ACCEPTABLE_THRESHOLD).length;
      const lowRelevanceCount = rerankedArray.filter(item => item.score < ACCEPTABLE_THRESHOLD).length;
      
      // Calculate average relevance of top 5 results
      const avgTopRelevance = rerankedArray
        .slice(0, 5)
        .reduce((sum, item) => sum + item.score, 0) / Math.min(5, rerankedArray.length);
      
      logger.log("Embedding", `Relevance stats - High (>=${HIGH_RELEVANCE_THRESHOLD}): ${highRelevanceCount}, ` +
        `Acceptable (>=${ACCEPTABLE_THRESHOLD}): ${acceptableCount}, Low: ${lowRelevanceCount}, ` +
        `Avg Top 5: ${avgTopRelevance.toFixed(2)}`);
      
      // Filter results based on the new acceptable threshold (5.0)
      let rerankProcessed = rerankedArray
        .filter(item => item.score >= ACCEPTABLE_THRESHOLD)
        .map(item => resultsRaw[parseInt(item.index)]);

      // If we have less than 3 acceptable results, include some lower-scoring ones
      if (rerankProcessed.length < 3) {
        logger.log("Embedding", `Not enough results above threshold ${ACCEPTABLE_THRESHOLD}. Including lower-scoring results.`);
        
        // Get additional items that didn't meet the acceptable threshold, but still have some relevance
        const additionalItems = rerankedArray
          .filter(item => item.score >= LOW_RELEVANCE_THRESHOLD && item.relevance_score < ACCEPTABLE_THRESHOLD)
          .map(item => resultsRaw[parseInt(item.index)]);
        
        // Add them to our processed results
        rerankProcessed = rerankProcessed.concat(additionalItems);
        
        // If we still don't have enough, just take the top 5
        if (rerankProcessed.length < 3) {
          rerankProcessed = rerankedArray
            .slice(0, 5)
            .map(item => resultsRaw[parseInt(item.index)]);
        }
      }

      // Trigger web search if ANY of these conditions are met:
      const shouldSearchWeb = requiresSearch && (
        // 1. We have fewer than 2 high-quality documents  
        highRelevanceCount < 2 || 
        // 2. Average top 5 score is below 6.0 (moderately relevant)
        avgTopRelevance < 6.0 ||
        // 3. More than 60% of results are below our acceptable threshold
        (lowRelevanceCount > 0 && lowRelevanceCount / rerankedArray.length > 0.6)
      );
      
      if (shouldSearchWeb) {
        logger.log(
          "Embedding", 
          `Attempting web search for additional context. Relevance too low: ` +
          `High: ${highRelevanceCount}, Avg: ${avgTopRelevance.toFixed(2)}, ` + 
          `Low Ratio: ${(lowRelevanceCount / rerankedArray.length).toFixed(2)}`
        );
        
        const augmentResult = await startWebResults(message, userId);
        
        if (augmentResult && augmentResult.error) {
          logger.log("Embedding", `Web search failed: ${augmentResult.message}`);
        } else if (augmentResult) {
          logger.log("Embedding", "Web search returned additional context, adding to results");
          rerankProcessed.push(augmentResult);
        }
      } else if (requiresSearch) {
        logger.log(
          "Embedding", 
          `Skipping web search - sufficient document quality. ` +
          `High: ${highRelevanceCount}, Acceptable: ${acceptableCount}, Avg: ${avgTopRelevance.toFixed(2)}`
        );
      }
      
      if (cotReturn) {
        return rerankProcessed;
      } else {
        return rerankProcessed.join("\n");
      }
    } catch (rerankError) {
      logger.log("Embedding", `Error during reranking: ${rerankError.message}`);
      
      // If reranking fails and search is allowed, try web search as fallback
      if (requiresSearch) {
        logger.log("Embedding", "Falling back to web search due to rerank failure");
        try {
          const webResults = await startWebResults(message, userId);
          if (webResults && !webResults.error) {
            return cotReturn ? [webResults] : webResults;
          }
        } catch (webError) {
          logger.log("Embedding", `Web search fallback also failed: ${webError.message}`);
        }
      }
      
      // Last resort: return the raw results limited to 5
      if (resultsRaw.length > 0) {
        const limitedResults = resultsRaw.slice(0, 5);
        return cotReturn ? limitedResults : limitedResults.join("\n");
      }
      
      return "- Error processing information. Using available context.\n";
    }
  } catch (error) {
    logger.log("Embedding", `Error in resultsReranked: ${error.stack}`);
    return createRagError('reranking', error.message, { stack: error.stack });
  }
}

export async function axiosRequestWithRetry(config, attempts = 3, initialDelay = 1000) {
  let delay = initialDelay;
  for (let i = 0; i < attempts; i++) {
    try {
      return await axios(config);
    } catch (error) {
      if (i === attempts - 1) {
        throw error;
      }
      await new Promise(resolve => setTimeout(resolve, delay));
      delay *= 2; // Exponential backoff
    }
  }
}

/**
 * Initiates a web search process for a given message and user ID.
 * It uses the message to infer a search query, performs a Brave search,
 * and then retrieves web context based on the search results.
 *
 * @param {string} message - The message to initiate the web search for.
 * @param {string} userId - The ID of the user performing the search.
 * @returns {Promise<string>} - The result of the web context retrieval, or an empty string if no query is inferred.
 */
export async function startWebResults(message, userId) {
  const queryResult = await inferSearchParam(message, userId);

  // Handle structured error from inferSearchParam
  if (!queryResult.success) {
    if (queryResult.optedOut) {
      logger.log("LLM", `Search opted out: ${queryResult.reason}`);
      return { 
        success: false, 
        optedOut: true, 
        reason: queryResult.reason,
        noSearchNeeded: true 
      };
    }
    
    logger.log("LLM", `Search parameter inference failed: ${queryResult.message}`);
    return queryResult; // Return the error object
  }

  try {
    const pmWebSearch = await searchSearXNG(queryResult.searchTerm, queryResult.freshness);
    
    // Check if searchSearXNG returned an error object
    if (pmWebSearch && pmWebSearch.error) {
      return pmWebSearch; // Already a properly formatted error
    }
    
    if (!pmWebSearch || pmWebSearch.length === 0) {
      return createRagError(
        'search-execution', 
        'No search results found',
        { searchTerm: queryResult.searchTerm, freshness: queryResult.freshness }
      );
    }
    
    logger.log("LLM", `Starting web search for '${queryResult.searchTerm}'`);
    const searchedResults = await retrieveWebContext(
      pmWebSearch,
      queryResult.searchTerm,
      queryResult.subject,
      userId
    );

    // Check if retrieveWebContext returned an error
    if (searchedResults && searchedResults.error) {
      return searchedResults;
    }

    return searchedResults || createRagError(
      'context-retrieval',
      'Failed to retrieve context from search results',
      { searchResults: pmWebSearch.length }
    );
  } catch (error) {
    logger.log("LLM", `Error in web search process: ${error.message}`);
    return createRagError('web-search', error.message, { stack: error.stack });
  }
}

/**
 * Classifies the emotions present in a given message using a specified classification model.
 * It sends the message to an embedding endpoint for classification and returns the ranked emotions.
 *
 * @param {string} message - The message to classify emotions from.
 * @returns {Promise<string>} - A string describing the ranked emotions in the message.
 */
const interpretEmotions = async (message) => {
  try {
    const classifyBody = {
      model: await retrieveConfigValue("models.classifier.model"),
      input: [message],
    };
    const response = await axios.post(`${await retrieveConfigValue("models.classifier.endpoint")}/classify`, classifyBody);
    const results = response.data.data[0];
    let emotionsResult = getEmotionRanking(results);
    return emotionsResult;
  } catch (error) {
    logger.log("Emotion", `Error in interpretEmotions: ${error}`);
    return "Error interpreting emotions.";
  }
};

/**
 * Pulls content from multiple web pages using Cheerio, parses, and cleans it.
 *
 * @param {Array} urls - An array of objects, each containing a URL to process.
 * @param {string} subject - The subject matter related to the URLs.
 * @returns {Promise<string>} - A concatenated string of cleaned content from all URLs, or an empty string if no content is found.
 */
const pullFromWeb = async (urls, subject) => {
  if (!urls || urls.length === 0) {
    logger.log("Augment", "No URLs provided for content extraction.");
    return "";
  }

  const fetchPromises = urls.map(async (link, index) => {
    try {
      const response = await axios.get(link.url, {
        headers: {
          "User-Agent":
            userAgentStrings[
            Math.floor(Math.random() * userAgentStrings.length)
            ],
        },
        timeout: 10000,
      });

      const $ = cheerio.load(response.data);

      // Remove script and style tags
      $("script, style").remove();

      // Get the HTML content after removing script and style tags
      const htmlContent = $.html();

      // Use Readability to extract the main content
      const document = new JSDOM(htmlContent); // Use JSDOM here
      const reader = new Readability(document.window.document);
      const article = reader.parse();

      if (!article) {
        logger.log("Augment", `Could not parse content from "${link.url}".`);
        return "";
      }

      const cleanContent = cleanContentWithNewlines(article.textContent);
      let content = "";

      if (index === 0) {
        content += `# Start of documents related to the subject "${subject}"`;
        content += `\n\n## From the web page "${link.source}", :\n\n${cleanContent}`;
      } else if (index === urls.length - 1) {
        content += `\n\n## From the web page "${link.url}", titled "${link.title}":\n\n${cleanContent}`;
        content += `\n\n# End of documents`;
      } else {
        content += `\n\n## From the web page "${link.url}" in regards to the subject matter "${subject}":\n\n${cleanContent}`;
      }

      return content;
    } catch (error) {
      logger.log("Augment", `Error processing URL "${link.url}": ${error}`);
      return "";
    }
  });

  const contents = await Promise.all(fetchPromises);
  const pageContentText = contents.filter(Boolean).join("\n\n");

  return pageContentText;
};

/**
 * Pulls content from multiple web pages using the scraper service
 * @param {Array} urls - Array of URL objects
 * @param {string} subject - The subject related to the URLs
 * @returns {Promise<string|object>} - Concatenated content or error object
 */
export async function pullFromWebScraper(urls, subject) {
  if (!urls || urls.length === 0) {
    return createRagError('scraping', 'No URLs provided for content extraction');
  }
  
  try {
    const fetchPromises = urls.map(async (link) => {
      try {
        const url = new URL(`${await retrieveConfigValue("server.externalScraper.endpoint")}/api/article`);
        url.searchParams.set("cache", await retrieveConfigValue("server.externalScraper.caching"));
        url.searchParams.set("resource", "document");
        url.searchParams.set("device", await retrieveConfigValue("server.externalScraper.deviceType"));
        url.searchParams.set("url", link.url);
        url.searchParams.set("format", "json");

        const response = await axios.get(url.toString(), { timeout: 15000 });
        
        // Check if the response has the expected structure
        if (!response.data || typeof response.data !== 'object') {
          logger.log("Augment", `Invalid response format for URL ${link.url}`);
          return "";
        }
        
        // Check for textContent property specifically
        if (!response.data.textContent || typeof response.data.textContent !== 'string') {
          logger.log("Augment", `No text content found for URL ${link.url}`);
          return "";
        }
        
        return `## From the web page "${link.source}", titled "${link.title}":\n\n${response.data.textContent}`;
      } catch (error) {
        logger.log("Augment", `Error processing URL "${link.url}": ${error.message}`);
        return ""; // Return empty string on error to be filtered later
      }
    });

    const contents = await Promise.all(fetchPromises);
    const validContents = contents.filter(Boolean);
    
    if (validContents.length === 0) {
      return createRagError(
        'scraping-results', 
        'No valid content extracted from any URL',
        { urlsAttempted: urls.length }
      );
    }

    // Construct the final page content text
    let pageContentText = `# Start of documents related to the subject "${subject}"\n\n`;
    pageContentText += validContents.join("\n\n");
    pageContentText += `\n\n# End of documents related to the subject "${subject}"`;

    return pageContentText;
  } catch (error) {
    logger.log("Augment", `Error in web scraping: ${error.message}`);
    return createRagError('scraping-execution', error.message);
  }
}

/**
 * Cleans a given text content by removing extra spaces and normalizing newlines.
 *
 * @param {string} content - The text content to clean.
 * @returns {string} - The cleaned text content.
 */
function cleanContentWithNewlines(content) {
  return content
    .replace(/\s+/g, " ")
    .replace(/(?:\s*\n\s*)+/g, "\n")
    .trim();
}

/**
 * Generates a description of the emotional tone conveyed in a message based on emotion classification results.
 *
 * @param {Array} emotions - An array of emotion objects, each with a 'label' and 'score'.
 * @returns {string} - A description of the emotional tone.
 */
const getEmotionRanking = (emotions) => {
  const getModifier = (score) => {
    if (score <= 0.33) {
      return "a bit of";
    } else if (score <= 0.66) {
      return "quite a bit of";
    } else {
      return "a lot of";
    }
  };

  const getEmotionDescription = (label) => {
    switch (label) {
      case "curious":
        return "a quizzical and curious vibe";
      case "surprise":
        return "shock and awe";
      case "think":
        return "curiosity";
      case "cheeky":
        return "cheeky banter";
      case "grumpy":
        return "a grumpy vibe";
      case "whiny":
        return "a whiny tone";
      case "empathetic":
        return "a sense of compassion";
      case "guilty":
        return "regret";
      case "anger":
        return "a heated emotion";
      case "disgust":
        return "a disgusted tone";
      case "impatient":
        return "frustration";
      case "energetic":
        return "an electrifying energy";
      case "joy":
        return "an uplifting and vibrant energy";
      case "serious":
        return "a stone-cold serious vibe";
      case "neutral":
        return "a lack of emotional energy";
      case "fear":
        return "a reserved or tense mood";
      case "love":
        return "a heartfelt or warm sentiment";
      case "confuse":
        return "a puzzled demeanor";
      case "suspicious":
        return "a doubtful tone";
      case "sadness":
        return "melancholy";
      default:
        return "an undefined or mixed feeling";
    }
  };

  const topEmotions = emotions.sort((a, b) => b.score - a.score).slice(0, 3);

  const messageParts = topEmotions.map(({ label, score }) => {
    const modifier = getModifier(score);
    const description = getEmotionDescription(label);
    return `${modifier} ${description}`;
  });

  const formattedMessage =
    messageParts.length > 1
      ? `${messageParts.slice(0, -1).join(", ")}, and ${messageParts.slice(-1)}`
      : messageParts[0];

  return `You feel that this message gives off ${formattedMessage}.`;
};

export {
  interpretEmotions,
  maintainVoiceContext,
  pullFromWeb,
};
</file>

<file path="oai-requests.js">
import { retrieveConfigValue } from "./config-helper.js";

export class ChatRequestBody {
  constructor(promptData) {
    this.messages = [
      // System message with core instructions
      {
        role: "system",
        content: promptData.systemPrompt
      }
    ];

    // Add each context component as a separate user message
    if (promptData.characterDescription) {
      this.messages.push({
        role: "user",
        content: promptData.characterDescription
      });
    }

    if (promptData.characterPersonality) {
      this.messages.push({
        role: "user",
        content: promptData.characterPersonality
      });
    }

    if (promptData.worldInfo) {
      this.messages.push({
        role: "user",
        content: promptData.worldInfo
      });
    }

    if (promptData.scenario) {
      this.messages.push({
        role: "user",
        content: promptData.scenario
      });
    }

    if (promptData.playerInfo) {
      this.messages.push({
        role: "user",
        content: promptData.playerInfo
      });
    }

    if (promptData.recentChat) {
      this.messages.push({
        role: "user",
        content: promptData.recentChat
      });
    }

    if (promptData.weatherInfo) {
      this.messages.push({
        role: "user",
        content: promptData.weatherInfo
      });
    }

    // Add additional context elements if they exist
    if (promptData.additionalContext) {
      Object.entries(promptData.additionalContext).forEach(([key, value]) => {
        if (value && value.trim()) {
          this.messages.push({
            role: "user",
            content: value
          });
        }
      });
    }

    // Add assistant acknowledgment
    this.messages.push({
      role: "assistant",
      content: "I understand. I'll keep the provided rules, character information, and provided context in mind when responding to the next user message."
    });

    // Add the actual user query
    this.messages.push({
      role: "user",
      content: promptData.userMessage
    });

    // Set streaming to true by default
    this.stream = true;
  }

  // Static factory method for async initialization
  static async create(promptData) {
    const instance = new ChatRequestBody(promptData);
    await instance.initialize();
    return instance;
  }

  // Handle async initialization
  async initialize() {
    // Load all configuration values in parallel for better performance
    const [
      model,
      topK,
      minP,
      xtcThreshold,
      xtcProbability,
      topP,
      typicalP,
      minTokens,
      repetitionPenalty,
      presencePenalty,
      repetitionRange,
      presenceRange,
      temperature,
      dynTempMax,
      dynTempMin,
      dynTemp,
      maxTokens,
      generateWindow
    ] = await Promise.all([
      retrieveConfigValue("models.chat.model"),
      retrieveConfigValue("samplers.chat.topK"),
      retrieveConfigValue("samplers.chat.minP"),
      retrieveConfigValue("samplers.chat.xtcThreshold"),
      retrieveConfigValue("samplers.chat.xtcProbability"),
      retrieveConfigValue("samplers.chat.topP"),
      retrieveConfigValue("samplers.chat.typicalP"),
      retrieveConfigValue("samplers.chat.minTokens"),
      retrieveConfigValue("samplers.chat.repetitionPenalty"),
      retrieveConfigValue("samplers.chat.presencePenalty"),
      retrieveConfigValue("samplers.chat.repetitionRange"),
      retrieveConfigValue("samplers.chat.presenceRange"),
      retrieveConfigValue("samplers.chat.temperature"),
      retrieveConfigValue("samplers.chat.dynTempMin"),
      retrieveConfigValue("samplers.chat.dynTempMax"),
      retrieveConfigValue("samplers.chat.dynTemp"),
      retrieveConfigValue('samplers.chat.maxTokens'),
      retrieveConfigValue('samplers.chat.generateWindow')
    ]);

    // Assign values to this instance
    this.model = model;
    this.top_k = parseInt(topK);
    this.min_p = parseFloat(minP);
    this.xtc_threshold = parseFloat(xtcThreshold);
    this.xtc_probability = parseFloat(xtcProbability);
    this.top_p = parseFloat(topP);
    this.typical_p = parseFloat(typicalP);
    this.min_tokens = parseInt(minTokens);
    this.repetition_penalty = parseFloat(repetitionPenalty);
    this.presence_penalty = parseFloat(presencePenalty);
    this.repetition_range = parseInt(repetitionRange);
    this.presence_range = parseInt(presenceRange);
    this.temperature = parseFloat(temperature);
    this.max_tokens = parseInt(maxTokens);
    this.generate_window = parseInt(generateWindow);
    // Add dynamic temperature settings if enabled
    if (dynTemp) {
      this.dynatemp = dynTemp;
      this.dynatemp_min = parseFloat(dynTempMin);
      this.dynatemp_max = parseFloat(dynTempMax);
    }
  }
}

export class ChatRequestBodyCoT {
  constructor(promptData) {
    // Initialize with the system prompt
    this.messages = [
      {
        role: "system",
        content: promptData.systemPrompt
      }
    ];

    // Add each context component as a separate user message
    if (promptData.characterDescription) {
      this.messages.push({
        role: "user",
        content: promptData.characterDescription
      });
    }

    if (promptData.characterPersonality) {
      this.messages.push({
        role: "user",
        content: promptData.characterPersonality
      });
    }

    if (promptData.worldInfo) {
      this.messages.push({
        role: "user",
        content: promptData.worldInfo
      });
    }

    if (promptData.scenario) {
      this.messages.push({
        role: "user",
        content: promptData.scenario
      });
    }

    if (promptData.playerInfo) {
      this.messages.push({
        role: "user",
        content: promptData.playerInfo
      });
    }

    if (promptData.recentChat) {
      this.messages.push({
        role: "user",
        content: promptData.recentChat
      });
    }

    if (promptData.weatherInfo) {
      this.messages.push({
        role: "user",
        content: promptData.weatherInfo
      });
    }

    // Add additional context elements if they exist
    if (promptData.additionalContext) {
      Object.entries(promptData.additionalContext).forEach(([key, value]) => {
        if (value && value.trim()) {
          this.messages.push({
            role: "user",
            content: value
          });
        }
      });
    }

    // Add assistant acknowledgment
    this.messages.push({
      role: "assistant",
      content: "I understand all given instructions and who I am now. I'll ensure I think deeply but concisely about the message and respond according to my thoughts."
    });

    // Add the actual user query
    this.messages.push({
      role: "user",
      content: promptData.userMessage
    });

    // Set streaming to true by default
    this.stream = true;

    // Define the JSON response format for chain-of-thought
    this.response_format = {
      type: "json_schema",
      json_schema: {
        name: "thoughtful_response",
        schema: {
          type: "object",
          properties: {
            thoughts: {
              type: "array",
              items: {
                type: "string",
                description: "One brief thought about the user's message. Keep each thought under 250 words maximum."
              },
              maxItems: 6,
              description: "A short list of key thoughts that capture your reasoning process."
            },
            final_response: {
              type: "string",
              description: "Your final response to the user, optimized for Twitch chat. Keep it under 500 characters when possible."
            }
          },
          required: ["thoughts", "final_response"],
          additionalProperties: false
        },
        strict: true
      }
    };
  }

  // Static factory method for async initialization
  static async create(promptData) {
    const instance = new ChatRequestBodyCoT(promptData);
    await instance.initialize();
    return instance;
  }

  // Handle async initialization
  async initialize() {
    // Load all configuration values in parallel for better performance
    const [
      model,
      maxTokens,
      generateWindow,
      topK,
      minP,
      xtcThreshold,
      xtcProbability,
      topP,
      typicalP,
      minTokens,
      repetitionPenalty,
      presencePenalty,
      repetitionRange,
      presenceRange,
      temperature,
      dynTemp,
      dynTempMin,
      dynTempMax
    ] = await Promise.all([
      retrieveConfigValue("models.chat.model"),
      retrieveConfigValue("samplers.chat.maxTokens"),
      retrieveConfigValue("samplers.chat.generateWindow"),
      retrieveConfigValue("samplers.chat.topK"),
      retrieveConfigValue("samplers.chat.minP"),
      retrieveConfigValue("samplers.chat.xtcThreshold"),
      retrieveConfigValue("samplers.chat.xtcProbability"),
      retrieveConfigValue("samplers.chat.topP"),
      retrieveConfigValue("samplers.chat.typicalP"),
      retrieveConfigValue("samplers.chat.minTokens"),
      retrieveConfigValue("samplers.chat.repetitionPenalty"),
      retrieveConfigValue("samplers.chat.presencePenalty"),
      retrieveConfigValue("samplers.chat.repetitionRange"),
      retrieveConfigValue("samplers.chat.presenceRange"),
      retrieveConfigValue("samplers.chat.temperature"),
      retrieveConfigValue("samplers.chat.dynTemp"),
      retrieveConfigValue("samplers.chat.dynTempMin"),
      retrieveConfigValue("samplers.chat.dynTempMax")
    ]);

    // Assign and parse all configuration values
    this.model = model;
    this.max_tokens = parseInt(maxTokens);
    this.generate_window = parseInt(generateWindow);
    this.top_k = parseInt(topK);
    this.min_p = parseFloat(minP);
    this.xtc_threshold = parseFloat(xtcThreshold);
    this.xtc_probability = parseFloat(xtcProbability);
    this.top_p = parseFloat(topP);
    this.typical_p = parseFloat(typicalP);
    this.min_tokens = parseInt(minTokens);
    this.repetition_penalty = parseFloat(repetitionPenalty);
    this.presence_penalty = parseFloat(presencePenalty);
    this.repetition_range = parseInt(repetitionRange);
    this.presence_range = parseInt(presenceRange);
    this.temperature = parseFloat(temperature);
    
    // Add dynamic temperature settings if enabled
    if (dynTemp) {
      this.dynatemp = dynTemp;
      this.dynatemp_min = parseFloat(dynTempMin);
      this.dynatemp_max = parseFloat(dynTempMax);
    }
  }
}

export class ToolRequestBody {
  // Constructor handles synchronous initialization
  constructor(prompt, model, message) {
    // Initialize the basic message structure
    this.model = model;
    this.messages = [
      {
        role: "system",
        content: prompt,
      },
      {
        role: "user",
        content: message,
      },
    ];
  }

  // Static factory method provides a clean async interface
  static async create(prompt, model, message) {
    const instance = new ToolRequestBody(prompt, model, message);
    await instance.initialize();
    return instance;
  }

  // Private method handles all async initialization
  async initialize() {
    // Load all configuration values in parallel for better performance
    const [temperature, topP, topK, minP] = await Promise.all([
      retrieveConfigValue("samplers.tool.temperature"),
      retrieveConfigValue("samplers.tool.topP"),
      retrieveConfigValue("samplers.tool.topK"),
      retrieveConfigValue("samplers.tool.minP")
    ]);

    // Assign the parsed values to the instance
    this.temperature = parseFloat(temperature);
    this.top_p = parseFloat(topP);
    this.top_k = parseInt(topK);
    this.min_p = parseFloat(minP);
    this.stream = true;
  }
}

export class QueryRequestBody {
  // Constructor handles all synchronous initialization
  constructor(prompt, model, message) {
    // Set up the basic message structure
    this.model = model;
    this.messages = [
      {
        role: "system",
        content: prompt,
      },
      {
        role: "user",
        content: message,
      },
    ];

    // Initialize the JSON schema response format
    this.response_format = {
      type: "json_schema",
      json_schema: {
        name: "query_response",
        schema: {
          type: "object",
          properties: {
            valid: {
              type: "boolean",
              description: "Whether or not this is a Valid Inquiry for performing searches on. True for valid, False for invalid."
            },
            searchTerm: {
              type: "string",
              description: "The SEO-optimized search term related to the inquiry."
            },
            subject: {
              type: "string",
              description: "The inferred subject of the inquiry."
            },
            vectorString: {
              type: "string",
              description: "The vector similiarity search optimized string you have created."
            },
            freshness: {
              type: "string",
              description: "The freshness rating that applies to this search."
            },
            reason: {
              type: "string",
              description: "If query was deemed to be not valid, briefly and concisely explain why you determined the query was invalid. For valid queries, leave this empty."
            }
          },
          required: ["valid", "searchTerm", "subject", "vectorString", "freshness", "reason"],
          additionalProperties: false
        },
        strict: true
      }
    };
  }

  // Static factory method provides the async creation interface
  static async create(prompt, model, message) {
    const instance = new QueryRequestBody(prompt, model, message);
    await instance.initialize();
    return instance;
  }

  // Private method handles all async initialization
  async initialize() {
    // Load all configuration values in parallel for better performance
    const [
      temperature,
      topP,
      topK,
      minP,
      generateWindow,
      maxTokens
    ] = await Promise.all([
      retrieveConfigValue("samplers.tool.temperature"),
      retrieveConfigValue("samplers.tool.topP"),
      retrieveConfigValue("samplers.tool.topK"),
      retrieveConfigValue("samplers.tool.minP"),
      retrieveConfigValue("samplers.tool.generateWindow"),
      retrieveConfigValue("samplers.tool.maxTokens")
    ]);

    // Assign and parse all the configuration values
    this.temperature = parseFloat(temperature);
    this.top_p = parseFloat(topP);
    this.top_k = parseInt(topK);
    this.min_p = parseFloat(minP);
    this.generate_window = parseInt(generateWindow);
    this.max_tokens = parseInt(maxTokens);
    this.stream = true;
  }
}

export class ModerationRequestBody {
  // Constructor handles synchronous initialization of message structure and schema
  constructor(prompt, model, message) {
    // Initialize the basic messaging structure for moderation requests
    this.model = model;
    this.messages = [
      {
        role: "system",
        content: prompt,
      },
      {
        role: "user",
        content: message,
      },
    ];

    // Set up the JSON schema for moderation responses
    // This is static and defines the structure all moderation responses must follow
    this.response_format = {
      type: "json_schema",
      json_schema: {
        name: "moderator_response",
        schema: {
          type: "object",
          properties: {
            actionNeeded: {
              type: "boolean",
              description: "Whether the user's message is deemed safe (false) or needs to be actioned (true)."
            },
            actionType: {
              type: "string",
              description: "Whether or not the user's message requires a strike or a ban."
            },
            reason: {
              type: "string",
              description: "The reason for issuing the action to the user."
            },
          },
          required: ["actionNeeded", "actionType", "reason"],
          additionalProperties: false
        },
        strict: true
      }
    };
  }

  // Static factory method provides a clean async interface for creating instances
  static async create(prompt, model, message) {
    const instance = new ModerationRequestBody(prompt, model, message);
    await instance.initialize();
    return instance;
  }

  // Private method handles asynchronous initialization of configuration values
  async initialize() {
    // Load all configuration values in parallel using Promise.all for efficiency
    const [temperature, topP, topK, minP] = await Promise.all([
      retrieveConfigValue("samplers.tool.temperature"),
      retrieveConfigValue("samplers.tool.topP"),
      retrieveConfigValue("samplers.tool.topK"),
      retrieveConfigValue("samplers.tool.minP")
    ]);

    // Parse and assign the configuration values to the instance
    this.temperature = parseFloat(temperature);
    this.top_p = parseFloat(topP);
    this.top_k = parseInt(topK);
    this.min_p = parseFloat(minP);
    this.stream = true;
  }
}

export class SummaryRequestBody {
  // Constructor handles synchronous initialization of the core structure
  constructor(prompt, model, message) {
    // Set up the basic message structure that all requests need
    this.model = model;
    this.messages = [
      {
        role: "system",
        content: prompt,
      },
      {
        role: "user",
        content: message,
      },
    ];

    // Define the JSON schema that governs the format of summary responses
    // This schema ensures we get both a vector-optimized string and complete summary
    this.response_format = {
      type: "json_schema",
      json_schema: {
        name: "summary_response",
        schema: {
          type: "object",
          properties: {
            vectorString: {
              type: "string",
              description: "A single brief and concise sentence about what you've summarized, optimized for ease of retrieval in a vector similarity search."
            },
            summaryContents: {
              type: "string",
              description: "The complete contents of your summary."
            },
          },
          required: ["vectorString", "summaryContents"],
          additionalProperties: false
        },
        strict: true
      }
    };
  }

  // Static factory method creates a clean interface for async instantiation
  static async create(prompt, model, message) {
    const instance = new SummaryRequestBody(prompt, model, message);
    await instance.initialize();
    return instance;
  }

  // Private method handles all asynchronous configuration loading
  async initialize() {
    // Load all sampler configuration values in parallel for better performance
    // This reduces initialization time compared to sequential loading
    const [temperature, topP, topK, minP] = await Promise.all([
      retrieveConfigValue("samplers.tool.temperature"),
      retrieveConfigValue("samplers.tool.topP"),
      retrieveConfigValue("samplers.tool.topK"),
      retrieveConfigValue("samplers.tool.minP")
    ]);

    // Parse and assign the configuration values, ensuring proper type conversion
    this.temperature = parseFloat(temperature);
    this.top_p = parseFloat(topP);
    this.top_k = parseInt(topK);
    this.min_p = parseFloat(minP);
    this.stream = true;
  }
}

export class ConvertDocsRequestBody {
  constructor(prompt, model, message) {
    return (async () => {
      this.model = model;
      this.messages = [
        {
          role: "system",
          content: prompt,
        },
        {
          role: "user",
          content: message,
        },
      ];

      this.temperature = parseFloat(
        await retrieveConfigValue("samplers.tool.temperature"),
      );
      this.top_p = parseFloat(await retrieveConfigValue("samplers.tool.topP"));
      this.top_k = parseInt(await retrieveConfigValue("samplers.tool.topK"));
      this.min_p = parseFloat(await retrieveConfigValue("samplers.tool.minP"));
      this.response_format = {
        "type": "json_schema",
        "json_schema": {
          "name": "conversion_response",
          "schema": {
            "type": "object",
            "properties": {
              "vectorString": { "type": "string", "description": "A concisely written phrasing of the contents you've summarized, optimized for ease of retrieval in a vector similarity search." },
              "summaryContents": { "type": "string", "description": "The complete contents of the summary about the document." },
            },
            "required": ["vectorString", "summaryContents"],
            "additionalProperties": false
          },
          "strict": true
        }
      }
      return this;
    })();
  }
}
</file>

<file path="twitch-helper.js">
import fs from "fs-extra";
import { funFact, returnAuthObject } from "./api-helper.js";
import { sendChatCompletionRequest, moderatorPrompt } from "./prompt-helper.js";
import moment from "moment";
import { retrieveConfigValue } from './config-helper.js'
const lastFunFactTime = new Map();

/**
 * Returns a formatted string for a Twitch event based on its type.
 *
 * @param {object} eventThing - The event data.
 * @param {string} userId - The ID of the user associated with the event.
 * @returns {Promise<string>} - A formatted string describing the event.
 */
async function returnTwitchEvent(eventThing, userId) {
  const userObj = await returnAuthObject(userId);
  const event = {
    ...eventThing,
    playerName: userObj.user_name,
    playerId: userObj.user_id,
  };

  const eventTypeHandlers = {
    sub: subMessage,
    dono: donoMessage,
    chat: chatMessage,
    raid: raidMessage,
    follow: followMessage,
    hype_start: hypeStartMessage,
    hype_update: hypeUpdateMessage,
    hype_end: hypeEndMessage,
    hype_up: hypeLevelUpMessage,
    trivia: triviaMessage,
    ad: adMessage,
    summary: summaryMessage,
    shoutout: shoutoutMessage,
  };

  const handler = eventTypeHandlers[event.eventType];
  if (handler) {
    return await handler(event);
  } else {
  }
}

/**
 * Processes command-driven events from chat
 * @param {string} command - The command text 
 * @param {string} userId - The user ID
 * @returns {Promise<object>} - Event object if command is valid
 */
export async function processCommandEvent(command, userId) {
  if (command.startsWith('!summary')) {
    return {
      eventType: 'summary',
      eventData: {}
    };
  } else if (command.startsWith('!trivia')) {
    return {
      eventType: 'trivia',
      eventData: {}
    };
  }

  return null;
}

/**
 * Processes real-time chat messages from any source
 * @param {object} chatEvent - The chat event data
 * @param {string} userId - The user ID
 * @returns {Promise<object>} - The processing result
 */
export async function processChatMessage(chatEvent, userId) {
  try {
    // Normalize the chat message
    const normalizedChat = normalizeMessageFormat(chatEvent);
    
    // Get user data
    const user = await returnAuthObject(userId);
    
    // Skip messages from ignored bots
    const fromBot = await containsAuxBotName(normalizedChat.user, userId);
    if (fromBot) return { success: true, ignored: true, reason: "bot_user" };
    
    // Check if message is a command
    const isCommand = await isCommandMatch(normalizedChat.message, userId);
    if (isCommand) return { success: true, ignored: true, reason: "command" };
    
    // Check if message mentions the character
    const mentionsChar = await containsCharacterName(normalizedChat.message, userId);
    
    // Format date for context
    const formattedDate = new Date().toLocaleString();
    
    // Process first messages or character mentions
    if (normalizedChat.firstMessage || mentionsChar) {
      // Add message to vector storage
      const summaryString = `On ${formattedDate} ${normalizedChat.user} said in ${user.twitch_name}'s Twitch chat: "${normalizedChat.message}"`;
      
      // Store asynchronously
      addChatMessageAsVector(
        summaryString,
        normalizedChat.message,
        normalizedChat.user,
        formattedDate,
        "",
        userId
      ).catch(err => logger.error("Twitch", `Error storing chat vector: ${err.message}`));
      
      // Return data needed for response generation
      return {
        success: true,
        processed: true,
        mentioned: mentionsChar,
        firstMessage: normalizedChat.firstMessage,
        requiresResponse: mentionsChar || normalizedChat.firstMessage,
        messageData: {
          message: normalizedChat.message,
          user: normalizedChat.user
        }
      };
    }
    
    // For other messages, store if configured
    if (user.store_all_chat) {
      const summaryString = `On ${formattedDate} ${normalizedChat.user} said in ${user.twitch_name}'s Twitch chat: "${normalizedChat.message}"`;
      
      addChatMessageAsVector(
        summaryString,
        normalizedChat.message,
        normalizedChat.user,
        formattedDate,
        "",
        userId
      ).catch(err => logger.error("Twitch", `Error storing regular chat: ${err.message}`));
    }
    
    return {
      success: true,
      processed: false,
      requiresResponse: false
    };
  } catch (error) {
    logger.error("Twitch", `Error processing chat: ${error.message}`);
    return { success: false, error: error.message };
  }
}

/**
 * Calculates the time difference between a given date and the current time.
 *
 * @param {string} inputDate - The date string to compare with the current time.
 * @returns {string} - A string describing the time difference.
 */
const getTimeDifferenceFromNow = (inputDate) => {
  const format = "MM/DD/YYYY hh:mm:ss A";
  const momentDate = moment.utc(inputDate, format);
  const now = moment.utc();

  const diffInMinutes = momentDate.diff(now, "minutes");
  const absDiff = Math.abs(diffInMinutes);

  if (diffInMinutes > 0) {
    return `in ${absDiff < 60 ? `${absDiff} minute${absDiff === 1 ? "" : "s"}` : `${Math.round(absDiff / 60)} hour${Math.round(absDiff / 60) === 1 ? "" : "s"}`}`;
  } else {
    return `${absDiff < 60 ? `${absDiff} minute${absDiff === 1 ? "" : "s"}` : `${Math.round(absDiff / 60)} hour${Math.round(absDiff / 60) === 1 ? "" : "s"}`} ago`;
  }
};

const eventMessagesCache = {};

async function readEventMessages(playerId) {
  if (eventMessagesCache[playerId]) {
    return eventMessagesCache[playerId];
  }
  try {
    const filePath = `./world_info/${playerId}/event_messages.txt`;
    const fileContent = await fs.readFile(filePath, "utf-8");
    const parsed = JSON.parse(fileContent);
    eventMessagesCache[playerId] = parsed;
    return parsed;
  } catch (error) {
    logger.log("Files", `Error reading event messages for player ${playerId}: ${error}`);
    return {};
  }
}

/**
 * Normalizes chat messages from various sources into a standard format
 * @param {object} messageData - Raw message from EventSub or API
 * @returns {object} - Standardized chat object
 */
export function normalizeMessageFormat(messageData) {
  // From EventSub webhook
  if (messageData.chatter && messageData.message && messageData.message.text) {
    return {
      user: messageData.chatter.user_name,
      userId: messageData.chatter.user_id,
      message: messageData.message.text,
      firstMessage: messageData.message.is_first || false,
      badges: messageData.chatter.badges?.map(badge => badge.set_id) || [],
      emotes: messageData.message.fragments
        ?.filter(f => f.type === 'emote')
        .map(e => ({ id: e.id, code: e.text })) || [],
      emoteCount: messageData.message.fragments?.filter(f => f.type === 'emote').length || 0,
      color: messageData.color,
      source: 'eventsub'
    };
  }
  
  // From Enspira API
  return {
    user: messageData.user,
    userId: messageData.userId || null,
    message: messageData.message,
    firstMessage: messageData.firstMessage || false,
    badges: messageData.badges || [],
    emotes: messageData.emotes || [],
    emoteCount: messageData.emoteCount || 0,
    color: messageData.color || null,
    source: 'api'
  };
}

/**
 * Generates a formatted string for a subscription event.
 *
 * @param {object} event - The subscription event data.
 * @returns {Promise<string>} - A formatted string describing the subscription event.
 */
const subMessage = async (event) => {
  const parsedAddons = await readEventMessages(event.playerId);
  const subValues = {
    prime: "$4.99",
    "tier 1": "$4.99",
    "tier 2": "$9.99",
    "tier 3": "$24.99",
  };
  const subValNum = {
    prime: 4.99,
    "tier 1": 4.99,
    "tier 2": 9.99,
    "tier 3": 24.99,
  };
  let subString = "";

  switch (event.eventData.subType) {
    case "sub":
      subString += `${event.eventData.user} just gave ${event.playerName} a ${event.eventData.subTier} sub! They spent ${subValues[event.eventData.subTier]} to give them a subscription. `;
      subString += event.eventData.multiMonth
        ? `They also decided to subscribe for ${event.eventData.monthLength} months, and have been subscribed for ${event.eventData.tenure} months so far! `
        : "";
      subString += event.eventData.primeUpgrade
        ? `They upgraded from their Twitch Prime subscription right into being a ${event.eventData.subTier} subscriber, paying ${subValues[event.eventData.subTier]} to do so! `
        : "";
      subString += event.eventData.paidForward
        ? "They decided to pay their gifted subscription forward! "
        : "";
      subString += event.eventData.message
        ? `${event.eventData.user} said this in the Twitch chat afterward:\n${event.eventData.message}`
        : "";
      break;
    case "resub":
      subString += `${event.eventData.user} just decided to resubscribe to ${event.playerName}'s Twitch channel! They resubscribed with a ${event.eventData.subTier} sub! `;
      subString += `They spent ${subValues[event.eventData.subTier]} to resubscribe. They're on a ${event.eventData.streak} month streak and have been a subscriber for ${event.eventData.tenure} months. `;
      subString += `${event.eventData.user} said the following in the Twitch chat afterward:\n${event.eventData.sharedChat}`;
      break;
    case "gift_sub":
      if (event.eventData.anonymous) {
        subString += `Some generous person just gave ${event.eventData.recipientUserName} a ${event.eventData.subTier} sub to ${event.playerName}'s Twitch channel! `;
        subString += `They spent ${subValues[event.eventData.subTier]} to gift this sub. `;
      } else {
        subString += `${event.eventData.user} just gave ${event.eventData.recipientUserName} a ${event.eventData.subTier} sub to ${event.playerName}'s Twitch channel! They spent ${subValues[event.eventData.subTier]} to gift this sub. `;
      }
      subString += event.eventData.random
        ? `This sub was randomly given to ${event.eventData.recipientUserName}. `
        : `This sub was specifically given to ${event.eventData.recipientUserName}. `;
      subString += `They're on a ${event.eventData.streak} month streak with their own sub, and have been a subscriber for ${event.eventData.tenure} months so far. `;
      if (event.eventData.anonymous) {
        subString += `Though they wished to be anonymous, they said the following in the Twitch chat afterward:\n${event.eventData.message}`;
      } else {
        subString += `${event.eventData.user} said the following in the Twitch chat afterward:\n${event.eventData.message}`;
      }
      break;
    case "gift_bomb":
      if (event.eventData.anonymous) {
        subString += `Some generous person just gave out ${event.eventData.giftAmt} ${event.eventData.subTier} subs to ${event.playerName}'s channel! `;
        subString += event.eventData.sharedAmt
          ? `They spent $${(subValNum[event.eventData.subTier] * event.eventData.giftAmt).toFixed(2)} on these subs. `
          : `Each sub was worth ${subValNum[event.eventData.subTier]}. `;
      } else {
        subString += `${event.eventData.user} just gave out ${event.eventData.giftAmt} ${event.eventData.subTier} subs to ${event.playerName}'s channel! `;
        subString += event.eventData.sharedAmt
          ? `They spent $${(subValNum[event.eventData.subTier] * event.eventData.giftAmt).toFixed(2)} on these subs. `
          : `Each sub was worth ${subValNum[event.eventData.subTier]}. `;
      }
      subString +=
        event.eventData.bonusGifts > 0
          ? `Twitch themselves also decided to add subs towards ${event.playerName}'s channel too! `
          : "";
      subString += event.eventData.anonymous
        ? `They said this in the chat afterward:\n${event.eventData.systemMessage}`
        : `${event.eventData.user} said this in the chat afterward:\n${event.eventData.systemMessage}`;
      break;
    default:
      break;
  }
  subString += `\n${parsedAddons.sub.replace("{{user}}", event.playerName)}`;
  return subString;
};

/**
 * Generates a formatted string for a donation event.
 *
 * @param {object} event - The donation event data.
 * @returns {Promise<string>} - A formatted string describing the donation event.
 */
const donoMessage = async (event) => {
  const parsedAddons = await readEventMessages(event.playerId);
  let subString = "";
  switch (event.eventData.donoType) {
    case "tip":
      subString += `A donation for ${event.eventData.donoAmt} just came through from ${event.eventData.donoFrom}! `;
      break;
    case "charity":
      subString += `A donation towards our favorite charity ${event.eventData.forCharity} just came through, in the amount of $${event.eventData.donoAmt}! `;
      break;
    case "bits":
      subString += `${event.eventData.donoFrom} just donated ${event.eventData.donoAmt} bits to ${event.playerName}'s channel! While each one of these is only worth a cent, they do stack up! `;
    default:
      break;
  }
  subString +=
    event.eventData.donoType === "charity"
      ? `\n${parsedAddons.charity.replace("{{user}}", event.playerName)}`
      : `They said this in a message:\n${event.eventData.donoMessage}\n${parsedAddons.dono.replace(
        "{{user}}",
        event.playerName,
      )}`;
  return subString;
};

/**
 * Generates a formatted string for a raid event.
 *
 * @param {object} event - The raid event data.
 * @returns {Promise<string>} - A formatted string describing the raid event.
 */
const raidMessage = async (event) => {
  const parsedAddons = await readEventMessages(event.playerId);
  let subString = `${event.eventData.username} just raided ${event.playerName}'s Twitch channel! `;
  subString += `${event.eventData.username} has been streaming for ${event.eventData.accountAge} as well! `;
  subString += event.eventData.isFollowing
    ? `They are not currently a follower of ${event.playerName}'s channel. `
    : `They are a follower of ${event.playerName}'s channel! `;
  subString += `They were last seen playing the video game ${event.eventData.lastGame} to their viewers! `;
  subString += `Their raid brought along ${event.eventData.viewers} viewers with them, who will now be eagerly watching ${event.playerName} stream and game!\n`;
  subString += parsedAddons.raid.replace("{{user}}", event.playerName);
  return subString;
};

/**
 * Generates a formatted string for a follow event.
 *
 * @param {object} event - The follow event data.
 * @returns {Promise<string>} - A formatted string describing the follow event.
 */
const followMessage = async (event) => {
  const parsedAddons = await readEventMessages(event.playerId);
  return `${event.eventData.username} just followed ${event.playerName}'s Twitch channel!\n\n${parsedAddons.follow.replace("{{user}}", event.playerName)}`;
};

/**
 * Generates a formatted string for a summary message during a break in streaming.
 *
 * @param {object} event - The summary event data.
 * @returns {Promise<string>} - A formatted string summarizing the stream's events.
 */
const summaryMessage = async (event) => {
  return `${event.playerName} is taking a small break from streaming. While ${event.playerName}'s away from their keyboard, briefly summarize the events in the stream using only the previous chat interactions and any other Twitch events that occured. Do not imagine any other details about the live stream, only use the provided context. Be creative in your summary and put a creative spin on things, but avoid responding with more than 500 characters.`;
};

/**
 * Generates a formatted string for a chat message event.
 *
 * @param {object} event - The chat message event data.
 * @returns {Promise<string>} - A formatted string describing the chat message event.
 */
const chatMessage = async (event) => {
  const parsedAddons = await readEventMessages(event.playerId);
  let subString = `${event.user} sent the following message in ${event.playerName}'s Twitch chat:\n${event.message}`;
  subString += event.firstMessage
    ? `\nThis is ${event.user}'s *first ever* chat message in ${event.playerName}'s Twitch channel as well!`
    : "";
  subString += `\n${parsedAddons.firstchat.replace(
    "{{user}}",
    event.playerName,
  )}`;
  return subString;
};

/**
 * Generates a formatted string for a hype train start event.
 *
 * @param {object} event - The hype train start event data.
 * @returns {Promise<string>} - A formatted string describing the hype train start event.
 */
const hypeStartMessage = async (event) => {
  const parsedAddons = await readEventMessages(event.playerId);
  let subString = `A hype train on ${event.playerName}'s channel just started!\n`;
  subString += `It is currently at level ${event.eventData.level}, started ${getTimeDifferenceFromNow(
    event.eventData.startedAt,
  )}, and will expire ${getTimeDifferenceFromNow(event.eventData.expiresAt)}.\n`;
  subString += `We are ${event.eventData.percent * 100
    }% of the way to level ${parseInt(event.eventData.level) + 1}!\n`;
  subString += `${event.eventData.topSubUser} has the most gifted subscriptions at ${event.eventData.topSubTotal} subs, and ${event.eventData.topBitsUser} has donated the most bits with ${event.eventData.topBitsAmt} bits donated!`;
  subString += "\n" + parsedAddons.hype;
  return subString;
};

/**
 * Generates a formatted string for a hype train update event.
 *
 * @param {object} event - The hype train update event data.
 * @returns {Promise<string>} - A formatted string describing the hype train update event.
 */
const hypeUpdateMessage = async (event) => {
  const parsedAddons = await readEventMessages(event.playerId);
  let subString = `Here's an update on the Hype Train ${event.playerName}'s channel has started:\n`;
  subString += `It is currently at level ${event.eventData.level}, started ${getTimeDifferenceFromNow(
    event.eventData.startedAt,
  )}, and will expire ${getTimeDifferenceFromNow(event.eventData.expiresAt)}.\n`;
  subString += `There are ${event.eventData.contributors} contributors!\n`;
  subString += event.eventData.isGolden
    ? `This is now a Golden Kappa train, a rare event rewarding contributors with the Golden Kappa emote for 24 hours!\n`
    : "";
  subString += `We are ${event.eventData.percent * 100
    }% of the way to level ${parseInt(event.eventData.level) + 1}!\n`;
  subString += `${event.eventData.topSubUser} has the most gifted subscriptions at ${event.eventData.topSubTotal} subs, and ${event.eventData.topBitsUser} has donated the most bits with ${event.eventData.topBitsAmt} bits donated!`;
  subString += "\n" + parsedAddons.hype;
  return subString;
};

/**
 * Generates a formatted string for a hype train end event.
 *
 * @param {object} event - The hype train end event data.
 * @returns {Promise<string>} - A formatted string describing the hype train end event.
 */
const hypeEndMessage = async (event) => {
  const parsedAddons = await readEventMessages(event.playerId);
  let subString = `The Hype Train on ${event.playerName}'s channel has just ended!\n`;
  subString += `It ended at level ${event.eventData.level}, started ${getTimeDifferenceFromNow(
    event.eventData.startedAt,
  )}, and reached ${event.eventData.percent * 100
    }% towards level ${parseInt(event.eventData.level) + 1}.\n`;
  subString += `There were ${event.eventData.contributors} contributors! `;
  subString += event.eventData.isGolden
    ? `This was a Golden Kappa train, a rare event rewarding contributors with the Golden Kappa emote for 24 hours.\n`
    : "";
  subString += `${event.eventData.topSubUser} gifted the most subscriptions at ${event.eventData.topSubTotal} subs, and ${event.eventData.topBitsUser} donated the most bits with ${event.eventData.topBitsAmt} bits donated!`;
  subString += "\n" + parsedAddons.hype;
  return subString;
};

/**
 * Generates a formatted string for a hype train level up event.
 *
 * @param {object} event - The hype train level up event data.
 * @returns {Promise<string>} - A formatted string describing the hype train level up event.
 */
const hypeLevelUpMessage = async (event) => {
  const parsedAddons = await readEventMessages(event.playerId);
  let subString = `The hype train on ${event.playerName}'s channel has just leveled up!\n`;
  subString += `It is now at level ${event.eventData.level}, started ${getTimeDifferenceFromNow(
    event.eventData.startedAt,
  )}, and will expire ${getTimeDifferenceFromNow(event.eventData.expiresAt)}.\n`;
  subString += `There are ${event.eventData.contributors} contributors!\n`;
  subString += event.eventData.isGolden
    ? `This is now a Golden Kappa train, a rare event rewarding contributors with the Golden Kappa emote for 24 hours!\n`
    : "";
  subString += `We are ${event.eventData.percent * 100
    }% of the way to level ${parseInt(event.eventData.level) + 1}!\n`;
  subString += `${event.eventData.topSubUser} has the most gifted subscriptions at ${event.eventData.topSubTotal} subs, and ${event.eventData.topBitsUser} has donated the most bits with ${event.eventData.topBitsAmt} bits donated!`;
  subString += "\n" + parsedAddons.hype;
  return subString;
};

/**
 * Generates a formatted string for a trivia message event.
 *
 * @param {object} event - The trivia message event data.
 * @returns {Promise<string>} - A formatted string containing a fun fact.
 */
const triviaMessage = async (event) => {
  return `You're about to receive a fun fact to tell all of the viewers of ${event.playerName}'s channel. Share the entirety of this fact, and your thoughts about it, to all of the viewers. Here is the fun fact:\n${await funFact()}`;
};



/**
 * Generates a formatted string for a shoutout message event.
 *
 * @param {object} event - The shoutout message event data.
 * @returns {Promise<string>} - A formatted string describing the shoutout event.
 */
const shoutoutMessage = async (event) => {
  let subString = `${event.playerName} wants you to give ${event.eventData.user} a shoutout in their Twitch channel! Here is some information regarding ${event.eventData.user} to consider when shouting them out!\n`;
  subString += `${event.eventData.user} started their streaming career ${getTimeDifferenceFromNow(
    event.eventData.accountAge,
  )}!\n`;
  subString += `The last time ${event.eventData.user} was live, they were streaming ${event.eventData.game} for their viewers! `;
  subString += `${event.eventData.user} was last active ${getTimeDifferenceFromNow(
    event.eventData.lastActive,
  )} on their channel! The title of their last stream was '${event.eventData.streamTitle
    }'. `;
  subString += event.eventData.isMod
    ? `They are also a moderator in ${event.playerName}'s Twitch channel!\n`
    : "";
  subString += event.eventData.isAffiliate
    ? `They are also a Twitch affiliate!\n`
    : "";
  subString += event.eventData.isPartner
    ? `They are also an official Twitch partner!\n`
    : "";
  subString += event.eventData.isSubbed
    ? `They are also currently subscribed to ${event.playerName}'s Twitch channel!\n`
    : "";
  subString += `Make sure you give ${event.eventData.user} the type of hype-up you can only get from ${event.playerName}'s Twitch channel!`;
  return subString;
};

/**
 * Generates a formatted string for an ad message event.
 *
 * @param {object} event - The ad message event data.
 * @returns {Promise<string>} - A formatted string describing the ad event.
 */
const adMessage = async (event) => {
  return `Give a heads up to the viewers of ${event.playerName}'s channel that ads will be coming in ${event.minutesLeft} minutes. Playfully hint towards avoiding the ads by subscribing to ${event.playerName}'s channel, and how much it would mean to you.`;
};

/**
 * Retrieves and formats social media information for a user.
 * Enhanced to better support template variables and specific platform requests.
 *
 * @param {string} userId - The ID of the user.
 * @param {string} [platform] - If provided, returns information for a specific platform.
 * @returns {Promise<string|object>} - A formatted string, specific platform value, or object containing social media information.
 */
async function socialMedias(userId, platform = "") {
  try {
    const currentUser = await returnAuthObject(userId);
    
    if (!currentUser?.socials) {
      return platform ? "" : "";
    }
    
    // Return all social media as an object if requested
    if (platform === "all") {
      return { ...currentUser.socials };
    }

    // Normalize platform name and return specific value if requested
    const normalizedPlatform = normalizePlatformName(platform);
    if (normalizedPlatform) {
      return currentUser.socials[normalizedPlatform] || "";
    }

    // Format all available platforms for template use
    return Object.entries(currentUser.socials)
      .filter(([_, value]) => value?.trim())
      .map(([key, value]) => formatSocialMediaValue(key, value))
      .filter(Boolean)
      .join(", ")
      ? `(${Object.entries(currentUser.socials)
          .filter(([_, value]) => value?.trim())
          .map(([key, value]) => formatSocialMediaValue(key, value))
          .filter(Boolean)
          .join(", ")})`
      : "";
  } catch (error) {
    logger.log("System", `Error retrieving social media: ${error.message}`);
    return platform ? "" : "";
  }
}

/**
 * Normalizes platform names to consistent keys.
 * 
 * @param {string} platform - The platform identifier to normalize.
 * @returns {string} - The normalized platform key.
 */
function normalizePlatformName(platform) {
  if (!platform) return "";
  
  const platformMap = {
    // TikTok variations
    "tt": "tiktok",
    "tik": "tiktok",
    "tiktok": "tiktok",
    
    // YouTube variations
    "yt": "youtube",
    "youtube": "youtube",
    
    // Twitter/X variations
    "twitter": "twitter",
    "x": "twitter",
    "tweet": "twitter",
    
    // Twitch
    "twitch": "twitch",
    
    // Instagram
    "ig": "instagram",
    "insta": "instagram",
    "instagram": "instagram",
    
    // Discord
    "discord": "discord",
    
    // Kick
    "kick": "kick",
    
    // Facebook
    "fb": "facebook",
    "facebook": "facebook",
    
    // Other common platforms
    "linkedin": "linkedin",
    "github": "github",
    "reddit": "reddit"
  };
  
  return platformMap[platform.toLowerCase()] || platform.toLowerCase();
}

/**
 * Formats a social media value for display.
 * 
 * @param {string} platform - The platform name.
 * @param {string} value - The social media handle or URL.
 * @returns {string} - Formatted social media value.
 */
function formatSocialMediaValue(platform, value) {
  if (!value || value.trim() === "") return "";
  
  let formattedValue = value.trim();
  
  // Add @ prefix for handles if not present
  const handlePlatforms = ["twitter", "tiktok", "instagram"];
  if (handlePlatforms.includes(platform.toLowerCase()) && !formattedValue.startsWith("@")) {
    formattedValue = `@${formattedValue}`;
  }
  
  return `${formattedValue}`;
}

export { 
  socialMedias,
  normalizePlatformName, // Export for testing or direct use
  formatSocialMediaValue // Export for testing or direct use
};

/**
 * Checks if an input string matches any of a user's social media identifiers.
 *
 * @param {string} input - The input string to check.
 * @param {string} userId - The ID of the user.
 * @returns {Promise<boolean>} - True if a match is found, false otherwise.
 */
async function checkForUser(input, userId) {
  const socialMediaObj = await socialMedias(userId, "all");

  if (Object.keys(socialMediaObj).length === 0) {
    logger.log("System", "socialMediaObj is empty.");
    return false;
  }

  const normalizedInput = input.trim().toLowerCase();
  return Object.values(socialMediaObj).some((value) => {
    const normalizedValue = value.trim().toLowerCase();
    return normalizedValue === normalizedInput;
  });
}

/**
 * Checks if a message matches any command in the user's command list.
 *
 * @param {string} message - The message to check.
 * @param {string} userId - The ID of the user.
 * @returns {Promise<boolean>} - True if the message matches a command, false otherwise.
 */
const isCommandMatch = async (message, userId) => {
  const userObj = await returnAuthObject(userId);
  const commandRegex = new RegExp(
    `^(${userObj.commands_list.join("|")})$`,
    "i",
  );
  return commandRegex.test(message);
};

/**
 * Prepares a moderation chat request by formatting the message and adding relevant context.
 *
 * @param {string} userName - The name of the user being moderated.
 * @param {string} userMessage - The message from the user.
 * @param {number} emoteCount - The number of emotes in the message.
 * @param {string} userId - The ID of the user associated with the moderation.
 * @returns {Promise<string|object>} - The moderation action to take, or an object with details for further action.
 */
async function prepareModerationChatRequest(
  userName,
  userMessage,
  emoteCount,
  userId,
) {
  try {
    const strikeInfo = await getStrikesByUserName(userName, userId);
    const banInfo = await checkBanned(userName, userId);
    const userStrikes = strikeInfo.strikes;
    const userObject = await returnAuthObject(userId);

    let userMessageFormatted = `${userName} sent the following message:\n\`${userMessage}\`\nThey have ${userStrikes} strikes currently.\nThey sent ${emoteCount} emotes.`;

    if (userStrikes === 2) {
      userMessageFormatted += userObject.global_strikes
        ? `\n${userName} has ${userStrikes} strikes across all users platforms. This is their last strike. If they commit another offense, apply a ban.`
        : `\nThis is ${userName}'s last strike on ${userObject.user_name}'s channel. If they commit another offense, apply a ban.`;
    } else if (userStrikes >= 3) {
      userMessageFormatted += userObject.global_bans
        ? `\n${userName} has surpassed their max strikes on all user platforms. Apply a ban immediately regardless of their offense.`
        : `\n${userName} has surpassed their max strikes on ${userObject.user_name}'s channel. Apply a ban immediately regardless of their offense.`;
    }

    if (banInfo.banned) {
      userMessageFormatted += `\n${userName} has been banned in ${banInfo.banCount} other communities. Per ${userObject.user_name}'s request, apply a ban immediately regardless of their offense.`;
    }

    const moderationPrompt = await moderatorPrompt(
      userMessageFormatted,
      userId,
    );

    const completion = await sendChatCompletionRequest(moderationPrompt, await retrieveConfigValue("models.moderator"));
    const formattedCompletion = JSON.parse(completion.response)
    if (formattedCompletion.actionNeeded == true) {
      const reason = formattedCompletion.reason
      const action = formattedCompletion.actionType
      if (action === "strike") {
        logger.log(
          "Moderation",
          `${userName} earned a strike in ${userObject.twitch_name}'s channel. Reason: ${reason}'`,
        );
        const newStrikes = await incrementStrikes(userName, userId);
        return {
          action,
          reason,
          user: userName,
          userMsg: userMessage,
          strikeCount: newStrikes.strikes,
        };
      } else if (action === "ban") {
        logger.log(
          "Moderation",
          `${userName} received a ${action} in ${userObject.twitch_name}'s channel. Reason: '${reason}'`,
        );
        await addBanToUser(userName, userObject.twitch_name);
        return {
          action,
          reason,
          user: userName,
          userMsg: userMessage,
        };
      }
    } else {
      return "safe"
    }
  } catch (error) {
    logger.log("Moderation", `Error creating mod chat completion: ${error}`);
    return "error";
  }
}

/**
 * Retrieves the number of strikes for a given user.
 *
 * @param {string} userName - The name of the user.
 * @param {string} userId - The ID of the user associated with the strikes.
 * @returns {Promise<object>} - An object containing the user name and their number of strikes.
 */
const getStrikesByUserName = async (userName, userId) => {
  const userObject = await returnAuthObject(userId);
  try {
    const data = await fs.readFile("./data/global/strikes.json", "utf8");

    if (!data.trim()) {
      logger.log("Moderation", "The strike list is currently empty.");
      return { userName, strikes: 0 };
    }

    const strikes = JSON.parse(data);

    if (userObject.global_strikes && strikes.hasOwnProperty(userName)) {
      const sumOfAllStrikes = Object.values(strikes[userName]).reduce(
        (sum, count) => sum + count,
        0,
      );
      return { userName, strikes: sumOfAllStrikes };
    } else if (strikes.hasOwnProperty(userName)) {
      return {
        userName,
        strikes: strikes[userName][userObject.twitch_name] || 0,
      };
    } else {
      return { userName, strikes: 0 };
    }
  } catch (error) {
    logger.log(
      "Moderation",
      `Error reading or parsing the JSON file: ${error}`,
    );
  }
};

/**
 * Increments the strike count for a given user.
 *
 * @param {string} userName - The name of the user.
 * @param {string} userId - The ID of the user associated with the strikes.
 * @returns {Promise<object>} - An object containing the user name and their updated number of strikes.
 */
async function incrementStrikes(userName, userId) {
  const userObject = await returnAuthObject(userId);
  const strikesFilePath = "./data/global/strikes.json";

  try {
    await fs.ensureFile(strikesFilePath);
    let strikes = {};

    const data = await fs.readFile(strikesFilePath, "utf8");
    if (data.trim()) {
      strikes = JSON.parse(data);
    }

    if (!strikes.hasOwnProperty(userName)) {
      strikes[userName] = {};
    }

    strikes[userName][userObject.twitch_name] =
      (strikes[userName][userObject.twitch_name] || 0) + 1;

    await fs.writeFile(
      strikesFilePath,
      JSON.stringify(strikes, null, 2),
      "utf8",
    );

    return { userName, strikes: strikes[userName][userObject.twitch_name] };
  } catch (error) {
    logger.log("Moderation", `Error updating strikes: ${error}`, "err");
  }
}

/**
 * Checks if a user is banned and retrieves their ban information.
 *
 * @param {string} userName - The name of the user to check.
 * @param {string} userId - The ID of the user associated with the ban list.
 * @returns {Promise<object>} - An object containing ban information.
 */
const checkBanned = async (userName, userId) => {
  try {
    const bansData = JSON.parse(
      await fs.readFile("./data/global/bans.json", "utf-8"),
    );
    const userObject = await returnAuthObject(userId);

    if (userObject.global_bans && bansData.hasOwnProperty(userName)) {
      const streamerBans = bansData[userName]; // Array of streamers where the user is banned
      return {
        banned: true,
        streamerBans,
        banCount: streamerBans.length,
      };
    } else {
      return {
        banned: false,
        streamerBans: [],
        banCount: 0,
      };
    }
  } catch (error) {
    logger.log("Moderator", `Error reading or processing bans.json: ${error}`);
  }
};

/**
 * Adds a ban for a user in a specific streamer's context.
 *
 * @param {string} userName - The name of the user to ban.
 * @param {string} streamerName - The name of the streamer banning the user.
 * @returns {Promise<void>}
 */
const addBanToUser = async (userName, streamerName) => {
  try {
    const bansFilePath = "./data/global/bans.json";
    await fs.ensureFile(bansFilePath);

    let bansData = {};
    const data = await fs.readFile(bansFilePath, "utf8");
    if (data.trim()) {
      bansData = JSON.parse(data);
    }

    if (!bansData.hasOwnProperty(userName)) {
      bansData[userName] = [];
    }

    if (!bansData[userName].includes(streamerName)) {
      bansData[userName].push(streamerName);
      await fs.writeFile(
        bansFilePath,
        JSON.stringify(bansData, null, 2),
        "utf8",
      );
      logger.log(
        "System",
        `Banned ${userName} from ${streamerName}'s channel.`,
      );
    } else {
      logger.log(
        "Moderator",
        `${streamerName} is already in ${userName}'s ban list.`,
      );
    }
  } catch (error) {
    logger.log("Moderator", `Error reading or updating bans.json: ${error}`);
  }
};

/**
 * Checks if it's time to generate a fun fact based on the user's settings
 * @param {string} userId - The user ID
 * @returns {Promise<boolean>} - True if it's time for a fun fact, false otherwise
 */
export async function shouldGenerateFunFact(userId) {
  try {
    const user = await returnAuthObject(userId);
    
    // If fun facts are disabled, return false
    if (!user.funFacts) {
      return false;
    }
    
    const now = Date.now();
    const lastTime = lastFunFactTime.get(userId) || 0;
    const interval = (user.funFactsInterval || 30) * 60 * 1000; // Convert minutes to milliseconds
    
    // Check if enough time has passed since the last fun fact
    if (now - lastTime >= interval) {
      // Update the last fun fact time
      lastFunFactTime.set(userId, now);
      return true;
    }
    
    return false;
  } catch (error) {
    logger.error("Twitch", `Error checking fun fact timing: ${error.message}`);
    return false;
  }
}

/**
 * Removes a ban for a user in a specific streamer's context.
 *
 * @param {string} userName - The name of the user to unban.
 * @param {string} streamerName - The name of the streamer unbanning the user.
 * @returns {Promise<void>}
 */
const undoBan = async (userName, streamerName) => {
  try {
    const bansFilePath = "./data/global/bans.json";
    await fs.ensureFile(bansFilePath);

    let bansData = {};
    const data = await fs.readFile(bansFilePath, "utf8");
    if (data.trim()) {
      bansData = JSON.parse(data);
    }

    if (!bansData.hasOwnProperty(userName)) {
      logger.log(
        "Moderator",
        `User ${userName} does not exist in the ban list.`,
      );
      return;
    }

    const userBans = bansData[userName];
    const index = userBans.indexOf(streamerName);

    if (index !== -1) {
      userBans.splice(index, 1);
      if (userBans.length === 0) {
        delete bansData[userName]; // Remove the user entry if the ban list is empty
      }
      await fs.writeFile(
        bansFilePath,
        JSON.stringify(bansData, null, 2),
        "utf8",
      );
      logger.log(
        "System",
        `Removed ${streamerName} from ${userName}'s ban list.`,
      );
    } else {
      logger.log(
        "Moderator",
        `${streamerName} is not in ${userName}'s ban list.`,
      );
    }
  } catch (error) {
    logger.log("Moderator", `Error reading or updating bans.json: ${error}`);
  }
};

/**
 * Checks if a message contains any of the auxiliary bot names associated with a user.
 *
 * @param {string} message - The message to check.
 * @param {string} userId - The ID of the user associated with the auxiliary bots.
 * @returns {Promise<boolean>} - True if the message contains any of the auxiliary bot names, false otherwise.
 */
async function containsAuxBotName(message, userId) {
  const userObj = await returnAuthObject(userId);
  const auxBots = userObj.aux_bots;

  if (typeof message !== "string" || !Array.isArray(auxBots)) {

  }

  const lowerCaseMessage = message.toLowerCase();
  return auxBots.some((botName) =>
    lowerCaseMessage.includes(botName.toLowerCase()),
  );
}

export {
  returnTwitchEvent,
  isCommandMatch,
  prepareModerationChatRequest,
  incrementStrikes,
  getStrikesByUserName,
  checkForUser,
  containsAuxBotName,
  checkBanned,
  undoBan
};
</file>

<file path="routes/twitch.js">
// routes/twitch.js
import crypto from "crypto";
import { retrieveConfigValue } from "../config-helper.js";
import { returnAuthObject, updateUserParameter } from "../api-helper.js";
import { logger } from "../create-global-logger.js";

// Notification request headers
const TWITCH_MESSAGE_ID = "twitch-eventsub-message-id";
const TWITCH_MESSAGE_TIMESTAMP = "twitch-eventsub-message-timestamp";
const TWITCH_MESSAGE_SIGNATURE = "twitch-eventsub-message-signature";
const MESSAGE_TYPE = "twitch-eventsub-message-type";

// Notification message types
const MESSAGE_TYPE_VERIFICATION = "webhook_callback_verification";
const MESSAGE_TYPE_NOTIFICATION = "notification";
const MESSAGE_TYPE_REVOCATION = "revocation";

// Prepend this string to the HMAC that's created from the message
const HMAC_PREFIX = "sha256=";

async function getWebhookSecret(userId) {
  try {
    const user = await returnAuthObject(userId);

    // Check if user has webhook secret
    if (
      !user ||
      !user.twitch_tokens ||
      !user.twitch_tokens.streamer ||
      !user.twitch_tokens.streamer.webhook_secret
    ) {
      logger.log(
        "Twitch",
        `No webhook secret found for user ${userId}, generating temporary one`
      );

      // If there's no webhook secret, we should create one for future use
      // But for this verification, we'll return a dummy one that will fail verification
      if (user && user.twitch_tokens && user.twitch_tokens.streamer) {
        const newSecret = crypto.randomBytes(32).toString("hex");

        // Try to ensure path exists and set the webhook secret
        await ensureParameterPath(userId, "twitch_tokens.streamer");
        await updateUserParameter(
          userId,
          "twitch_tokens.streamer.webhook_secret",
          newSecret
        );

        // Log but still return a dummy secret for this verification
        logger.log(
          "Twitch",
          `Generated new webhook secret for future use, but current verification will fail`
        );
      }

      // Return a dummy secret that will cause verification to fail (this is intentional)
      return "invalid-verification-will-fail";
    }

    // Return the actual webhook secret
    return user.twitch_tokens.streamer.webhook_secret;
  } catch (error) {
    logger.error("Twitch", `Error getting webhook secret: ${error.message}`);
    // Return a dummy secret that will cause verification to fail
    return "error-getting-secret";
  }
}

async function twitchEventSubRoutes(fastify, options) {
  // Configure the raw body parser specifically for this route
  fastify.addContentTypeParser(
    "application/json",
    { parseAs: "buffer" },
    (req, body, done) => {
      done(null, body);
    }
  );

  // Helper functions for EventSub signature verification
  const getSecret = async (userId) => {
    // Get the secret from configuration
    try {
      const user = await returnAuthObject(userId);
      if (!user || !user.twitch_tokens || !user.twitch_tokens.webhook_secret) {
        logger.error("Twitch", `No webhook secret found for user ${userId}`);
        return null;
      }
      return user.twitch_tokens.webhook_secret;
    } catch (error) {
      logger.error("Twitch", `Error getting webhook secret: ${error.message}`);
      return null;
    }
  };

  const getHmacMessage = (headers, body) => {
    if (!headers || !body) {
      logger.error("Twitch", "Missing headers or body for HMAC calculation");
      return "";
    }

    const messageId = headers[TWITCH_MESSAGE_ID];
    const timestamp = headers[TWITCH_MESSAGE_TIMESTAMP];

    if (!messageId || !timestamp) {
      logger.error("Twitch", "Missing required headers for HMAC calculation");
      return "";
    }

    return messageId + timestamp + body;
  };

  const getHmac = (secret, message) => {
    if (!secret || !message) {
      logger.error("Twitch", "Missing secret or message for HMAC calculation");
      return "";
    }

    return crypto.createHmac("sha256", secret).update(message).digest("hex");
  };

  const verifyMessage = (hmac, verifySignature) => {
    try {
      return crypto.timingSafeEqual(
        Buffer.from(hmac),
        Buffer.from(verifySignature)
      );
    } catch (error) {
      logger.error("Twitch", `Error verifying signature: ${error.message}`);
      return false;
    }
  };

  // Test webhook endpoint for simulating Twitch events
  fastify.post("/eventsub/test/:userId", async (request, reply) => {
    try {
      const { userId } = request.params;
      const { eventType, eventData, eventVersion = "1" } = request.body;

      // Validate required parameters

      logger.log(
        "Twitch",
        `Processing test ${eventType} event for user ${userId}`
      );

      // Import the event processor
      const { processEventSubNotification } = await import(
        "../twitch-eventsub-manager.js"
      );

      // Process the event using the existing event processor
      const result = await processEventSubNotification(
        eventType,
        eventData,
        userId,
        eventVersion
      );

      return reply.send({
        success: true,
        eventType,
        userId,
        result,
      });
    } catch (error) {
      logger.error("Twitch", `Error processing test event: ${error.message}`);
      return reply.code(500).send({ error: error.message });
    }
  });
  fastify.get("/eventsub/test/examples/:eventType", async (request, reply) => {
    const { eventType } = request.params;

    // Import user object to get broadcaster ID if needed
    const { returnAuthObject } = await import("../api-helper.js");

    // Get user ID from query param or use a default
    const userId = request.query.userId || "default_user_id";

    // Try to get user details to populate broadcaster information
    let userObj;
    try {
      userObj = await returnAuthObject(userId);
    } catch (error) {
      logger.warn(
        "Twitch",
        `Could not get user object for ${userId}: ${error.message}`
      );
    }

    const broadcasterId =
      userObj?.twitch_tokens?.streamer?.twitch_user_id || "123456789";
    const broadcasterName = userObj?.twitch_name || "TestStreamer";

    const examples = {
      "channel.follow": {
        eventType: "channel.follow",
        eventData: {
          user_name: "TestFollower",
          user_id: "987654321",
          broadcaster_user_id: broadcasterId,
          broadcaster_user_name: broadcasterName,
          followed_at: new Date().toISOString(),
        },
        eventVersion: "2",
      },
      "channel.subscribe": {
        eventType: "channel.subscribe",
        eventData: {
          user_name: "TestSubscriber",
          user_id: "987654321",
          broadcaster_user_id: broadcasterId,
          broadcaster_user_name: broadcasterName,
          tier: "1000",
          is_gift: false,
        },
        eventVersion: "1",
      },
      "channel.subscription.gift": {
        eventType: "channel.subscription.gift",
        eventData: {
          user_name: "TestGifter",
          user_id: "987654321",
          broadcaster_user_id: broadcasterId,
          broadcaster_user_name: broadcasterName,
          tier: "1000",
          is_anonymous: false,
          recipient_user_name: "GiftRecipient",
          recipient_user_id: "456789123",
          total: 1,
        },
        eventVersion: "1",
      },
      "channel.raid": {
        eventType: "channel.raid",
        eventData: {
          from_broadcaster_user_id: "987654321",
          from_broadcaster_user_name: "TestRaider",
          to_broadcaster_user_id: broadcasterId,
          to_broadcaster_user_name: broadcasterName,
          viewers: 42,
        },
        eventVersion: "1",
      },
      "channel.chat.message": {
        eventType: "channel.chat.message",
        eventData: {
          broadcaster_user_id: broadcasterId,
          broadcaster_user_name: broadcasterName,
          chatter: {
            user_id: "987654321",
            user_name: "TestChatter",
            badges: [{ set_id: "subscriber", version: "1" }],
          },
          message: {
            text: "This is a test message! @" + broadcasterName,
            is_first: false,
            fragments: [
              {
                type: "text",
                text: "This is a test message! @" + broadcasterName,
              },
            ],
          },
        },
        eventVersion: "1",
      },
    };

    if (!examples[eventType]) {
      return reply.code(404).send({
        error: "Event type not found",
        availableTypes: Object.keys(examples),
      });
    }

    return reply.send(examples[eventType]);
  });

  // List current EventSub subscriptions
  fastify.get("/subscriptions/:userId", async (request, reply) => {
    const { userId } = request.params;

    try {
      const user = await returnAuthObject(userId);

      if (!user || !user.twitch_tokens || !user.twitch_tokens.access_token) {
        return reply
          .code(400)
          .send({ error: "User has no Twitch integration" });
      }

      // Get subscriptions from Twitch API
      const response = await axios.get(
        "https://api.twitch.tv/helix/eventsub/subscriptions",
        {
          headers: {
            "Client-ID": await retrieveConfigValue("twitch.clientId"),
            Authorization: `Bearer ${user.twitch_tokens.access_token}`,
          },
        }
      );

      return {
        success: true,
        subscriptions: response.data.data,
        total: response.data.total,
        max: response.data.max_total_cost,
      };
    } catch (error) {
      logger.error("Twitch", `Error listing subscriptions: ${error.message}`);
      return reply.code(500).send({ error: error.message });
    }
  });

  // Manually register all EventSub for a user
  fastify.post("/subscriptions/register/:userId", async (request, reply) => {
    const { userId } = request.params;

    try {
      // Import registration function
      const { registerUserSubscriptions } = await import(
        "../twitch-eventsub-manager.js"
      );

      // Register subscriptions
      const result = await registerUserSubscriptions(userId);

      return {
        success: result.success,
        created: result.created,
        skipped: result.skipped,
        error: result.error,
      };
    } catch (error) {
      logger.error(
        "Twitch",
        `Error registering subscriptions: ${error.message}`
      );
      return reply.code(500).send({ error: error.message });
    }
  });

  // Route to handle EventSub notifications
  fastify.post("/eventsub/:userId", async (request, reply) => {
    const { userId } = request.params;

    if (!userId) {
      logger.error("Twitch", "No userId provided in EventSub webhook URL");
      return reply.code(400).send({ error: "Missing userId parameter" });
    }

    // Get the webhook secret for this user
    const secret = await getWebhookSecret(userId);

    // Get and verify the signature
    const headers = request.headers;
    const rawBody = request.body;

    try {
      // Calculate the expected signature
      const message = getHmacMessage(headers, rawBody);
      const hmac = HMAC_PREFIX + getHmac(secret, message);

      // Verify the request is actually from Twitch
      if (!verifyMessage(hmac, headers[TWITCH_MESSAGE_SIGNATURE])) {
        logger.error("Twitch", "EventSub signature verification failed");

        // If the secret was a dummy one, it means we don't have a valid webhook secret
        if (
          secret === "invalid-verification-will-fail" ||
          secret === "error-getting-secret"
        ) {
          logger.error(
            "Twitch",
            `Invalid webhook secret for user ${userId}, verification was expected to fail`
          );

          // Register EventSub for this user to generate a valid webhook secret for next time
          const { registerUserSubscriptions } = await import(
            "../twitch-eventsub-manager.js"
          );
          registerUserSubscriptions(userId).catch((err) => {
            logger.error(
              "Twitch",
              `Failed to register EventSub subscriptions: ${err.message}`
            );
          });
        }

        return reply.code(403).send({ error: "Signature verification failed" });
      }

      // Signature verified, process the notification
      const notification = JSON.parse(rawBody.toString());
      const messageType = headers[MESSAGE_TYPE];

      // Handle different message types
      if (messageType === MESSAGE_TYPE_NOTIFICATION) {
        // Process the event
        await processEvent(notification, userId);
        return reply.code(204).send();
      } else if (messageType === MESSAGE_TYPE_VERIFICATION) {
        // Respond to webhook verification challenge
        logger.log(
          "Twitch",
          `EventSub verification received for user ${userId}`
        );
        return reply.code(200).type("text/plain").send(notification.challenge);
      } else if (messageType === MESSAGE_TYPE_REVOCATION) {
        // Handle subscription revocation
        logger.log(
          "Twitch",
          `EventSub ${notification.subscription.type} notifications revoked for user ${userId}`
        );
        logger.log("Twitch", `Reason: ${notification.subscription.status}`);

        // Update user's subscription status
        await handleEventSubRevocation(notification, userId);
        return reply.code(204).send();
      } else {
        logger.log("Twitch", `Unknown message type: ${messageType}`);
        return reply.code(204).send();
      }
    } catch (error) {
      logger.error(
        "Twitch",
        `Error processing EventSub notification: ${error.message}`
      );
      return reply.code(500).send({ error: "Internal server error" });
    }
  });

  fastify.post("/eventsub/register/:userId", async (request, reply) => {
    const { userId } = request.params;

    try {
      // Import registration function
      const { registerUserSubscriptions } = await import(
        "../twitch-eventsub-manager.js"
      );

      // Register subscriptions
      const result = await registerUserSubscriptions(userId);

      return {
        success: result.success,
        created: result.created,
        skipped: result.skipped,
        error: result.error,
      };
    } catch (error) {
      logger.error(
        "Twitch",
        `Error registering subscriptions: ${error.message}`
      );
      return reply.code(500).send({ error: error.message });
    }
  });

  fastify.get("/eventsub/subscriptions/:userId", async (request, reply) => {
    const { userId } = request.params;

    try {
      const user = await returnAuthObject(userId);

      if (!user || !user.twitch_tokens?.streamer?.access_token) {
        return reply
          .code(400)
          .send({ error: "User has no Twitch integration" });
      }

      // Import axios if needed
      const axios = (await import("axios")).default;

      // Get subscriptions from Twitch API
      const response = await axios.get(
        "https://api.twitch.tv/helix/eventsub/subscriptions",
        {
          headers: {
            "Client-ID": await retrieveConfigValue("twitch.clientId"),
            Authorization: `Bearer ${user.twitch_tokens.streamer.access_token}`,
          },
        }
      );

      return {
        success: true,
        subscriptions: response.data.data,
        total: response.data.total,
        max: response.data.max_total_cost,
      };
    } catch (error) {
      logger.error("Twitch", `Error listing subscriptions: ${error.message}`);
      return reply.code(500).send({ error: error.message });
    }
  });

  // EventSub subscription management endpoint
  fastify.post("/eventsub/subscribe", async (request, reply) => {
    const { userId, type, condition } = request.body;

    if (!userId || !type) {
      return reply.code(400).send({ error: "Missing required parameters" });
    }

    try {
      const result = await subscribeToEvent(userId, type, condition);
      return reply.send(result);
    } catch (error) {
      logger.error("Twitch", `Error subscribing to event: ${error.message}`);
      return reply.code(500).send({ error: error.message });
    }
  });
}

// Function to subscribe to EventSub events
async function subscribeToEvent(userId, type, condition = {}) {
  try {
    const user = await returnAuthObject(userId);

    if (!user) {
      throw new Error("User not found");
    }

    // Generate a new secret if one doesn't exist
    if (!user.twitch_tokens?.streamer?.webhook_secret) {
      const newSecret = crypto.randomBytes(32).toString("hex");

      // Ensure the path exists
      await ensureParameterPath(userId, "twitch_tokens.streamer");

      // Save the new secret
      await updateUserParameter(
        userId,
        "twitch_tokens.streamer.webhook_secret",
        newSecret
      );
    }

    // Default condition uses the broadcaster's ID
    if (Object.keys(condition).length === 0) {
      if (!user.twitch_tokens?.streamer?.twitch_user_id) {
        throw new Error("No broadcaster user ID available");
      }
      condition = {
        broadcaster_user_id: user.twitch_tokens.streamer.twitch_user_id,
      };
    }

    // Import needed functions
    const { getAppAccessToken } = await import("../twitch-eventsub-manager.js");
    const appToken = await getAppAccessToken();

    // Prepare the subscription payload
    const callbackUrl = `${await retrieveConfigValue("server.endpoints.external")}/api/v1/twitch/eventsub/${userId}`;

    // Get fresh user data to ensure we have the webhook secret
    const freshUser = await returnAuthObject(userId);

    const subscriptionBody = {
      type,
      version: "1",
      condition,
      transport: {
        method: "webhook",
        callback: callbackUrl,
        secret: freshUser.twitch_tokens.streamer.webhook_secret,
      },
    };

    // Make the API request to create the subscription
    const axios = (await import("axios")).default;
    const response = await axios.post(
      "https://api.twitch.tv/helix/eventsub/subscriptions",
      subscriptionBody,
      {
        headers: {
          "Client-ID": await retrieveConfigValue("twitch.clientId"),
          Authorization: `Bearer ${appToken}`, // Use app token here
          "Content-Type": "application/json",
        },
      }
    );

    // Save subscription ID in user's data
    const subscriptionId = response.data.data[0].id;

    // Update user's subscriptions list
    const subscriptions = freshUser.twitch_tokens.streamer.subscriptions || [];
    subscriptions.push({
      id: subscriptionId,
      type,
      created_at: new Date().toISOString(),
    });

    await updateUserParameter(
      userId,
      "twitch_tokens.streamer.subscriptions",
      subscriptions
    );

    logger.log(
      "Twitch",
      `Created EventSub subscription for ${userId}: ${type}`
    );

    return {
      success: true,
      subscription: response.data.data[0],
    };
  } catch (error) {
    logger.error("Twitch", `Failed to create subscription: ${error.message}`);
    throw error;
  }
}

// Handle EventSub revocation
async function handleEventSubRevocation(notification, userId) {
  try {
    const subscriptionId = notification.subscription.id;

    if (!userId || !subscriptionId) {
      logger.error("Twitch", "Missing userId or subscriptionId for revocation");
      return;
    }

    const user = await returnAuthObject(userId);

    if (!user || !user.twitch_tokens?.streamer?.subscriptions) {
      logger.error("Twitch", `No subscriptions found for user ${userId}`);
      return;
    }

    // Filter out the revoked subscription
    const subscriptions = user.twitch_tokens.streamer.subscriptions.filter(
      (sub) => sub.id !== subscriptionId
    );

    // Update the subscriptions list
    await updateUserParameter(
      userId,
      "twitch_tokens.streamer.subscriptions",
      subscriptions
    );

    logger.log(
      "Twitch",
      `Removed revoked subscription ${subscriptionId} for user ${userId}`
    );
  } catch (error) {
    logger.error("Twitch", `Error handling revocation: ${error.message}`);
  }
}

async function processEvent(notification, userId) {
  try {
    const eventType = notification.subscription.type;
    const eventVersion = notification.subscription.version || "1";
    const event = notification.event;

    // Log the event
    logger.log(
      "Twitch",
      `Processing ${eventType} (v${eventVersion}) event for user ${userId}`
    );

    // Import the event processor from the manager
    const { processEventSubNotification } = await import(
      "../twitch-eventsub-manager.js"
    );

    // Process based on the event type
    return await processEventSubNotification(
      eventType,
      event,
      userId,
      eventVersion
    );
  } catch (error) {
    logger.error("Twitch", `Error processing event: ${error.message}`);
    return { success: false, error: error.message };
  }
}

export default twitchEventSubRoutes;
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*
package-lock.json

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock
auth_keys.json
# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port
*.env
# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*
data/*
world_info/*
instructs/*
resources/*
.prettierrc
*.json
!*.example.json
!package.json
*.key
*.crt
start.sh
final/*
temp/*
*.go
go.mod
go.sum
bin/*
logs/*
*.sh
repomix-output.md
images/*
PRIVACY_POLICY.md
</file>

<file path="package.json">
{
  "name": "streamer-llm",
  "version": "1.0.2",
  "description": "Just a Node.js interface to a chat completion API to create responses and (optionally) send them to a TTS service",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Prolix OCs",
  "license": "ISC",
  "dependencies": {
    "@fastify/compress": "^8.0.1",
    "@fastify/cookie": "^11.0.2",
    "@fastify/cors": "^10.0.1",
    "@fastify/formbody": "^8.0.1",
    "@fastify/multipart": "^9.0.3",
    "@fastify/rate-limit": "^10.2.1",
    "@fastify/static": "^8.1.1",
    "@fastify/view": "^11.0.0",
    "@fastify/websocket": "^11.1.0",
    "@mozilla/readability": "^0.6.0",
    "@zilliz/milvus2-sdk-node": "^2.5.5",
    "ansi-colors-es6": "^5.0.0",
    "axios": "^1.7.7",
    "chalk": "^5.3.0",
    "cheerio": "^1.0.0",
    "commander": "^12.1.0",
    "fast-levenshtein": "^3.0.0",
    "fastify": "^5.0.0",
    "ffmpeg-static": "^5.2.0",
    "form-data": "^4.0.2",
    "fs-extra": "^11.2.0",
    "jsdom": "^25.0.1",
    "jsonrepair": "^3.11.2",
    "mediainfo.js": "^0.3.3",
    "moment": "^2.30.1",
    "mongoose": "^8.13.1",
    "neo-blessed": "^0.2.0",
    "node-addon-api": "^8.2.1",
    "node-cron": "^3.0.3",
    "node-web-audio-api": "^1.0.4",
    "nunjucks": "^3.2.4",
    "openai": "^4.68.4",
    "puppeteer": "^23.10.4",
    "readline": "^1.3.0",
    "tokenizers": "^0.13.3",
    "tokenizers-linux-x64-gnu": "^0.13.4-rc1",
    "untruncate-json": "^0.0.1",
    "uuid": "^11.1.0",
    "ws": "^8.18.0",
    "zod": "^3.24.1"
  },
  "overrides": {
    "whatwg-url": "14.x",
    "tough-cookie": "5.x"
  },
  "events": {
    "start": "node -e console.clear() "
  },
  "devDependencies": {
    "prettier": "3.4.2"
  }
}
</file>

<file path="api-helper.js">
import fs from "fs-extra";
import axios from "axios";
import cron from "node-cron";
import * as crypto from "crypto";
import path from "path";
import { 
  connectToMongoDB, 
  getUserById, 
  getAllUsers, 
  updateUserData,
  ensureUserPath,
  flushAllChanges
} from './mongodb-client.js';
import { retrieveConfigValue } from "./config-helper.js";
import { logger } from './create-global-logger.js';
let cachedAuthKeys = null;

const authFilePath = await retrieveConfigValue("server.authFilePath");

/**
 * Loads API keys from MongoDB
 * @returns {Promise<void>}
 */
async function loadAPIKeys() {
  try {
    // Connect to MongoDB
    const connected = await connectToMongoDB();
    
    if (!connected) {
      logger.error("API", "Could not connect to MongoDB, using empty user list");
      cachedAuthKeys = [];
      return;
    }
    
    // No need to cache here as getUserById handles caching
    logger.log("API", "MongoDB connection established");
  } catch (err) {
    logger.error("API", `Error initializing MongoDB: ${err.message}`);
    cachedAuthKeys = [];
  }
}

/**
 * Returns a copy of all users
 * @returns {Promise<object[]>} A promise that resolves to an array of user objects
 */
const returnAPIKeys = async () => {
  try {
    return await getAllUsers();
  } catch (error) {
    logger.error("API", `Error fetching all users: ${error.message}`);
    return [];
  }
};

/**
 * Returns the authentication object for a given user ID
 * @param {string} userId - The ID of the user
 * @returns {Promise<object|null>} A promise that resolves to the user's auth object or null if not found
 */
const returnAuthObject = async (userId) => {
  try {
    return await getUserById(userId);
  } catch (error) {
    logger.error("API", `Error fetching user ${userId}: ${error.message}`);
    return null;
  }
};

/**
 * Ensures a nested parameter path exists in the user object
 * @param {string} userId - The user ID
 * @param {string} parameterPath - The dot-notation path to ensure exists
 * @returns {Promise<boolean>} - True if successful, false otherwise
 */
export async function ensureParameterPath(userId, parameterPath) {
  try {
    return await ensureUserPath(userId, parameterPath);
  } catch (error) {
    logger.error("API", `Error ensuring parameter path: ${error.message}`);
    return false;
  }
}

/**
 * Updates a specific parameter for a user
 * @param {string} userId - The ID of the user to update
 * @param {string} parameter - Path to the parameter to update
 * @param {any} newValue - The new value for the parameter
 * @returns {Promise<boolean>} - True if successful, false otherwise
 */
async function updateUserParameter(userId, parameter, newValue) {
  try {
    return await updateUserData(userId, parameter, newValue);
  } catch (error) {
    logger.error("API", `Error updating user parameter: ${error.message}`);
    return false;
  }
}

async function getAndStoreLatLong(ipAddr, userId) {
  try {
    const response = await axios.get(
      new URL(
        `http://ip-api.com/json/${ipAddr}?fields=status,message,country,regionName,lat,lon,timezone`,
      ),
    );
    if (response.data.status === "fail") {
      if (response.data.message === "private range") {
        logger.log("API", "Request from local network determined.");
        return false;
      } else if (response.data.message === "reserved range") {
        logger.log("API", "Request from the feds (???) determined.");
        return false;
      } else {
        logger.log("API", "Bad request for IP information.");
        return false;
      }
    } else {
      const { lat, lon, timezone } = response.data; // FIXED: Changed request.data to response.data
      await updateUserParameter(userId, "latitude", lat);
      await updateUserParameter(userId, "longitude", lon);
      await updateUserParameter(userId, "timeZone", timezone);
      return { latitude: lat, longitude: lon, timezone: timezone };
    }
  } catch (error) {
    logger.log("API", `Error in getAndStoreLatLong: ${error.message}`);
    return false;
  }
}

/**
 * Saves all pending changes to disk
 * @returns {Promise<void>}
 */
async function saveAuthToDisk() {
  try {
    await flushAllChanges();
    logger.log("API", "All pending changes saved to MongoDB");
  } catch (error) {
    logger.error("API", `Error saving changes to MongoDB: ${error.message}`);
  }
}

async function fetchWeather() {
  try {
    const users = await returnAPIKeys();

    for (const user of users) {
      if (!user.weather || !user.lastIp || user.lastIp === "") {
        continue; // Skip users without weather or IP
      }

      let locData = null;

      // Only call getAndStoreLatLong if latitude is not already set
      if (!user.latitude || user.latitude === "") {
        try {
          locData = await getAndStoreLatLong(user.lastIp, user.user_id);
        } catch (error) {
          logger.log(
            "API",
            `Error getting or storing lat/long for user ${user.user_id}: ${error}`,
          );
          continue; // Skip to the next user on error
        }
      } else {
        // Use existing latitude and longitude if available
        locData = {
          latitude: user.latitude,
          longitude: user.longitude,
          timezone: user.timeZone,
        };
      }

      // Ensure locData is valid before proceeding
      if (!locData || !locData.latitude || !locData.longitude) {
        logger.log(
          "API",
          `Missing or invalid location data for user ${user.user_id}.`,
        );
        continue; // Skip to the next user
      }

      try {
        const url = new URL(`https://api.open-meteo.com/v1/forecast`);
        url.searchParams.append("latitude", locData.latitude);
        url.searchParams.append("longitude", locData.longitude);
        url.searchParams.append(
          "current",
          "temperature_2m,is_day,precipitation,rain,showers,snowfall,cloud_cover,wind_speed_10m",
        );
        url.searchParams.append("precipitation_unit", "inch");
        url.searchParams.append("temperature_unit", "fahrenheit");
        url.searchParams.append("wind_speed_unit", "mph");
        url.searchParams.append("models", "gfs_seamless");
        url.searchParams.append("timezone", locData.timezone);

        const response = await axios.get(url.toString());

        if (response.status === 200) {
          const current = response.data.current;
          const tempF = parseInt(current["temperature_2m"]).toFixed(0);
          const cloudCover = parseInt(current["cloud_cover"]);
          const rainAmt = current["rain"].toFixed(1);
          const snowAmt = current["snowfall"].toFixed(1);
          const windSpeed = current["wind_speed_10m"].toFixed(0);

          let rainString = "";
          let cloudString = "";
          let tempString = "";
          let snowString = "";
          let windString = "";

          cloudString =
            cloudCover === 0
              ? " There are clear skies with no clouds in sight."
              : cloudCover <= 20
                ? " There are very few clouds in the sky."
                : cloudCover <= 50
                  ? " There are a few clouds in the sky."
                  : cloudCover <= 75
                    ? " There are a lot of clouds in the sky."
                    : " The sky is full of clouds.";

          tempString =
            tempF <= 0
              ? ` It's way below freezing at ${tempF} degrees.`
              : tempF <= 31.9
                ? ` It's below freezing at ${tempF} degrees.`
                : tempF <= 59.9
                  ? ` It's quite chilly at ${tempF} degrees.`
                  : tempF <= 78.9
                    ? ` It's quite cozy outside at ${tempF} degrees.`
                    : tempF <= 94.9
                      ? ` It's pretty warm outside at ${tempF} degrees.`
                      : ` It's quite hot outside at ${tempF} degrees.`;

          rainString =
            rainAmt == 0
              ? ""
              : rainAmt <= 0.9
                ? " It's lightly rainy outside."
                : rainAmt <= 1.9
                  ? " It's raining outside."
                  : rainAmt <= 5
                    ? " It's very rainy outside."
                    : " It's extremely rainy outside, almost like a huge storm.";

          snowString =
            snowAmt == 0
              ? ""
              : snowAmt <= 1
                ? " There is a light snowfall outside."
                : snowAmt <= 4
                  ? " There is a pleasant amount of snow outside."
                  : snowAmt <= 9.9
                    ? " There is quite a bit of snow outside."
                    : " There is a whole lot of snow outside.";

          windString =
            windSpeed == 0
              ? ""
              : windSpeed <= 9.9
                ? ` It is lightly windy outside at ${windSpeed} miles per hour.`
                : windSpeed <= 25.9
                  ? ` It's fairly windy outside at ${windSpeed} miles per hour.`
                  : windSpeed <= 49.9
                    ? ` It's moderately windy outside at ${windSpeed} miles per hour.`
                    : windSpeed <= 74.9
                      ? ` It's severely windy outside at ${windSpeed} miles per hour.`
                      : ` It is extremely windy outside, almost like a hurricane, at ${windSpeed} miles per hour.`;

          const timeOfDay = `It is currently ${current["is_day"] ? "day time." : "night time."
            }`;
          const currWeather = `${timeOfDay}${tempString}${cloudString}${rainString}${snowString}${windString}`;

          const userDir = path.join("./world_info", user.user_id);
          if (!fs.existsSync(userDir)) {
            await fs.promises.mkdir(userDir, { recursive: true });
          }
          await fs.promises.writeFile(
            path.join(userDir, "weather.txt"),
            currWeather,
          );
        } else {
          logger.log("API", `Failed to fetch weather for ${user.user_id}.`);
        }
      } catch (error) {
        logger.log(
          "API",
          `Error fetching weather for ${user.user_id}: ${error.message}`,
          "err"
        );
      }
    }
  } catch (error) {
    logger.log("API", `Error reading user data: ${error.message}`);
  }
}

/**
 * Checks for authentication using a provided token.
 * @param {string} token - The authentication token.
 * @returns {Promise<object>} A promise that resolves to an object indicating validity and user details.
 */
async function checkForAuth(token) {
  const allTokens = await returnAPIKeys();
  if (!allTokens || allTokens.length === 0) {
    return { valid: false };
  }

  const validObject = allTokens.find(
    (object) => token.trim() === object.api_token,
  );
  return validObject ? { valid: true, ...validObject } : { valid: false };
}

const funFact = async () => {
  const pickOne = Math.floor(Math.random() * 5) + 1
  switch (pickOne) {
    case 1:
      logger.log("API", "Pulled fact from Black History API.")
      return await blackRandomFact()
    case 2:
      logger.log("API", "Pulled fact from MeowFacts.")
      return await randomCatFact()
    case 3:
      logger.log("API", "Pulled fact from Numbers API.")
      return await randomNumbersFact()
    case 4:
      logger.log("API", "Pulled fact from Kinduff.")
      return await randomDogFact()
    case 5:
      logger.log("API", "Pulled fact from UselessFacts.")
      return await randomUselessFact()
    default:
      return "One of the websites decided to take a break. Instead of sharing a provided fun fact from one of these sites, talk about your favorite safe-for-work and stream-appropriate fact about your favorite person."
  }
};

const blackRandomFact = async () => {
  try {
    const response = await axios.get(
      "https://rest.blackhistoryapi.io/fact/random", { headers: { "x-api-key": await retrieveConfigValue("funFacts.key") } }
    );
    return response.data.Results[0].text;
  } catch (err) {
    logger.log("System", "Unable to get random fact from BlackHistoryAPI")
  }

};

const randomCatFact = async () => {
  try {
    const response = await axios.get(
      "https://meowfacts.herokuapp.com/"
    );
    return response.data.data[0];
  } catch (err) {
    logger.log("System", "Unable to get random fact from UselessFacts")
  }
};

const randomUselessFact = async () => {
  try {
    const response = await axios.get(
      "https://uselessfacts.jsph.pl/api/v2/facts/random?language=en"
    );
    return response.data.text;
  } catch (err) {
    logger.log("System", "Unable to get random fact from MeowFacts")
  }
}

const randomDogFact = async () => {
  try {
    const response = await axios.get(
      "http://dog-api.kinduff.com/api/facts?number=1"
    );
    return response.data.facts[0];
  } catch (err) {
    logger.log("System", "Unable to get random fact from DogApi")
  }
};

const randomNumbersFact = async () => {
  try {
    const response = await axios.get(
      "http://numbersapi.com/random?json",
    );
    return response.data.text
  } catch (err) {
    logger.log("System", "Unable to get random fact from NumbersApi")
  }

}

async function initAllAPIs() {
  await fetchWeather();
  cron.schedule("*/10 * * * *", async () => {
    await fetchWeather();
  });
}

process.on('SIGTERM', async () => {
  await flushAllChanges();
});

process.on('SIGINT', async () => {
  await flushAllChanges();
});

export {
  initAllAPIs,
  funFact,
  returnAuthObject,
  checkForAuth,
  loadAPIKeys,
  returnAPIKeys,
  saveAuthToDisk,
  updateUserParameter,
};
</file>

<file path="routes/web.js">
// routes/web.js
import fs from "fs-extra";
import path from "path";
import { returnAuthObject, updateUserParameter } from "../api-helper.js";
import { logger } from "../create-global-logger.js";
import { fileURLToPath } from "url";
import { dirname } from "path";
import { getChatCount } from "../mongodb-client.js";
import {
  loadPreset,
  loadAllPresets,
  hashPassword,
  isPasswordCorrect,
} from "./v1.js";

// Get the directory name properly in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

/**
 * Loads text content from a file if it exists, or returns an empty string
 * @param {string} userId - The user ID
 * @param {string} fileName - The file name
 * @returns {Promise<string>} - The file content or empty string
 */
async function loadTextContent(userId, fileName) {
  try {
    const filePath = path.join(
      process.cwd(),
      "world_info",
      userId,
      `${fileName}.txt`
    );

    // Create directory if it doesn't exist
    await fs.ensureDir(path.join(process.cwd(), "world_info", userId));

    // Check if file exists
    const exists = await fs.pathExists(filePath);
    if (!exists) {
      return "";
    }

    // Read file content
    return await fs.readFile(filePath, "utf8");
  } catch (error) {
    logger.error(
      "Web",
      `Error loading ${fileName} for user ${userId}: ${error.message}`
    );
    return "";
  }
}

// Import verifySessionToken function from existing auth code
import { verifySessionToken } from "./v1.js";

/**
 * Authentication middleware for web routes
 * @param {object} request - The request object
 * @param {object} reply - The reply object
 * @returns {Promise<void>}
 */
async function requireAuth(request, reply) {
  // Check if cookies object exists and if the enspira_session cookie is set
  const sessionToken = request.cookies?.enspira_session;

  if (!sessionToken) {
    logger.log("Auth", "No session token found, redirecting to login");
    return reply.redirect("/web/auth/login"); // Updated path
  }

  try {
    // Verify and decode the session token
    const decoded = verifySessionToken(sessionToken);

    if (!decoded || !decoded.userId) {
      // Invalid token
      reply.clearCookie("enspira_session");
      return reply.redirect("/web/auth/login"); // Updated path
    }

    // Get user from database
    const user = await returnAuthObject(decoded.userId);

    if (!user) {
      // User doesn't exist
      reply.clearCookie("enspira_session");
      return reply.redirect("/web/auth/login"); // Updated path
    }

    // Add user to request for use in route handlers
    request.user = user;

    // Continue to route handler
    return;
  } catch (error) {
    logger.error("Auth", `Session validation error: ${error.message}`);
    reply.clearCookie("enspira_session");
    return reply.redirect("/web/auth/login"); // Updated path
  }
}

// Helper function to extract form field values
function getFieldValue(field) {
  if (!field) return "";

  // If the field is a Part object from @fastify/multipart
  if (field.value !== undefined) {
    return field.value;
  }

  // If the field is already a string
  if (typeof field === "string") {
    return field;
  }

  // If the field is a readable stream (file upload)
  if (field.pipe && typeof field.pipe === "function") {
    // For this implementation, we're not handling file uploads
    return "";
  }

  // Return empty string for any other case
  return "";
}

// Setup the web routes
async function webRoutes(fastify, options) {
  // Register the form body parser to ensure form submissions work
  await fastify.register(import("@fastify/formbody"));

  // Ensure the pages directory exists
  await fs.ensureDir(path.join(process.cwd(), "pages"));
  fastify.get(
    "/settings",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // List of common time zones
        const timeZones = [
          { value: "America/New_York", label: "Eastern Time (ET)" },
          { value: "America/Chicago", label: "Central Time (CT)" },
          { value: "America/Denver", label: "Mountain Time (MT)" },
          { value: "America/Los_Angeles", label: "Pacific Time (PT)" },
          { value: "America/Anchorage", label: "Alaska Time (AKT)" },
          { value: "Pacific/Honolulu", label: "Hawaii Time (HT)" },
          { value: "Europe/London", label: "Greenwich Mean Time (GMT)" },
          { value: "Europe/Paris", label: "Central European Time (CET)" },
          { value: "Europe/Helsinki", label: "Eastern European Time (EET)" },
          { value: "Asia/Tokyo", label: "Japan Standard Time (JST)" },
          { value: "Australia/Sydney", label: "Australian Eastern Time (AET)" },
        ];

        // Initialize socials object if it doesn't exist
        if (!user.socials) {
          user.socials = {};
        }

        // Render settings page
        return reply.view("settings.njk", {
          pageTitle: "User Settings",
          settingsActive: true,
          user,
          timeZones,
          success: request.query.success,
          error: request.query.error,
        });
      } catch (error) {
        logger.error("Web", `Error serving settings page: ${error.message}`);
        return reply.code(500).send("Error loading settings page");
      }
    }
  );

  // Profile settings update endpoint
  fastify.post(
    "/settings/profile",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Extract values from form data
        const displayName = getFieldValue(request.body.display_name);
        const userName = getFieldValue(request.body.user_name);
        const email = getFieldValue(request.body.email);
        const timeZone = getFieldValue(request.body.timeZone);

        // Update user parameters
        await updateUserParameter(user.user_id, "display_name", displayName);
        await updateUserParameter(user.user_id, "user_name", userName);

        if (email) {
          await updateUserParameter(user.user_id, "email", email);
        }

        if (timeZone) {
          await updateUserParameter(user.user_id, "timeZone", timeZone);
        }

        return reply.send({
          success: true,
          message: "Profile settings updated successfully",
        });
      } catch (error) {
        logger.error(
          "Web",
          `Error updating profile settings: ${error.message}`
        );
        return reply.code(500).send({
          success: false,
          error: "An error occurred while updating profile settings",
        });
      }
    }
  );

  // Social media settings update endpoint
  fastify.post(
    "/settings/socials",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Ensure socials object exists in user record
        if (!user.socials) {
          await updateUserParameter(user.user_id, "socials", {});
        }

        // Build the socials object
        const socials = {};

        // Process each social media platform
        const platforms = [
          "twitter",
          "tiktok",
          "youtube",
          "instagram",
          "twitch",
          "kick",
        ];

        for (const platform of platforms) {
          socials[platform] = getFieldValue(
            request.body[`socials[${platform}]`]
          );
        }

        // Update user parameter
        await updateUserParameter(user.user_id, "socials", socials);

        return reply.send({
          success: true,
          message: "Social media settings updated successfully",
        });
      } catch (error) {
        logger.error(
          "Web",
          `Error updating social media settings: ${error.message}`
        );
        return reply.code(500).send({
          success: false,
          error: "An error occurred while updating social media settings",
        });
      }
    }
  );
  // Password update endpoint
  fastify.post(
    "/settings/password",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Extract values from form data
        const currentPassword = getFieldValue(request.body.current_password);
        const newPassword = getFieldValue(request.body.new_password);
        const confirmPassword = getFieldValue(request.body.confirm_password);

        // Validate passwords
        if (newPassword !== confirmPassword) {
          return reply.code(400).send({
            success: false,
            error: "New passwords do not match",
          });
        }

        // Check if password is already set
        if (!user.webPasswordHash || !user.webPasswordSalt) {
          // No password set yet, just set the new one
          const passwordData = await hashPassword(newPassword);

          await updateUserParameter(
            user.user_id,
            "webPasswordHash",
            passwordData.hash
          );
          await updateUserParameter(
            user.user_id,
            "webPasswordSalt",
            passwordData.salt
          );
          await updateUserParameter(
            user.user_id,
            "webPasswordIterations",
            passwordData.iterations
          );

          return reply.send({
            success: true,
            message: "Password set successfully",
          });
        }

        // Verify current password
        const iterations = user.webPasswordIterations || 20480;
        const passwordCorrect = await isPasswordCorrect(
          user.webPasswordHash,
          user.webPasswordSalt,
          iterations,
          currentPassword
        );

        if (!passwordCorrect) {
          return reply.code(401).send({
            success: false,
            error: "Current password is incorrect",
          });
        }

        // Set new password
        const passwordData = await hashPassword(newPassword);

        await updateUserParameter(
          user.user_id,
          "webPasswordHash",
          passwordData.hash
        );
        await updateUserParameter(
          user.user_id,
          "webPasswordSalt",
          passwordData.salt
        );
        await updateUserParameter(
          user.user_id,
          "webPasswordIterations",
          passwordData.iterations
        );

        return reply.send({
          success: true,
          message: "Password updated successfully",
        });
      } catch (error) {
        logger.error("Web", `Error updating password: ${error.message}`);
        return reply.code(500).send({
          success: false,
          error: "An error occurred while updating password",
        });
      }
    }
  );
  // Dashboard route
  fastify.get(
    "/dashboard",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Ensure we have proper defaults for all values the template uses
        const streamerConnected = !!user?.twitch_tokens?.streamer?.access_token;
        const botConnected = !!user?.twitch_tokens?.bot?.access_token;
        const streamerName = streamerConnected
          ? user.twitch_tokens.streamer.twitch_display_name || "Unknown"
          : "";
        const botName = botConnected
          ? user.twitch_tokens.bot.twitch_display_name || "Unknown"
          : "";

        // Set default stats
        const stats = {
          chatMessages: 0,
        };

        // Try to get actual chat count
        try {
          const recentChats = await getChatCount(user.user_id);
          stats.chatMessages = recentChats || 0;
        } catch (error) {
          logger.error("Web", `Error fetching chat stats: ${error.message}`);
        }

        // Always initialize streamStatus with default values for all properties
        let streamStatus = {
          online: false,
          title: "",
          game: "",
          viewers: 0,
          duration: "",
          thumbnail: null,
        };

        let followerCount = user.current_followers || 0;
        let lastGame = user.current_game?.game || "None";

        if (user.twitch_tokens?.streamer?.twitch_user_id) {
          try {
            const { fetchStreamInfo } = await import(
              "../twitch-eventsub-manager.js"
            );
            const streamInfo = await fetchStreamInfo(user.user_id);

            if (streamInfo && streamInfo.success && streamInfo.isLive) {
              // Update streamStatus with actual values
              streamStatus = {
                online: true,
                title: streamInfo.data.title || "Untitled Stream",
                game: streamInfo.data.gameName || "Unknown Game",
                viewers: streamInfo.data.viewerCount || 0,
                duration: streamInfo.data.duration || "Just started",
                thumbnail: streamInfo.data.thumbnailUrl || null,
              };
            }

            followerCount = user.current_followers || 0;
          } catch (error) {
            logger.error("Web", `Error fetching stream info: ${error.message}`);
          }
        }

        // Log complete data being sent to template
        logger.log(
          "Web",
          `Rendering dashboard with streamStatus: ${JSON.stringify(streamStatus)}`
        );

        return reply.view("dashboard.njk", {
          pageTitle: "Dashboard",
          dashboardActive: true,
          user: {
            display_name: user.display_name || user.user_name,
          },
          streamerConnected,
          botConnected,
          streamerName,
          botName,
          stats,
          streamStatus,
          followerCount,
          lastGame,
        });
      } catch (error) {
        logger.error("Web", `Error serving dashboard: ${error.message}`);
        return reply.code(500).send("Error loading dashboard");
      }
    }
  );

  // Character editor route
  fastify.get(
    "/character",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Load character data from files
        const characterPersonality = await loadTextContent(
          user.user_id,
          "character_personality"
        );
        const characterDescription = await loadTextContent(
          user.user_id,
          "character_card"
        );
        const characterExamples = await loadTextContent(
          user.user_id,
          "examples"
        );

        return reply.view("character.njk", {
          pageTitle: "Character Editor",
          characterActive: true,
          user,
          character: user,
          characterPersonality,
          characterDescription,
          characterExamples,
        });
      } catch (error) {
        logger.error("Web", `Error serving character editor: ${error.message}`);
        return reply.code(500).send("Error loading character editor");
      }
    }
  );

  // World editor route
  fastify.get("/world", { preHandler: requireAuth }, async (request, reply) => {
    try {
      const user = request.user;

      // Load world data from files
      const worldInfo = await loadTextContent(user.user_id, "world_lore");
      const playerInfo = await loadTextContent(user.user_id, "player_info");
      const scenario = await loadTextContent(user.user_id, "scenario");

      // Format commands list and aux bots for textarea
      const commandsList = user.commands_list
        ? user.commands_list.join("\n")
        : "";
      const auxBots = user.aux_bots ? user.aux_bots.join("\n") : "";

      return reply.view("world.njk", {
        pageTitle: "World Editor",
        worldActive: true,
        user,
        character: user,
        worldInfo,
        playerInfo,
        scenario,
        commandsList,
        auxBots,
      });
    } catch (error) {
      logger.error("Web", `Error serving world editor: ${error.message}`);
      return reply.code(500).send("Error loading world editor");
    }
  });

  // Help page route
  fastify.get("/help", { preHandler: requireAuth }, async (request, reply) => {
    try {
      return reply.view("help.njk", {
        pageTitle: "Help & Documentation",
        helpActive: true,
      });
    } catch (error) {
      logger.error("Web", `Error serving help page: ${error.message}`);
      return reply.code(500).send(`Error loading help page: ${error.message}`);
    }
  });

  // Gallery route
  fastify.get(
    "/gallery",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Load all character presets
        const presets = await loadAllPresets();

        // Add placeholder images for presets that don't have one
        presets.forEach((preset) => {
          if (!preset.image) {
            preset.image = "/api/placeholder/200/200";
          }
        });

        return reply.view("gallery.njk", {
          pageTitle: "Character Gallery",
          galleryActive: true,
          presets,
          user,
        });
      } catch (error) {
        logger.error("Web", `Error serving gallery: ${error.message}`);
        return reply.code(500).send("Error loading character gallery");
      }
    }
  );

  fastify.get(
    "/gallery/:characterId",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;
        const { characterId } = request.params;

        // Load the character preset data
        const characterData = await loadPreset(characterId);

        if (!characterData) {
          logger.warn("Web", `Character preset '${characterId}' not found`);
          return reply.redirect("/web/gallery");
        }

        // Add placeholder image if missing
        if (!characterData.image) {
          characterData.image = "/api/placeholder/200/200";
        }

        return reply.view("character-details.njk", {
          pageTitle: characterData.name,
          galleryActive: true,
          character: characterData,
          user,
        });
      } catch (error) {
        logger.error(
          "Web",
          `Error serving character details: ${error.message}`
        );
        return reply.code(500).send("Error loading character details");
      }
    }
  );

  // Authentication routes
  fastify.get("/auth/login", async (request, reply) => {
    return reply.view("login.njk", {
      pageTitle: "Login",
      error: request.query.error || null,
    });
  });

  fastify.get("/auth/logout", async (request, reply) => {
    reply.clearCookie("enspira_session");
    return reply.redirect("/web/auth/login");
  });

  // Redirect root to dashboard
  fastify.get("/", (request, reply) => {
    return reply.redirect("/web/dashboard");
  });
  
  logger.log("Web", "Web routes registered successfully");
}

export default webRoutes;
</file>

<file path="prompt-helper.js">
import fs from "fs-extra";
import moment from "moment";
import { socialMedias } from "./twitch-helper.js";
import { interpretEmotions } from "./data-helper.js";
import { returnAuthObject } from "./api-helper.js";
import {
  tokenizedFromRemote,
  promptTokenizedFromRemote,
} from "./token-helper.js";
import { retrieveConfigValue } from "./config-helper.js";
import { returnRecentChats } from "./ai-logic.js";
import {
  ChatRequestBody,
  ChatRequestBodyCoT,
  ToolRequestBody,
  QueryRequestBody,
  ModerationRequestBody,
  SummaryRequestBody,
} from "./oai-requests.js";
import { jsonrepair } from "jsonrepair";
import OpenAI from "openai";
import { performance } from "node:perf_hooks";
import { logger } from "./create-global-logger.js";
import { utils } from "./utils/index.js";

const { getTemplate } = utils.file;
const { replacePlaceholders } = utils.string;
const { withErrorHandling } = utils.error;

const templateCache = {};

/**
 * Helper function to extract all social media replacements for templates.
 * Gets both the full socials string and individual platform entries.
 *
 * @param {string} userId - The user ID
 * @returns {Promise<object>} - Object containing all social media replacements
 */
async function getSocialMediaReplacements(userId) {
  try {
    // Get the complete socials string for {{socials}} replacement
    const allSocials = await socialMedias(userId);

    // Create the base replacements object
    const replacements = {
      "{{socials}}": allSocials || "",
    };

    // Get all available platforms for the user
    const socialPlatforms = await socialMedias(userId, "all");

    // Add individual platform replacements
    for (const [platform, value] of Object.entries(socialPlatforms)) {
      if (value && value.trim() !== "") {
        replacements[`{{socials.${platform}}}`] = value;
      }
    }

    // Add specific commonly used platform shortcuts
    // These are kept for backward compatibility
    replacements["{{soc_tiktok}}"] =
      (await socialMedias(userId, "tiktok")) || "";
    replacements["{{soc_youtube}}"] =
      (await socialMedias(userId, "youtube")) || "";
    replacements["{{soc_twitter}}"] =
      (await socialMedias(userId, "twitter")) || "";
    replacements["{{soc_instagram}}"] =
      (await socialMedias(userId, "instagram")) || "";

    return replacements;
  } catch (error) {
    logger.log(
      "System",
      `Error getting social media replacements: ${error.message}`
    );
    return { "{{socials}}": "" };
  }
}

/**
 * Sends a chat completion request for tool tasks like query writing and reranking.
 * Simplified version without reasoning or chain-of-thought features.
 *
 * @param {object} requestBody - The request body for the completion.
 * @param {object} modelConfig - Configuration for the model.
 * @returns {Promise<object>} - The completion response.
 */
export async function sendToolCompletionRequest(requestBody, modelConfig) {
  const openai = new OpenAI({
    baseURL: modelConfig.endpoint,
    apiKey: modelConfig.apiKey,
  });

  const startTime = performance.now();
  let fullResponse = "";
  const MAX_RESPONSE_SIZE = 50000; // 50KB limit for tool responses

  try {
    const stream = await openai.chat.completions.create({
      ...requestBody,
      stream: true,
    });

    for await (const part of stream) {
      const content = part.choices[0]?.delta?.content;
      if (content) {
        // Add content to full response, but check size limit
        fullResponse += content;

        // If exceeded max size, stop processing stream
        if (fullResponse.length > MAX_RESPONSE_SIZE) {
          logger.log(
            "API",
            `Tool response exceeded ${MAX_RESPONSE_SIZE / 1000}KB limit, truncating`
          );
          break; // Exit the loop to stop processing more tokens
        }
      }
    }

    // Calculate total processing time
    const totalTime = (performance.now() - startTime) / 1000;

    // For JSON responses, make sure we have valid JSON
    if (requestBody.response_format?.type === "json_schema") {
      // Check if the response is already an object
      if (typeof fullResponse === "object" && fullResponse !== null) {
        return {
          response: fullResponse,
          rawResponse: JSON.stringify(fullResponse),
          processingTime: totalTime.toFixed(3),
        };
      }

      try {
        // Try parsing the JSON response
        const jsonResponse = JSON.parse(fullResponse);
        return {
          response: jsonResponse,
          rawResponse: fullResponse,
          processingTime: totalTime.toFixed(3),
        };
      } catch (jsonError) {
        // If JSON parsing fails, try to fix it using jsonrepair
        try {
          const fixedResponse = jsonrepair(fullResponse);
          const jsonResponse = JSON.parse(fixedResponse);

          logger.log("API", "Fixed malformed JSON in tool response");

          return {
            response: jsonResponse,
            rawResponse: fixedResponse,
            processingTime: totalTime.toFixed(3),
            jsonFixed: true,
          };
        } catch (repairError) {
          // If repair also fails, return error
          logger.log(
            "API",
            `Failed to parse JSON response: ${jsonError.message}`
          );
          return {
            error: "JSON parsing failed",
            rawResponse: fullResponse.substring(0, 1000),
            processingTime: totalTime.toFixed(3),
          };
        }
      }
    }

    // For non-JSON responses, just return the content
    return {
      response: fullResponse,
      processingTime: totalTime.toFixed(3),
    };
  } catch (error) {
    logger.log(
      "API",
      `Tool completion error: ${error}; Model: ${modelConfig.model}`
    );
    return { error: error.message };
  }
}
export async function sendChatCompletionRequest(
  requestBody,
  modelConfig,
  userObj = null
) {
  const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

  try {
    // DIAGNOSTIC: Validate model configuration
    logger.log("API", `[${requestId}] Starting chat completion request`);
    logger.log("API", `[${requestId}] Model config validation:`, {
      hasEndpoint: !!modelConfig?.endpoint,
      hasApiKey: !!modelConfig?.apiKey,
      hasModel: !!modelConfig?.model,
      endpoint: modelConfig?.endpoint || "MISSING",
      model: modelConfig?.model || "MISSING",
      apiKeyLength: modelConfig?.apiKey?.length || 0,
    });

    if (!modelConfig) {
      throw new Error("Model configuration is null or undefined");
    }

    if (!modelConfig.endpoint) {
      throw new Error("Model endpoint is missing from configuration");
    }

    if (!modelConfig.apiKey) {
      throw new Error("Model API key is missing from configuration");
    }

    if (!modelConfig.model) {
      throw new Error("Model name is missing from configuration");
    }

    // DIAGNOSTIC: Validate request body
    logger.log("API", `[${requestId}] Request body validation:`, {
      hasMessages: !!requestBody?.messages,
      messageCount: requestBody?.messages?.length || 0,
      hasModel: !!requestBody?.model,
      hasStream: requestBody?.stream !== undefined,
      requestBodyKeys: Object.keys(requestBody || {}),
    });

    if (
      !requestBody ||
      !requestBody.messages ||
      !Array.isArray(requestBody.messages)
    ) {
      throw new Error(
        "Invalid request body: missing or invalid messages array"
      );
    }

    if (requestBody.messages.length === 0) {
      throw new Error("Request body has empty messages array");
    }

    // DIAGNOSTIC: Log the actual request that will be sent
    logger.log("API", `[${requestId}] Request details:`, {
      endpoint: modelConfig.endpoint,
      model: requestBody.model || modelConfig.model,
      messageCount: requestBody.messages.length,
      stream: requestBody.stream,
      temperature: requestBody.temperature,
      max_tokens: requestBody.max_tokens,
    });

    // Create OpenAI client with enhanced configuration
    const openaiConfig = {
      baseURL: modelConfig.endpoint,
      apiKey: modelConfig.apiKey,
      timeout: 60000, // 60 second timeout
      maxRetries: 0, // We'll handle retries manually
    };

    logger.log(
      "API",
      `[${requestId}] Creating OpenAI client with baseURL: ${modelConfig.endpoint}`
    );

    const openai = new OpenAI(openaiConfig);

    const startTime = performance.now();
    let firstTokenTimeElapsed = null;
    let backendStartTime;
    let fullResponse = "";
    let thinkingStuff = "";
    const MAX_RESPONSE_SIZE = 100000; // 100KB limit

    // DIAGNOSTIC: Save request body for debugging
    try {
      await fs.writeJSON(
        `./debug-chat-request-${requestId}.json`,
        {
          requestId,
          timestamp: new Date().toISOString(),
          requestBody,
          modelConfig: {
            endpoint: modelConfig.endpoint,
            model: modelConfig.model,
            hasApiKey: !!modelConfig.apiKey,
            apiKeyLength: modelConfig.apiKey?.length,
          },
        },
        { spaces: 2 }
      );
    } catch (debugError) {
      logger.warn(
        "API",
        `[${requestId}] Could not save debug file: ${debugError.message}`
      );
    }

    logger.log("API", `[${requestId}] Sending request to vLLM...`);

    // ENHANCED: Create the completion request with better error handling
    let stream;
    try {
      stream = await openai.chat.completions.create({
        ...requestBody,
        stream: true,
      });

      logger.log(
        "API",
        `[${requestId}] Successfully created stream connection to vLLM`
      );
    } catch (streamError) {
      logger.error("API", `[${requestId}] Failed to create stream to vLLM:`, {
        error: streamError.message,
        code: streamError.code,
        status: streamError.status,
        type: streamError.type,
      });

      // Try to provide more specific error information
      if (streamError.message.includes("ECONNREFUSED")) {
        throw new Error(
          `Cannot connect to vLLM at ${modelConfig.endpoint} - connection refused. Is vLLM running?`
        );
      } else if (streamError.message.includes("ENOTFOUND")) {
        throw new Error(
          `Cannot resolve hostname for vLLM endpoint: ${modelConfig.endpoint}`
        );
      } else if (streamError.message.includes("timeout")) {
        throw new Error(
          `Connection to vLLM timed out at ${modelConfig.endpoint}`
        );
      } else if (streamError.status === 401) {
        throw new Error(`Authentication failed with vLLM - check your API key`);
      } else if (streamError.status === 404) {
        throw new Error(`vLLM endpoint not found: ${modelConfig.endpoint}`);
      } else {
        throw new Error(`vLLM connection error: ${streamError.message}`);
      }
    }

    logger.log("API", `[${requestId}] Processing response stream...`);

    // Process the stream
    try {
      for await (const part of stream) {
        const content = part.choices[0]?.delta?.content;
        const thinkContent = part.choices[0]?.delta?.reasoning_content
        if (content) {
          if (firstTokenTimeElapsed === null) {
            // Calculate time to first token in seconds
            firstTokenTimeElapsed = (performance.now() - startTime) / 1000;
            // Start backend timer after first token arrives
            backendStartTime = performance.now();
            logger.log(
              "API",
              `[${requestId}] First token received after ${firstTokenTimeElapsed.toFixed(3)} seconds`
            );
          }

          // Add content to full response, but check size limit
          fullResponse += content;
          // Check if response is getting too large (warn at 50KB)
          if (fullResponse.length > 50000 && fullResponse.length < 51000) {
            logger.log(
              "API",
              `[${requestId}] Response size over 50KB, approaching limits`
            );
          }

          // If exceeded max size, stop processing stream - prevents memory issues
          if (fullResponse.length > MAX_RESPONSE_SIZE) {
            logger.log(
              "API",
              `[${requestId}] Response exceeded ${MAX_RESPONSE_SIZE / 1000}KB limit, truncating`
            );
            fullResponse += "\n\n[Response truncated due to length limits]";
            break; // Exit the loop to stop processing more tokens
          }
        } else if (thinkContent) {
          if (firstTokenTimeElapsed === null) {
            // Calculate time to first token in seconds
            firstTokenTimeElapsed = (performance.now() - startTime) / 1000;
            // Start backend timer after first token arrives
            backendStartTime = performance.now();
            logger.log(
              "API",
              `[${requestId}] First thought token received after ${firstTokenTimeElapsed.toFixed(3)} seconds`
            );
          }

          // Add content to full response, but check size limit
          thinkingStuff += thinkContent;
          // Check if response is getting too large (warn at 50KB)
          if (thinkingStuff.length > 50000 && thinkingStuff.length < 51000) {
            logger.log(
              "API",
              `[${requestId}] Response size over 50KB, approaching limits`
            );
          }

          // If exceeded max size, stop processing stream - prevents memory issues
          if (thinkingStuff.length > MAX_RESPONSE_SIZE) {
            logger.log(
              "API",
              `[${requestId}] Response exceeded ${MAX_RESPONSE_SIZE / 1000}KB limit, truncating`
            );
            thinkingStuff += "\n\n[Response truncated due to length limits]";
            break; // Exit the loop to stop processing more tokens
          }
        }
      }
    } catch (streamProcessError) {
      logger.error("API", `[${requestId}] Error processing stream:`, {
        error: streamProcessError.message,
        responseLength: fullResponse.length,
      });

      if (fullResponse.length === 0 || thinkingStuff.length === 0
      ) {
        throw new Error(
          `Stream processing failed: ${streamProcessError.message}`
        );
      } else {
        logger.warn(
          "API",
          `[${requestId}] Stream ended with error but got partial response (${fullResponse.length} chars)`
        );
      }
    }

    // Calculate backend processing time in seconds
    const backendTimeElapsed = backendStartTime
      ? (performance.now() - backendStartTime) / 1000
      : 0;

    logger.log("API", `[${requestId}] Response completed:`, {
      responseLength: fullResponse.length,
      thoughtResponseLength: thinkingStuff.length,
      firstTokenTime: firstTokenTimeElapsed?.toFixed(3),
      totalTime: ((performance.now() - startTime) / 1000).toFixed(3),
      backendTime: backendTimeElapsed.toFixed(3),
    });

    // Validate we got a response
    if (!fullResponse || fullResponse.trim() === "") {
      throw new Error("Received empty response from vLLM");
    }

    // Tokenize the full response (use simpler calculation if tokenization fails)
    let generatedTokens;
    try {
      generatedTokens = await tokenizedFromRemote(fullResponse);
    } catch (tokenizationError) {
      logger.warn(
        "API",
        `[${requestId}] Tokenization failed: ${tokenizationError.message}`
      );
      // Fallback to character-based estimation
      generatedTokens = Math.ceil(fullResponse.length / 4);
    }

    let backendTokensPerSecond = 0;
    if (backendTimeElapsed > 0 && generatedTokens > 0) {
      backendTokensPerSecond = (generatedTokens / backendTimeElapsed).toFixed(
        2
      );
    }
    await fs.writeJSON(
    `./cmp-chat-request-${requestId}.json`,
    {
      response: fullResponse,
      thinking: thinkingStuff
    })
    // Enhanced thought process extraction
    let thoughtProcess = "";
    let finalResponse = "";

    // Check for thought tags and determine pattern
    const startTag = "<think>";
    const endTag = " </think>";
    const startTagIndex = fullResponse.indexOf(startTag);
    const endTagIndex = fullResponse.indexOf(endTag);
    
    // Case 1: Standard format with both <think> and </think>
    if (
      startTagIndex !== -1 &&
      endTagIndex !== -1 &&
      endTagIndex > startTagIndex
    ) {
      thoughtProcess = fullResponse
        .substring(startTagIndex + startTag.length, endTagIndex)
        .trim();
      finalResponse = fullResponse
        .substring(endTagIndex + endTag.length)
        .trim();
    }
    // Case 2: Only </think> exists (no opening tag)
    else if (startTagIndex === -1 && endTagIndex !== -1) {
      thoughtProcess = fullResponse.substring(0, endTagIndex).trim();
      finalResponse = fullResponse
        .substring(endTagIndex + endTag.length)
        .trim();
    }
    // Case 3: Multiple thought segments or complex pattern
    else if (fullResponse.includes(" \n</think>")) {
      // Initialize markers
      let currentPos = 0;
      let thoughts = [];
      let lastEndTagPos = -1;

      // Iterate through finding all segments
      while (true) {
        const nextStartTag = fullResponse.indexOf(startTag, currentPos);
        const nextEndTag = fullResponse.indexOf(endTag, currentPos);

        // No more tags found
        if (nextEndTag === -1) break;

        // Found a new segment
        lastEndTagPos = nextEndTag;

        // If we found a start tag and it comes before the end tag
        if (nextStartTag !== -1 && nextStartTag < nextEndTag) {
          thoughts.push(
            fullResponse
              .substring(nextStartTag + startTag.length, nextEndTag)
              .trim()
          );
          currentPos = nextEndTag + endTag.length;
        }
        // If we only found an end tag (or the end tag comes first)
        else {
          // If this is the first segment and there's no start tag, capture from beginning
          if (thoughts.length === 0 && nextStartTag === -1) {
            thoughts.push(fullResponse.substring(0, nextEndTag).trim());
          } else {
            // Otherwise capture from current position to end tag
            thoughts.push(
              fullResponse.substring(currentPos, nextEndTag).trim()
            );
          }
          currentPos = nextEndTag + endTag.length;
        }
      }

      // Combine all thought segments
      thoughtProcess = thoughts.join("\n");

      // Final response is everything after the last </think>
      if (lastEndTagPos !== -1) {
        finalResponse = fullResponse
          .substring(lastEndTagPos + endTag.length)
          .trim();
      } else {
        finalResponse = fullResponse; // Fallback to full response
      }
    }
    // Case 4: No think tags found
    else {
      finalResponse = fullResponse.trim();
    }

    logger.log("API", `[${requestId}] Request completed successfully:`, {
      finalResponseLength: finalResponse.length,
      thoughtProcessLength: thoughtProcess.length,
      tokensPerSecond: backendTokensPerSecond,
    });

    return {
      response: finalResponse,
      thoughtProcess,
      timeToFirstToken: firstTokenTimeElapsed
        ? firstTokenTimeElapsed.toFixed(3)
        : null,
      tokensPerSecond: backendTokensPerSecond,
      requestId: requestId,
      metadata: {
        totalTokens: generatedTokens,
        totalTime: ((performance.now() - startTime) / 1000).toFixed(3),
        endpoint: modelConfig.endpoint,
        model: requestBody.model || modelConfig.model,
      },
    };
  } catch (error) {
    logger.error("API", `[${requestId}] OpenAI chat completion error:`, {
      error: error.message,
      model: modelConfig?.model || "unknown",
      endpoint: modelConfig?.endpoint || "unknown",
      stack: error.stack,
    });

    return {
      error: error.message,
      requestId: requestId,
      details: {
        endpoint: modelConfig?.endpoint,
        model: modelConfig?.model,
        hasApiKey: !!modelConfig?.apiKey,
      },
    };
  }
}

export async function sendChatCompletionRequestCoT(requestBody, modelConfig) {
  const openai = new OpenAI({
    baseURL: modelConfig.endpoint,
    apiKey: modelConfig.apiKey,
  });

  const startTime = performance.now();
  let firstTokenTimeElapsed = null;
  let backendStartTime;
  let fullResponse = "";

  try {
    const stream = await openai.chat.completions.create({
      ...requestBody,
      stream: true,
    });

    for await (const part of stream) {
      const content = part.choices[0]?.delta?.content;
      if (content) {
        if (firstTokenTimeElapsed === null) {
          firstTokenTimeElapsed = (performance.now() - startTime) / 1000;
          backendStartTime = performance.now();
        }
        fullResponse += content;

        // Early warning for large responses
        if (fullResponse.length > 50000) {
          logger.log(
            "API",
            "CoT response is becoming very large, may cause issues with API returns"
          );
        }
      }
    }

    const backendTimeElapsed = (performance.now() - backendStartTime) / 1000;

    // Tokenize the full response
    let generatedTokens;
    try {
      generatedTokens = await tokenizedFromRemote(
        fullResponse,
        modelConfig.modelType
      );
    } catch (tokenizationError) {
      logger.log(
        "API",
        `Error tokenizing CoT response: ${tokenizationError}. Using character-based estimate.`
      );
      generatedTokens = Math.ceil(fullResponse.length / 4); // Rough estimate
    }

    let backendTokensPerSecond = 0;
    if (backendTimeElapsed > 0 && generatedTokens > 0) {
      backendTokensPerSecond = (generatedTokens / backendTimeElapsed).toFixed(
        2
      );
    }

    // Attempt to parse the JSON response with multiple fallback mechanisms
    let formattedResponse;
    let thoughtsArray = [];
    let fullOutput = null;

    try {
      // First attempt with regular JSON.parse
      try {
        formattedResponse = JSON.parse(fullResponse);
      } catch (initialParseError) {
        // If that fails, try jsonrepair
        logger.log(
          "API",
          `Initial JSON parse failed, trying jsonrepair: ${initialParseError.message}`
        );
        const fixedResponse = jsonrepair(fullResponse);
        formattedResponse = JSON.parse(fixedResponse);
      }

      // Process thoughts array safely
      if (formattedResponse.thoughts) {
        // If thoughts is already an array of strings
        if (Array.isArray(formattedResponse.thoughts)) {
          thoughtsArray = formattedResponse.thoughts.filter(
            (thought) => thought && thought !== ""
          );
        }
        // If thoughts is an array of objects with 'thought' property
        else if (
          Array.isArray(formattedResponse.thoughts) &&
          formattedResponse.thoughts.length > 0 &&
          formattedResponse.thoughts[0].thought
        ) {
          thoughtsArray = formattedResponse.thoughts
            .map((t) => t.thought)
            .filter((thought) => thought && thought !== "");
        } else {
          // Invalid format for thoughts, create a default
          logger.log(
            "API",
            "Invalid thoughts format in response, using empty array"
          );
          thoughtsArray = [];
        }
      }

      // Extract final response safely
      fullOutput =
        formattedResponse.final_response || formattedResponse.response || "";

      // Truncate if too long
      if (fullOutput && fullOutput.length > 100000) {
        logger.log(
          "API",
          `CoT response too large (${fullOutput.length} bytes), truncating`
        );
        fullOutput =
          fullOutput.substring(0, 100000) +
          "\n[Response truncated due to length...]";
      }
    } catch (parseError) {
      logger.log(
        "API",
        `Error parsing JSON response: ${parseError}; Response: ${fullResponse.substring(0, 500)}...`,
        "error"
      );

      // Last resort emergency parsing attempt
      try {
        // Try to extract anything that looks like a final response
        const finalResponseMatch = fullResponse.match(
          /"final_response"\s*:\s*"([^"]+)"/
        );
        if (finalResponseMatch && finalResponseMatch[1]) {
          fullOutput = finalResponseMatch[1];
        } else {
          fullOutput =
            "I apologize, but I encountered an error processing your message.";
        }

        // Log the parse failure
        logger.error(
          "API",
          `All JSON parsing attempts failed. Constructed basic response.`
        );
        thoughtsArray = ["Error parsing JSON response"];
      } catch (emergencyError) {
        logger.error(
          "API",
          `Emergency parsing also failed: ${emergencyError.message}`
        );
        return {
          error: `Error parsing JSON: ${parseError.message}`,
          rawResponse: fullResponse.substring(0, 1000),
        };
      }
    }

    return {
      response: fullOutput,
      thoughtProcess: thoughtsArray,
      timeToFirstToken: firstTokenTimeElapsed
        ? firstTokenTimeElapsed.toFixed(2)
        : null,
      tokensPerSecond: backendTokensPerSecond,
    };
  } catch (error) {
    logger.log(
      "API",
      `OpenAI chat completion error: ${error}; Model Config: ${JSON.stringify(modelConfig)}`,
      "error"
    );
    return { error: error.message };
  }
}

const moderatorPrompt = async (message, userId) => {
  const userObject = await returnAuthObject(userId);
  const instructTemplate = await withErrorHandling(
    () => getTemplate(`./instructs/helpers/moderation.prompt`),
    {
      context: "Templates",
      defaultValue: "",
      logError: true,
    }
  );
  // Get social media replacements with enhanced platform-specific support
  const socialReplacements = await getSocialMediaReplacements(userId);

  const replacements = {
    "{{user}}": userObject.user_name,
    "{{char}}": userObject.bot_name,
    "{{twitch}}": userObject.twitch_name,
    "{{modlist}}": userObject.mod_list.join("\n- "),
    "{{sites}}": userObject.approved_sites.join("\n- "),
    ...socialReplacements,
  };

  const instructionTemplate = replacePlaceholders(
    instructTemplate,
    replacements
  );
  const promptWithSamplers = await ModerationRequestBody.create(
    instructionTemplate,
    await retrieveConfigValue("models.moderator.model"),
    message
  );

  logger.log(
    "LLM",
    `Moderation prompt is using ${await promptTokenizedFromRemote(
      promptWithSamplers.messages
    )} of your available ${await retrieveConfigValue("models.moderator.maxTokens")} tokens.`
  );
  return promptWithSamplers;
};

/**
 * Generates a chat completion body with context, instructions, and message.
 * Enhanced with better support for social media templating.
 *
 * @param {object} promptData - Data containing relevant context, chats, and voice interactions.
 * @param {string} message - The user message.
 * @param {string} userID - The user ID.
 * @returns {Promise<object>} - The chat completion body.
 */
const contextPromptChat = async (promptData, message, userID) => {
  const currentAuthObject = await returnAuthObject(userID);
  const instructTemplate = await withErrorHandling(
    () => getTemplate(`./instructs/system.prompt`),
    {
      context: "Templates",
      defaultValue: "",
      logError: true,
    }
  );

  const timeStamp = moment().format("dddd, MMMM Do YYYY, [at] hh:mm A");

  // Load all necessary files in parallel for better performance
  const fileContents = await readPromptFiles(userID, [
    "character_personality",
    "world_lore",
    "scenario",
    "character_card",
    "weather",
    "twitch_chat",
    "player_info",
    "voice_messages",
  ]);

  const sentiment = await interpretEmotions(message);
  logger.log("LLM", `Analysis of emotions: ${sentiment}`);
  const user = promptData.chat_user;

  // Get social media replacements with enhanced platform-specific support
  const socialReplacements = await getSocialMediaReplacements(userID);

  // Common replacements for preprocessing text
  const commonReplacements = {
    "{{user}}": currentAuthObject.user_name,
    "{{char}}": currentAuthObject.bot_name,
    "{{char_limit}}": await retrieveConfigValue("twitch.maxCharLimit"),
    "{{chat_user}}": user,
    "{{model_author}}": await retrieveConfigValue("models.chat.author"),
    "{{model_org}}": await retrieveConfigValue("models.chat.organization"),
    // Add all social media replacements
    ...socialReplacements,
  };

  // Process system prompt
  const systemPrompt = replacePlaceholders(
    instructTemplate,
    commonReplacements
  );

  // Structure the prompt data in the format expected by the new ChatRequestBody
  const structuredPromptData = {
    systemPrompt: systemPrompt,

    // Character information
    characterDescription: fileContents.character_card
      ? `# ${currentAuthObject.bot_name}'s Description:\n${replacePlaceholders(fileContents.character_card, commonReplacements)}`
      : null,

    characterPersonality: fileContents.character_personality
      ? `# ${currentAuthObject.bot_name}'s Personality:\n${replacePlaceholders(fileContents.character_personality, commonReplacements)}`
      : null,

    // World information
    worldInfo: fileContents.world_lore
      ? `# World Information:\nUse this information to reflect the world and context around ${currentAuthObject.bot_name}:\n${replacePlaceholders(fileContents.world_lore, commonReplacements)}`
      : null,

    // Scenario
    scenario: fileContents.scenario
      ? `# Scenario:\n${replacePlaceholders(fileContents.scenario, commonReplacements)}`
      : null,

    // Player information
    playerInfo: fileContents.player_info
      ? `# Information about ${currentAuthObject.user_name}:\nThis is pertinent information regarding ${currentAuthObject.user_name} that you should always remember.\n${replacePlaceholders(fileContents.player_info, commonReplacements)}`
      : null,

    // Current chat messages
    recentChat: `# Current Messages from Chat:\nUp to the last ${await retrieveConfigValue("twitch.maxChatsToSave")} messages are provided to you from ${currentAuthObject.user_name}'s Twitch chat. Use these messages to keep up with the current conversation:\n${await returnRecentChats(userID)}`,

    // Weather information
    weatherInfo:
      currentAuthObject.weather && fileContents.weather
        ? `# Current Weather:\n${replacePlaceholders(fileContents.weather, commonReplacements)}`
        : null,

    // Additional context elements
    additionalContext: {
      // Relevant context search results if available
      contextResults: promptData.relContext
        ? `# Additional Information:\nExternal context relevant to the conversation:\n${promptData.relContext}`
        : null,

      // Relevant chat history if available
      chatHistory: promptData.relChats
        ? `# Other Relevant Chat Context:\nBelow are potentially relevant chat messages sent previously, that may be relevant to the conversation:\n${promptData.relChats}`
        : null,

      // Voice interactions if available
      voiceInteractions: promptData.relVoice
        ? `# Previous Voice Interactions:\nNon-exhaustive list of prior vocal interactions you've had with ${currentAuthObject.user_name}:\n${promptData.relVoice}`
        : null,

      // Recent voice messages if available
      recentVoice: fileContents.voice_messages
        ? `# Current Voice Conversations with ${currentAuthObject.user_name}:\nUp to the last ${await retrieveConfigValue("twitch.maxChatsToSave")} voice messages are provided to you. Use these voice messages to help you keep up with the current conversation:\n${fileContents.voice_messages}`
        : null,

      // Emotional assessment
      emotionalAssessment: sentiment
        ? `# Current Emotional Assessment of Message:\n- ${sentiment}`
        : null,

      // Current date/time
      dateTime: `# Current Date and Time:\n- The date and time where you and ${currentAuthObject.user_name} live is currently: ${timeStamp}`,
    },

    // The actual user message
    userMessage: `${promptData.chat_user} says: "${message}"`,
  };

  // Create the chat request body with our structured prompt data
  const promptWithSamplers = await ChatRequestBody.create(structuredPromptData);

  logger.log(
    "LLM",
    `Chat prompt is using ${await promptTokenizedFromRemote(
      promptWithSamplers.messages
    )} of your available ${await retrieveConfigValue(
      "models.chat.maxTokens"
    )} tokens.`
  );

  return promptWithSamplers;
};

const contextPromptChatCoT = async (promptData, message, userID) => {
  const currentAuthObject = await returnAuthObject(userID);
  const instructTemplate = await withErrorHandling(
    () => getTemplate(`./instructs/system_cot.prompt`),
    {
      context: "Templates",
      defaultValue: "",
      logError: true,
    }
  );
  const timeStamp = moment().format("dddd, MMMM Do YYYY, [at] hh:mm A");

  // Load all necessary files in parallel for better performance
  const fileContents = await readPromptFiles(userID, [
    "character_personality",
    "world_lore",
    "scenario",
    "character_card",
    "weather",
    "twitch_chat",
    "player_info",
    "voice_messages",
  ]);

  const sentiment = await interpretEmotions(message);
  logger.log("LLM", `Analysis of emotions: ${sentiment}`);

  // Get social media replacements with enhanced platform-specific support
  const socialReplacements = await getSocialMediaReplacements(userID);

  // Common replacements for preprocessing text
  const commonReplacements = {
    "{{user}}": currentAuthObject.user_name,
    "{{char}}": currentAuthObject.bot_name,
    "{{char_limit}}": await retrieveConfigValue("twitch.maxCharLimit"),
    "{{chat_user}}": promptData.user,
    "{{model_author}}": await retrieveConfigValue("models.chat.author"),
    "{{model_org}}": await retrieveConfigValue("models.chat.organization"),
    // Add all social media replacements
    ...socialReplacements,
  };

  // Process system prompt and add CoT instructions
  let systemPrompt = replacePlaceholders(instructTemplate, commonReplacements);

  // Structure the prompt data in the format expected by the ChatRequestBodyCoT
  const structuredPromptData = {
    systemPrompt: systemPrompt,

    // Character information
    characterDescription: fileContents.character_card
      ? `# ${currentAuthObject.bot_name}'s Description:\n${replacePlaceholders(fileContents.character_card, commonReplacements)}`
      : null,

    characterPersonality: fileContents.character_personality
      ? `# ${currentAuthObject.bot_name}'s Personality:\n${replacePlaceholders(fileContents.character_personality, commonReplacements)}`
      : null,

    // World information
    worldInfo: fileContents.world_lore
      ? `# World Information:\nUse this information to reflect the world and context around ${currentAuthObject.bot_name}:\n${replacePlaceholders(fileContents.world_lore, commonReplacements)}`
      : null,

    // Scenario
    scenario: fileContents.scenario
      ? `# Scenario:\n${replacePlaceholders(fileContents.scenario, commonReplacements)}`
      : null,

    // Player information
    playerInfo: fileContents.player_info
      ? `# Information about ${currentAuthObject.user_name}:\nThis is pertinent information regarding ${currentAuthObject.user_name} that you should always remember.\n${replacePlaceholders(fileContents.player_info, commonReplacements)}`
      : null,

    // Current chat messages
    recentChat: `# Current Messages from Chat:\nUp to the last ${await retrieveConfigValue("twitch.maxChatsToSave")} messages are provided to you from ${currentAuthObject.user_name}'s Twitch chat. Use these messages to keep up with the current conversation:\n${await returnRecentChats(userID)}`,

    // Weather information
    weatherInfo:
      currentAuthObject.weather && fileContents.weather
        ? `# Current Weather:\n${replacePlaceholders(fileContents.weather, commonReplacements)}`
        : null,

    // Additional context elements
    additionalContext: {
      // Relevant context search results if available
      contextResults: promptData.relContext
        ? `# Additional Information:\nExternal context relevant to the conversation:\n${promptData.relContext}`
        : null,

      // Relevant chat history if available
      chatHistory: promptData.relChats
        ? `# Other Relevant Chat Context:\nBelow are potentially relevant chat messages sent previously, that may be relevant to the conversation:\n${promptData.relChats}`
        : null,

      // Voice interactions if available
      voiceInteractions: promptData.relVoice
        ? `# Previous Voice Interactions:\nNon-exhaustive list of prior vocal interactions you've had with ${currentAuthObject.user_name}:\n${promptData.relVoice}`
        : null,

      // Recent voice messages if available
      recentVoice: fileContents.voice_messages
        ? `# Current Voice Conversations with ${currentAuthObject.user_name}:\nUp to the last ${await retrieveConfigValue("twitch.maxChatsToSave")} voice messages are provided to you. Use these voice messages to help you keep up with the current conversation:\n${fileContents.voice_messages}`
        : null,

      // Emotional assessment
      emotionalAssessment: sentiment
        ? `# Current Emotional Assessment of Message:\n- ${sentiment}`
        : null,

      // Current date/time
      dateTime: `# Current Date and Time:\n- The date and time where you and ${currentAuthObject.user_name} live is currently: ${timeStamp}`,
    },

    // The actual user message
    userMessage: `${promptData.chat_user} says: "message"`,

    // Flag for chain-of-thought processing
    isChainOfThought: true,
  };

  // Create the chat request body with our structured prompt data
  const promptWithSamplers =
    await ChatRequestBodyCoT.create(structuredPromptData);

  logger.log(
    "LLM",
    `Thoughtful chat prompt is using ${await promptTokenizedFromRemote(
      promptWithSamplers.messages
    )} of your available ${await retrieveConfigValue(
      "models.chat.maxTokens"
    )} tokens.`
  );

  return promptWithSamplers;
};

/**
 * Generates a chat completion body for event-based interactions.
 * Enhanced with better support for social media templating.
 *
 * @param {string} message - The event message.
 * @param {string} userId - The user ID.
 * @returns {Promise<object>} - The chat completion body.
 */
const eventPromptChat = async (message, userId) => {
  const userObject = await returnAuthObject(userId);
  logger.log(
    "System",
    `Doing eventing stuff for: ${userObject.user_name} and ${userId}`
  );

  const instructTemplate = await withErrorHandling(
    () => getTemplate(`./instructs/system.prompt`),
    {
      context: "Templates",
      defaultValue: "",
      logError: true,
    }
  );

  const timeStamp = moment().format("dddd, MMMM Do YYYY, [at] hh:mm A");

  // Load all necessary files in parallel for better performance
  const fileContents = await readPromptFiles(userId, [
    "character_personality",
    "world_lore",
    "scenario",
    "character_card",
    "weather",
    "player_info",
  ]);

  // Get social media replacements with enhanced platform-specific support
  const socialReplacements = await getSocialMediaReplacements(userId);

  // Common replacements for preprocessing text
  const commonReplacements = {
    "{{user}}": userObject.user_name,
    "{{char}}": userObject.bot_name,
    "{{char_limit}}": await retrieveConfigValue("twitch.maxCharLimit"),
    "{{model_author}}": await retrieveConfigValue("models.chat.author"),
    "{{model_org}}": await retrieveConfigValue("models.chat.organization"),
    // Add all social media replacements
    ...socialReplacements,
  };

  // Process system prompt
  const systemPrompt = replacePlaceholders(
    instructTemplate,
    commonReplacements
  );

  // Structure the prompt data in the format expected by the new ChatRequestBody
  const structuredPromptData = {
    systemPrompt: systemPrompt,

    // Character information
    characterDescription: fileContents.character_card
      ? `# ${userObject.bot_name}'s Description:\n${replacePlaceholders(fileContents.character_card, commonReplacements)}`
      : null,

    characterPersonality: fileContents.character_personality
      ? `# ${userObject.bot_name}'s Personality:\n${replacePlaceholders(fileContents.character_personality, commonReplacements)}`
      : null,

    // World information
    worldInfo: fileContents.world_lore
      ? `# World Information:\nUse this information to reflect the world and context around ${userObject.bot_name}:\n${replacePlaceholders(fileContents.world_lore, commonReplacements)}`
      : null,

    // Scenario
    scenario: fileContents.scenario
      ? `# Scenario:\n${replacePlaceholders(fileContents.scenario, commonReplacements)}`
      : null,

    // Player information
    playerInfo: fileContents.player_info
      ? `# Information about ${userObject.user_name}:\nThis is pertinent information regarding ${userObject.user_name} that you should always remember.\n${replacePlaceholders(fileContents.player_info, commonReplacements)}`
      : null,

    // Current chat messages
    recentChat: `# Current Messages from Chat:\nUp to the last ${await retrieveConfigValue("twitch.maxChatsToSave")} messages are provided to you from ${userObject.user_name}'s Twitch chat. Use these messages to keep up with the current conversation:\n${await returnRecentChats(userId)}`,

    // Weather information
    weatherInfo:
      userObject.weather && fileContents.weather
        ? `# Current Weather:\n${replacePlaceholders(fileContents.weather, commonReplacements)}`
        : null,

    // Additional context elements
    additionalContext: {
      // Current date/time
      dateTime: `# Current Date and Time:\n- The date and time where you and ${userObject.user_name} live is currently: ${timeStamp}`,
    },

    // The actual user message
    userMessage: message,
  };

  // Create the chat request body with our structured prompt data
  const promptWithSamplers = await ChatRequestBody.create(structuredPromptData);

  logger.log(
    "LLM",
    `Event handler prompt is using ${await promptTokenizedFromRemote(
      promptWithSamplers.messages
    )} of your available ${await retrieveConfigValue(
      "models.chat.maxTokens"
    )} tokens.`
  );

  return promptWithSamplers;
};

/**
 * Generates a prompt for querying information with specific parameters.
 *
 * @param {string} message - The query message.
 * @param {string} userId - The user ID.
 * @returns {Promise<object>} - The prompt with samplers for querying.
 */
const queryPrompt = async (message, userId) => {
  const userObject = await returnAuthObject(userId);
  const instructTemplate = await withErrorHandling(
    () => getTemplate(`./instructs/helpers/query.prompt`),
    {
      context: "Templates",
      defaultValue: "",
      logError: true,
    }
  );
  const timeStamp = moment().format("MM/DD/YY [at] HH:mm");
  const [dateString, timeString] = timeStamp.split(" at ");

  // Get social media replacements with enhanced platform-specific support
  const socialReplacements = await getSocialMediaReplacements(userId);

  const replacements = {
    "{{datetime}}": `${dateString}. The current time is ${timeString}`,
    "{{query}}": message,
    "{{user}}": userObject.user_name,
    "{{char}}": userObject.bot_name,
    ...socialReplacements,
  };

  const instructionTemplate = replacePlaceholders(
    instructTemplate,
    replacements
  );
  const promptWithSamplers = await QueryRequestBody.create(
    instructionTemplate,
    await retrieveConfigValue("models.query.model"),
    message + "\n/no_think"
  );

  logger.log(
    "LLM",
    `Search query prompt is using ${await promptTokenizedFromRemote(
      promptWithSamplers.messages
    )} of your available ${await retrieveConfigValue("models.query.maxTokens")} tokens.`
  );
  return promptWithSamplers;
};

/**
 * Generates a prompt for reranking search results based on a message.
 *
 * @param {string} message - The message for reranking.
 * @param {string} userId - The user ID.
 * @returns {Promise<object>} - The prompt with samplers for reranking.
 */
const rerankPrompt = async (message, userId) => {
  logger.log("Rerank", `Received message ${message}`);
  const userObject = await returnAuthObject(userId);
  const instructTemplate = await withErrorHandling(
    () => getTemplate(`./instructs/helpers/rerank.prompt`),
    {
      context: "Templates",
      defaultValue: "",
      logError: true,
    }
  );
  // Get social media replacements with enhanced platform-specific support
  const socialReplacements = await getSocialMediaReplacements(userId);

  const replacements = {
    "{{user}}": userObject.user_name,
    ...socialReplacements,
  };

  const instructionTemplate = replacePlaceholders(
    instructTemplate,
    replacements
  );
  const promptWithSamplers = await ToolRequestBody.create(
    instructionTemplate,
    await retrieveConfigValue("models.rerankTransform.model"),
    message
  );

  logger.log(
    "LLM",
    `Reranking prompt is using ${await promptTokenizedFromRemote(
      promptWithSamplers.messages
    )} of your available ${await retrieveConfigValue("models.rerankTransform.maxTokens")} tokens.`
  );
  return promptWithSamplers;
};

const summaryPrompt = async (textContent) => {
  const instructTemplate = await withErrorHandling(
    () => getTemplate(`./instructs/helpers/summary.prompt`),
    {
      context: "Templates",
      defaultValue: "",
      logError: true,
    }
  );
  const promptWithSamplers = await SummaryRequestBody.create(
    instructTemplate,
    await retrieveConfigValue("models.summary.model"),
    textContent
  );

  logger.log(
    "LLM",
    `Summary prompt is using ${await promptTokenizedFromRemote(
      promptWithSamplers.messages
    )} of your available ${await retrieveConfigValue("models.summary.maxTokens")} tokens.`
  );
  return promptWithSamplers;
};

/**
 * Reads multiple files and returns their contents in an object.
 *
 * @param {string} userId - The user ID.
 * @param {string[]} fileNames - An array of file names to read.
 * @returns {Promise<object>} - An object containing file names as keys and their contents as values.
 */
async function readPromptFiles(userId, fileNames) {
  const fileContents = {};
  await Promise.all(
    fileNames.map(async (fileName) => {
      const filePath = `./world_info/${userId}/${fileName}.txt`;
      try {
        fileContents[fileName] = await fs.readFile(filePath, "utf-8");
      } catch (error) {
        logger.log("Files", `Error reading file ${filePath}: ${error}`);
        fileContents[fileName] = ""; // Provide a default value or handle the error as needed
      }
    })
  );
  return fileContents;
}

/**
 * Strips specific patterns and extra whitespace from a message.
 *
 * @param {string} message - The message to be stripped.
 * @param {string} userId - The user ID.
 * @returns {Promise<string>} - The stripped message.
 */
const replyStripped = async (message, userId) => {
  const userObj = await returnAuthObject(userId);
  let formatted = message
    .replace(/(\r\n|\n|\r)/gm, " ") // Replace newlines with spaces
    .replace(new RegExp(`${userObj.bot_name}:\\s?`, "g"), "") // Remove bot's name followed by a colon and optional space
    .replace(/\(500 characters\)/g, "") // Remove (500 characters)
    .replace(/\\/g, "") // Remove backslashes
    .replace(/\p{Emoji_Presentation}|\p{Extended_Pictographic}/gu, "") // Remove only graphical emojis
    .replace(/\s+/g, " ") // Replace multiple spaces with a single space
    .replace("shoutout", "shout out");
  // Remove unmatched quotes ONLY at the beginning or end of the string
  formatted = formatted.replace(/^['"]|['"]$/g, ""); // Trim unmatched quotes at start and end

  return formatted.trim(); // Trim leading and trailing whitespace
};

/**
 * Transforms a string by replacing acronyms and specific file extensions with a modified format.
 *
 * @param {string} inputString - The string to transform.
 * @returns {Promise<object>} - An object containing the transformed string and the counts of acronyms and specific patterns found.
 */
const fixTTSString = async (inputString) => {
  const acronymRegex = /\b([A-Z]{2,})(?!\w)/g;
  const jsRegex = /\.js\b/gi;

  const exceptions = ["GOATs", "LOL", "LMAO"];

  let acronymCount = 0;
  let jsCount = 0;

  let transformedString = inputString.replace(acronymRegex, (match) => {
    if (exceptions.includes(match)) {
      return match; // Skip transformation for exceptions
    }

    acronymCount++;
    let transformed =
      match.slice(0, -1).split("").join(".") + "." + match.slice(-1);
    if (match.endsWith("S") && match.length > 2) {
      const base = match.slice(0, -1).split("").join(".");
      transformed = `${base}'s`;
    }
    return transformed;
  });

  transformedString = transformedString.replace(jsRegex, (match) => {
    jsCount++;
    return ".J.S";
  });

  return { fixedString: transformedString, acronymCount, jsCount };
};

/**
 * Filters out character names from a message based on a regular expression.
 *
 * @param {string} str - The message string.
 * @param {string} userId - The user ID.
 * @returns {Promise<string>} - The filtered message.
 */
const filterCharacterFromMessage = async (str, userId) => {
  const userObject = await returnAuthObject(userId);
  const twitchRegex = new RegExp(`@?${userObject.bot_twitch}`, "i");
  const nameRegex = new RegExp(
    `,?\\s*\\b(?:${userObject.bot_name}|hey ${userObject.bot_name})\\b,?\\s*`,
    "i"
  );

  let result = str.replace(twitchRegex, "").trim();
  result = result.replace(nameRegex, "").trim();

  return result;
};

/**
 * Helper function to escape special regex characters
 * @param {string} string - String to escape
 * @returns {string} - Escaped string safe for regex
 */
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

/**
 * Checks if a message contains the character's name or Twitch username.
 * Enhanced to handle multiple variations and better bot account detection.
 *
 * @param {string} message - The message to check.
 * @param {string} userId - The user ID.
 * @returns {Promise<boolean>} - True if the message contains the character's name or Twitch username, false otherwise.
 */
async function containsCharacterName(message, userId) {
  try {
    const userObj = await returnAuthObject(userId);

    if (!message || typeof message !== "string") {
      return false;
    }

    const normalizedMessage = message.toLowerCase().trim();

    // Get all possible name variations
    const namesToCheck = new Set();

    // Add character/bot name
    if (userObj.bot_name) {
      namesToCheck.add(userObj.bot_name.toLowerCase());
    }

    // Add Twitch bot username variations
    if (userObj.bot_twitch) {
      const botTwitch = userObj.bot_twitch.toLowerCase();
      namesToCheck.add(botTwitch);
      // Remove @ if present and add both versions
      const cleanBotTwitch = botTwitch.startsWith("@")
        ? botTwitch.slice(1)
        : botTwitch;
      namesToCheck.add(cleanBotTwitch);
      namesToCheck.add("@" + cleanBotTwitch);
    }

    // Add the actual bot account username from tokens if available
    if (userObj.twitch_tokens?.bot?.twitch_login) {
      const botLogin = userObj.twitch_tokens.bot.twitch_login.toLowerCase();
      namesToCheck.add(botLogin);
      namesToCheck.add("@" + botLogin);
    }

    if (userObj.twitch_tokens?.bot?.twitch_display_name) {
      const botDisplayName =
        userObj.twitch_tokens.bot.twitch_display_name.toLowerCase();
      namesToCheck.add(botDisplayName);
      namesToCheck.add("@" + botDisplayName);
    }

    // Also check against streamer account in case bot_twitch points to streamer
    if (userObj.twitch_tokens?.streamer?.twitch_login) {
      const streamerLogin =
        userObj.twitch_tokens.streamer.twitch_login.toLowerCase();
      namesToCheck.add(streamerLogin);
      namesToCheck.add("@" + streamerLogin);
    }

    // Remove empty/undefined entries
    const validNames = Array.from(namesToCheck).filter(
      (name) => name && name.length > 0
    );

    if (validNames.length === 0) {
      logger.warn(
        "Twitch",
        `No valid bot names found for user ${userId} when checking mentions`
      );
      return false;
    }

    // Check each name variation
    for (const nameToCheck of validNames) {
      // Exact word match (handles @mentions and regular mentions)
      const wordBoundaryRegex = new RegExp(
        `\\b${escapeRegExp(nameToCheck)}\\b`,
        "i"
      );
      if (wordBoundaryRegex.test(normalizedMessage)) {
        logger.log(
          "Twitch",
          `Character name detected: "${nameToCheck}" in message: "${message}"`
        );
        return true;
      }

      // Also check for @ mentions without word boundaries (for usernames with special chars)
      if (nameToCheck.startsWith("@")) {
        const atMentionRegex = new RegExp(`${escapeRegExp(nameToCheck)}`, "i");
        if (atMentionRegex.test(normalizedMessage)) {
          logger.log(
            "Twitch",
            `@ mention detected: "${nameToCheck}" in message: "${message}"`
          );
          return true;
        }
      }
    }

    return false;
  } catch (error) {
    logger.error(
      "Twitch",
      `Error checking character name in message: ${error.message}`
    );
    return false;
  }
}

/**
 * Checks if a message contains the player's social media identifiers.
 *
 * @param {string} message - The message to check.
 * @param {string} userId - The user ID.
 * @returns {Promise<boolean>} - True if the message contains the player's social media identifiers, false otherwise.
 */
async function containsPlayerSocials(message, userId) {
  const userObj = await returnAuthObject(userId);
  const nameRegex = new RegExp(userObj.twitch_name, "i");
  return nameRegex.test(message);
}

/**
 * Enhanced containsAuxBotName function with better bot detection
 * Checks if a message contains any of the auxiliary bot names.
 *
 * @param {string} message - The message to check.
 * @param {string} userId - The user ID.
 * @returns {Promise<boolean>} - True if the message contains any of the auxiliary bot names, false otherwise.
 */
async function containsAuxBotName(message, userId) {
  try {
    const userObj = await returnAuthObject(userId);

    if (
      !message ||
      typeof message !== "string" ||
      !Array.isArray(userObj.aux_bots)
    ) {
      return false;
    }

    const normalizedMessage = message.toLowerCase();

    // Check each aux bot name
    for (const botName of userObj.aux_bots) {
      if (!botName || typeof botName !== "string") continue;

      const normalizedBotName = botName.toLowerCase();

      // Check for exact word match
      const wordBoundaryRegex = new RegExp(
        `\\b${escapeRegExp(normalizedBotName)}\\b`,
        "i"
      );
      if (wordBoundaryRegex.test(normalizedMessage)) {
        logger.log(
          "Twitch",
          `Aux bot name detected: "${botName}" in message, ignoring`
        );
        return true;
      }

      // Also check with @ prefix
      const atBotName = "@" + normalizedBotName;
      const atMentionRegex = new RegExp(
        `\\b${escapeRegExp(atBotName)}\\b`,
        "i"
      );
      if (atMentionRegex.test(normalizedMessage)) {
        logger.log(
          "Twitch",
          `Aux bot @ mention detected: "${atBotName}" in message, ignoring`
        );
        return true;
      }
    }

    return false;
  } catch (error) {
    logger.error("Twitch", `Error checking aux bot names: ${error.message}`);
    return false;
  }
}

export {
  replyStripped,
  moderatorPrompt,
  containsAuxBotName,
  containsPlayerSocials,
  summaryPrompt,
  filterCharacterFromMessage,
  queryPrompt,
  contextPromptChat,
  contextPromptChatCoT,
  fixTTSString,
  rerankPrompt,
  eventPromptChat,
  containsCharacterName,
};
</file>

<file path="twitch-eventsub-manager.js">
import crypto from "crypto";
import axios from "axios";
import {
  returnAPIKeys,
  returnAuthObject,
  updateUserParameter,
  ensureParameterPath,
} from "./api-helper.js";
import { retrieveConfigValue } from "./config-helper.js";
import { logger } from "./create-global-logger.js";
import cron from "node-cron";

class TwitchAPIManager {
  constructor() {
    // Rate limit buckets with TTL and size limits
    this.buckets = new Map();
    this.maxBuckets = 100; // Prevent memory leaks
    
    // Track per-endpoint usage with cleanup
    this.endpointCounts = new Map();
    this.lastCleanup = Date.now();
    this.cleanupInterval = 60 * 60 * 1000; // 1 hour

    // Default retry settings
    this.defaultRetryConfig = {
      maxRetries: 3,
      initialDelay: 500,
      maxDelay: 10000,
      factor: 2,
      jitter: true,
    };

    // Start periodic cleanup
    this.startCleanupTimer();
  }

  /**
   * Periodic cleanup to prevent memory leaks
   */
  startCleanupTimer() {
    setInterval(() => {
      this.cleanupOldData();
    }, this.cleanupInterval);
  }

  /**
   * Clean up old rate limit data and endpoint counts
   */
  cleanupOldData() {
    const now = Date.now();
    
    // Clean up expired buckets
    for (const [key, bucket] of this.buckets.entries()) {
      if (now > bucket.resetAt + 300000) { // 5 minutes buffer
        this.buckets.delete(key);
      }
    }

    // Reset endpoint counts periodically
    if (this.endpointCounts.size > 1000) {
      this.endpointCounts.clear();
      logger.log("Twitch", "Cleaned up endpoint usage statistics");
    }

    // Ensure we don't exceed max buckets
    if (this.buckets.size > this.maxBuckets) {
      const oldestKeys = Array.from(this.buckets.keys()).slice(0, 10);
      oldestKeys.forEach(key => this.buckets.delete(key));
    }

    this.lastCleanup = now;
  }

  /**
   * Get or create rate limit bucket
   */
  getBucket(bucketType) {
    if (!this.buckets.has(bucketType)) {
      const bucket = {
        helix: {
          points: 800,
          remaining: 800,
          resetAt: Date.now() + 60000,
          perMinute: 800,
        },
        auth: {
          points: 120,
          remaining: 120,
          resetAt: Date.now() + 60000,
          perMinute: 120,
        },
      }[bucketType] || {
        points: 100,
        remaining: 100,
        resetAt: Date.now() + 60000,
        perMinute: 100,
      };
      
      this.buckets.set(bucketType, bucket);
    }
    
    return this.buckets.get(bucketType);
  }

  /**
   * Make a rate-limited API call with automatic retries and improved error handling
   */
  async makeRequest(config, bucketType = "helix", retryOptions = {}) {
    const endpoint = this.getEndpointFromUrl(config.url);
    this.trackEndpointUsage(endpoint);

    const retryConfig = { ...this.defaultRetryConfig, ...retryOptions };
    const bucket = this.getBucket(bucketType);

    // Check rate limits before proceeding
    await this.checkRateLimits(bucket);

    let lastError;
    let delay = retryConfig.initialDelay;

    for (let attempt = 0; attempt < retryConfig.maxRetries; attempt++) {
      try {
        const response = await axios({
          ...config,
          timeout: config.timeout || 15000, // Default timeout
        });

        // Update rate limit info from headers
        this.updateRateLimits(bucket, response.headers);
        return response;

      } catch (error) {
        lastError = error;

        // Handle different error types
        if (error.response?.status === 429) {
          const retryAfter = parseInt(error.response.headers["retry-after"] || "0") * 1000;
          delay = Math.max(retryAfter, this.calculateBackoff(attempt, retryConfig));
          
          logger.warn("Twitch", `Rate limited on ${endpoint}. Retrying in ${delay}ms`);
          
          bucket.remaining = 0;
          bucket.resetAt = Date.now() + retryAfter || delay;
          
        } else if (this.isRetryableError(error)) {
          delay = this.calculateBackoff(attempt, retryConfig);
          logger.warn("Twitch", `Retryable error on ${endpoint}: ${error.message}. Retry ${attempt + 1}/${retryConfig.maxRetries} in ${delay}ms`);
        } else {
          // Non-retryable error
          logger.error("Twitch", `Non-retryable error on ${endpoint}: ${error.message}`);
          throw error;
        }

        // Wait before retry
        if (attempt < retryConfig.maxRetries - 1) {
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
      }
    }

    throw lastError;
  }

  /**
   * Calculate backoff delay with jitter
   */
  calculateBackoff(attempt, config) {
    const baseDelay = config.initialDelay * Math.pow(config.factor, attempt);
    const maxDelay = config.maxDelay;

    if (config.jitter) {
      return Math.min(maxDelay, Math.random() * baseDelay);
    }

    return Math.min(maxDelay, baseDelay);
  }

  /**
   * Check if we should attempt to retry this error
   */
  isRetryableError(error) {
    // Network errors
    if (["ECONNRESET", "ETIMEDOUT", "ECONNABORTED", "ENOTFOUND"].includes(error.code)) {
      return true;
    }

    // Server errors (5xx) or rate limiting (429)
    if (error.response) {
      const status = error.response.status;
      return status >= 500 || status === 429;
    }

    return false;
  }

  /**
   * Update rate limit info from response headers
   */
  updateRateLimits(bucket, headers) {
    if (!headers) return;

    const remaining = headers["ratelimit-remaining"];
    const reset = headers["ratelimit-reset"];
    const limit = headers["ratelimit-limit"];

    if (remaining !== undefined) bucket.remaining = parseInt(remaining);
    if (limit !== undefined) bucket.points = parseInt(limit);
    if (reset !== undefined) bucket.resetAt = parseInt(reset) * 1000;
  }

  /**
   * Wait if we're close to hitting rate limits
   */
  async checkRateLimits(bucket) {
    const now = Date.now();

    // Reset bucket if time has passed
    if (now > bucket.resetAt) {
      bucket.remaining = bucket.points;
      bucket.resetAt = now + 60000;
      return;
    }

    // If close to limit (less than 10% remaining), delay the request
    if (bucket.remaining < bucket.points * 0.1) {
      const timeToReset = Math.max(0, bucket.resetAt - now);
      logger.warn("Twitch", `Approaching rate limit, delaying request by ${timeToReset}ms`);

      await new Promise((resolve) => setTimeout(resolve, timeToReset));
      bucket.remaining = bucket.points;
      bucket.resetAt = now + 60000;
    }

    bucket.remaining--;
  }

  /**
   * Extract endpoint from URL for tracking
   */
  getEndpointFromUrl(url) {
    try {
      const parsedUrl = new URL(url);
      const segments = parsedUrl.pathname.split("/").filter((s) => s);
      return segments.slice(0, 2).join("/");
    } catch (e) {
      return url;
    }
  }

  /**
   * Track usage per endpoint for analytics
   */
  trackEndpointUsage(endpoint) {
    const count = this.endpointCounts.get(endpoint) || 0;
    this.endpointCounts.set(endpoint, count + 1);
  }

  /**
   * Get usage statistics
   */
  getUsageStats() {
    return {
      buckets: Object.fromEntries(this.buckets),
      endpoints: Object.fromEntries(this.endpointCounts),
    };
  }
}

// Optimized subscription types with better organization
const SUBSCRIPTION_TYPES = [
  // Essential events - high priority
  {
    type: "channel.chat.message",
    version: "1",
    condition: (broadcasterId) => ({
      broadcaster_user_id: broadcasterId,
      user_id: broadcasterId,
    }),
    requiredScopes: ["channel:moderate"],
    tokenType: "app",
    priority: "high",
  },
  {
    type: "channel.follow",
    version: "2",
    condition: (broadcasterId) => ({
      broadcaster_user_id: broadcasterId,
      moderator_user_id: broadcasterId,
    }),
    requiredScopes: ["moderator:read:followers"],
    tokenType: "app",
    priority: "high",
  },
  {
    type: "channel.subscribe",
    version: "1",
    condition: (broadcasterId) => ({ broadcaster_user_id: broadcasterId }),
    requiredScopes: ["channel:read:subscriptions"],
    tokenType: "app",
    priority: "high",
  },
  {
    type: "channel.subscription.gift",
    version: "1",
    condition: (broadcasterId) => ({ broadcaster_user_id: broadcasterId }),
    requiredScopes: ["channel:read:subscriptions"],
    tokenType: "app",
    priority: "high",
  },
  // Medium priority events
  {
    type: "channel.cheer",
    version: "1",
    condition: (broadcasterId) => ({ broadcaster_user_id: broadcasterId }),
    requiredScopes: ["bits:read"],
    tokenType: "app",
    priority: "medium",
  },
  {
    type: "channel.raid",
    version: "1",
    condition: (broadcasterId) => ({ to_broadcaster_user_id: broadcasterId }),
    requiredScopes: [],
    tokenType: "app",
    priority: "medium",
  },
  {
    type: "stream.online",
    version: "1",
    condition: (broadcasterId) => ({ broadcaster_user_id: broadcasterId }),
    requiredScopes: [],
    tokenType: "app",
    priority: "medium",
  },
  {
    type: "stream.offline",
    version: "1",
    condition: (broadcasterId) => ({ broadcaster_user_id: broadcasterId }),
    requiredScopes: [],
    tokenType: "app",
    priority: "medium",
  },
  // Additional events - lower priority
  {
    type: "channel.update",
    version: "2",
    condition: (broadcasterId) => ({
      broadcaster_user_id: broadcasterId,
      moderator_user_id: broadcasterId,
    }),
    requiredScopes: ["channel:read:stream_key"],
    tokenType: "app",
    priority: "low",
  },
  {
    type: "channel.subscription.message",
    version: "1",
    condition: (broadcasterId) => ({ broadcaster_user_id: broadcasterId }),
    requiredScopes: ["channel:read:subscriptions"],
    tokenType: "app",
    priority: "low",
  },
  {
    type: "channel.channel_points_custom_reward_redemption.add",
    version: "1",
    condition: (broadcasterId) => ({ broadcaster_user_id: broadcasterId }),
    requiredScopes: ["channel:read:redemptions"],
    tokenType: "app",
    priority: "low",
  },
];

// Token cache to prevent excessive refreshes
const tokenCache = new Map();
const TOKEN_CACHE_TTL = 5 * 60 * 1000; // 5 minutes

/**
 * Cached app access token with automatic refresh
 */
export async function getAppAccessToken() {
  const cacheKey = "app_token";
  const cached = tokenCache.get(cacheKey);
  
  if (cached && Date.now() < cached.expiresAt) {
    return cached.token;
  }

  try {
    logger.log("Twitch", "Getting new app access token");

    const clientId = await retrieveConfigValue("twitch.clientId");
    const clientSecret = await retrieveConfigValue("twitch.clientSecret");

    if (!clientId || !clientSecret) {
      throw new Error("Missing Twitch client ID or secret in configuration");
    }

    const response = await axios.post(
      "https://id.twitch.tv/oauth2/token",
      new URLSearchParams({
        client_id: clientId,
        client_secret: clientSecret,
        grant_type: "client_credentials",
      }),
      {
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        timeout: 10000,
      }
    );

    const { access_token, expires_in } = response.data;
    const expiresAt = Date.now() + (expires_in * 900); // 90% of expiry time

    tokenCache.set(cacheKey, {
      token: access_token,
      expiresAt,
    });

    logger.log("Twitch", "Successfully obtained app access token");
    return access_token;
  } catch (error) {
    logger.error("Twitch", `Failed to get app access token: ${error.message}`);
    throw error;
  }
}

/**
 * Enhanced token refresh with proper error handling and caching
 */
async function ensureValidToken(userId, tokenType) {
  const cacheKey = `${userId}_${tokenType}`;
  const cached = tokenCache.get(cacheKey);
  
  if (cached && Date.now() < cached.expiresAt) {
    return cached.token;
  }

  try {
    const user = await returnAuthObject(userId);
    
    if (!user?.twitch_tokens?.[tokenType]?.refresh_token) {
      return false;
    }
    
    const tokenData = user.twitch_tokens[tokenType];
    const now = Date.now();
    const bufferTime = 5 * 60 * 1000; // 5 minutes buffer
    
    // If token is valid and not close to expiry, return it
    if (tokenData.access_token && tokenData.expires_at && now < tokenData.expires_at - bufferTime) {
      // Cache the existing valid token
      tokenCache.set(cacheKey, {
        token: tokenData.access_token,
        expiresAt: tokenData.expires_at - bufferTime,
      });
      return tokenData.access_token;
    }
    
    // Token needs refresh
    const response = await axios.post(
      "https://id.twitch.tv/oauth2/token",
      new URLSearchParams({
        client_id: await retrieveConfigValue("twitch.clientId"),
        client_secret: await retrieveConfigValue("twitch.clientSecret"),
        grant_type: "refresh_token",
        refresh_token: tokenData.refresh_token
      }),
      { 
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        timeout: 10000,
      }
    );
    
    const { access_token, refresh_token, expires_in } = response.data;
    const expiresAt = Date.now() + expires_in * 1000;
    
    // Update token in user record
    await updateUserParameter(userId, `twitch_tokens.${tokenType}`, {
      ...tokenData,
      access_token,
      refresh_token,
      expires_at: expiresAt,
      scopes: null // Clear cached scopes
    });
    
    // Cache the new token
    tokenCache.set(cacheKey, {
      token: access_token,
      expiresAt: expiresAt - bufferTime,
    });
    
    logger.log("Twitch", `Refreshed ${tokenType} token for user ${userId}`);
    return access_token;
    
  } catch (error) {
    logger.error("Twitch", `Failed to refresh ${tokenType} token: ${error.message}`);
    tokenCache.delete(cacheKey); // Remove invalid cache entry
    return false;
  }
}

/**
 * Optimized subscription fetching with proper error handling
 */
async function fetchCurrentTwitchSubscriptions(userId) {
  try {
    const appToken = await getAppAccessToken();
    
    if (!appToken) {
      logger.error("Twitch", "Failed to get app access token for subscription check");
      return [];
    }
    
    const response = await twitchAPI.makeRequest({
      method: "get",
      url: "https://api.twitch.tv/helix/eventsub/subscriptions",
      headers: {
        "Client-ID": await retrieveConfigValue("twitch.clientId"),
        "Authorization": `Bearer ${appToken}`
      }
    });
    
    if (response.data?.data) {
      const callbackUrl = `${await retrieveConfigValue("server.endpoints.external")}/api/v1/twitch/eventsub/${userId}`;
      
      return response.data.data.filter(sub => 
        sub.transport?.callback === callbackUrl &&
        sub.status === "enabled"
      );
    }
    
    return [];
  } catch (error) {
    logger.error("Twitch", `Error fetching current subscriptions: ${error.message}`);
    return [];
  }
}

/**
 * Create singleton instance
 */
const twitchAPI = new TwitchAPIManager();

/**
 * Export wrapper function for all Twitch API calls
 */
export async function callTwitchAPI(config, bucketType = "helix", retryOptions = {}) {
  return twitchAPI.makeRequest(config, bucketType, retryOptions);
}

/**
 * Enhanced subscription registration with better prioritization and error handling
 */
export async function registerUserSubscriptions(userId) {
  try {
    const user = await returnAuthObject(userId);

    if (!user.twitch_tokens?.streamer?.access_token) {
      return {
        success: false,
        created: [],
        skipped: [],
        error: "No streamer account connected",
      };
    }

    // Ensure we have broadcaster ID
    if (!user.twitch_tokens.streamer.twitch_user_id) {
      const twitchUserId = await fetchTwitchUserId(userId, "streamer");
      if (!twitchUserId) {
        return {
          success: false,
          created: [],
          skipped: [],
          error: "Failed to fetch Twitch user ID",
        };
      }
    }

    await ensureParameterPath(userId, "twitch_tokens.streamer.subscriptions");

    // Generate webhook secret if needed
    if (!user.twitch_tokens.streamer.webhook_secret) {
      const newSecret = crypto.randomBytes(32).toString("hex");
      await updateUserParameter(userId, "twitch_tokens.streamer.webhook_secret", newSecret);
      logger.log("Twitch", `Generated new webhook secret for user ${userId}`);
    }

    const updatedUser = await returnAuthObject(userId);
    const broadcasterId = updatedUser.twitch_tokens.streamer.twitch_user_id;

    // Get current subscriptions from Twitch and our database
    const [currentTwitchSubs, streamerScopes] = await Promise.all([
      fetchCurrentTwitchSubscriptions(userId),
      getUserScopes(userId, "streamer"),
    ]);

    // Track existing subscriptions
    const existingSubsMap = new Map();
    currentTwitchSubs.forEach(sub => {
      const key = `${sub.type}:${sub.version}`;
      existingSubsMap.set(key, sub);
    });

    const results = {
      success: true,
      created: [],
      skipped: [],
      errors: [],
      error: null,
    };

    // Sort subscription types by priority
    const priorityOrder = { high: 0, medium: 1, low: 2 };
    const sortedSubscriptions = SUBSCRIPTION_TYPES.sort((a, b) => {
      return priorityOrder[a.priority || "low"] - priorityOrder[b.priority || "low"];
    });

    // Process subscriptions with delay between requests
    for (const subscriptionConfig of sortedSubscriptions) {
      try {
        const subKey = `${subscriptionConfig.type}:${subscriptionConfig.version}`;

        // Skip if subscription already exists
        if (existingSubsMap.has(subKey)) {
          results.skipped.push(`${subscriptionConfig.type} (v${subscriptionConfig.version})`);
          continue;
        }

        // Check required scopes
        if (subscriptionConfig.requiredScopes.length > 0) {
          const missingScopes = subscriptionConfig.requiredScopes.filter(
            scope => !streamerScopes.includes(scope)
          );

          if (missingScopes.length > 0) {
            logger.log("Twitch", `Skipping ${subscriptionConfig.type} - missing scopes: ${missingScopes.join(", ")}`);
            results.skipped.push(`${subscriptionConfig.type} (v${subscriptionConfig.version}) - missing scopes`);
            continue;
          }
        }

        // Create the subscription
        const subResult = await createSubscription(userId, subscriptionConfig, broadcasterId);

        if (subResult.success) {
          results.created.push(`${subscriptionConfig.type} (v${subscriptionConfig.version})`);
        } else {
          results.errors.push(`${subscriptionConfig.type}: ${subResult.error}`);
        }

        // Rate limiting delay
        await new Promise(resolve => setTimeout(resolve, 200));

      } catch (error) {
        results.errors.push(`${subscriptionConfig.type}: ${error.message}`);
      }
    }

    // Update success status
    results.success = results.created.length > 0 || results.skipped.length === SUBSCRIPTION_TYPES.length;

    if (results.errors.length > 0) {
      results.error = `Some subscriptions failed: ${results.errors.length} errors`;
    }

    logger.log("Twitch", `EventSub registration for ${userId}: ${results.created.length} created, ${results.skipped.length} skipped, ${results.errors.length} errors`);
    return results;

  } catch (error) {
    logger.error("Twitch", `Error in registerUserSubscriptions: ${error.message}`);
    return {
      success: false,
      created: [],
      skipped: [],
      error: error.message,
    };
  }
}

/**
 * Enhanced subscription creation with better error handling
 */
async function createSubscription(userId, subscriptionConfig, broadcasterId) {
  try {
    const user = await returnAuthObject(userId);
    
    // Use app access token for subscription creation
    const accessToken = await getAppAccessToken();
    const condition = subscriptionConfig.condition(broadcasterId);
    const callbackUrl = `${await retrieveConfigValue("server.endpoints.external")}/api/v1/twitch/eventsub/${userId}`;
    
    const subscriptionBody = {
      type: subscriptionConfig.type,
      version: subscriptionConfig.version,
      condition: condition,
      transport: {
        method: "webhook",
        callback: callbackUrl,
        secret: user.twitch_tokens.streamer.webhook_secret,
      },
    };
    
    const response = await twitchAPI.makeRequest({
      method: "post",
      url: "https://api.twitch.tv/helix/eventsub/subscriptions",
      data: subscriptionBody,
      headers: {
        "Client-ID": await retrieveConfigValue("twitch.clientId"),
        Authorization: `Bearer ${accessToken}`,
        "Content-Type": "application/json",
      },
    });
    
    // Save subscription ID
    const subscriptionId = response.data.data[0].id;
    
    // Update local subscription records
    const currentUser = await returnAuthObject(userId);
    const subscriptions = currentUser.twitch_tokens.streamer.subscriptions || [];
    
    subscriptions.push({
      id: subscriptionId,
      type: subscriptionConfig.type,
      version: subscriptionConfig.version,
      created_at: new Date().toISOString(),
    });
    
    await updateUserParameter(userId, "twitch_tokens.streamer.subscriptions", subscriptions);
    
    return {
      success: true,
      id: subscriptionId,
      version: subscriptionConfig.version,
    };
    
  } catch (error) {
    // Handle 409 conflict errors (subscription already exists)
    if (error.response?.status === 409) {
      logger.log("Twitch", `409 Conflict for ${subscriptionConfig.type} - subscription likely exists`);
      
      // Try to find the existing subscription
      const existingSubs = await fetchCurrentTwitchSubscriptions(userId);
      const matchingSub = existingSubs.find(sub => 
        sub.type === subscriptionConfig.type && 
        sub.version === subscriptionConfig.version
      );
      
      if (matchingSub) {
        return {
          success: true,
          id: matchingSub.id,
          version: matchingSub.version,
          alreadyExists: true
        };
      }
    }
    
    logger.error("Twitch", `Error creating subscription ${subscriptionConfig.type}: ${error.message}`);
    return { success: false, error: error.message };
  }
}

/**
 * Enhanced chat message processing with better error handling
 */
export async function processChatMessage(chatEvent, userId) {
  try {
    const { handleChatMessage, normalizeMessageFormat } = await import("./chat-handler.js");
    
    const normalizedChat = normalizeMessageFormat(chatEvent);
    
    // Process through central handler with autoRespond enabled for Twitch
    return await handleChatMessage(normalizedChat, userId, true);
    
  } catch (error) {
    logger.error("Twitch", `Error processing chat message: ${error.message}`);
    return { success: false, error: error.message };
  }
}

/**
 * Enhanced chat message sending with retry logic
 */
export async function sendChatMessage(message, userId) {
  try {
    const user = await returnAuthObject(userId);

    if (!user.twitch_tokens?.bot?.access_token) {
      logger.error("Twitch", `No bot token for user ${userId}, can't send chat message`);
      return { success: false, error: "No bot token available" };
    }

    // Ensure valid bot token
    const botToken = await ensureValidToken(userId, "bot");
    if (!botToken) {
      logger.error("Twitch", `Failed to refresh bot token for ${userId}`);
      return { success: false, error: "Failed to refresh bot token" };
    }

    if (!user.twitch_tokens?.streamer?.twitch_user_id) {
      logger.error("Twitch", `No streamer ID for ${userId}, can't determine chat channel`);
      return { success: false, error: "No streamer ID available" };
    }

    const channelId = user.twitch_tokens.streamer.twitch_user_id;

    const response = await twitchAPI.makeRequest({
      method: "post",
      url: "https://api.twitch.tv/helix/chat/messages",
      data: {
        broadcaster_id: channelId,
        sender_id: user.twitch_tokens.bot.twitch_user_id,
        message: message,
      },
      headers: {
        "Client-ID": await retrieveConfigValue("twitch.clientId"),
        Authorization: `Bearer ${botToken}`,
        "Content-Type": "application/json",
      },
    });

    if (response.status === 200) {
      logger.log("Twitch", `Sent chat message to ${user.twitch_name || user.user_name}'s channel`);
      return { success: true, message_id: response.data.message_id };
    } else {
      logger.error("Twitch", `Failed to send chat message: ${response.status} ${response.statusText}`);
      return { success: false, error: `API returned ${response.status}` };
    }
    
  } catch (error) {
    logger.error("Twitch", `Error sending chat message: ${error.message}`);
    return { success: false, error: error.message };
  }
}

/**
 * Enhanced user scope checking with caching
 */
async function getUserScopes(userId, tokenType) {
  const cacheKey = `scopes_${userId}_${tokenType}`;
  const cached = tokenCache.get(cacheKey);
  
  if (cached && Date.now() < cached.expiresAt) {
    return cached.scopes;
  }

  try {
    const user = await returnAuthObject(userId);

    if (!user.twitch_tokens?.[tokenType]?.access_token) {
      return [];
    }

    // If we have cached scopes in the user object, use them
    if (user.twitch_tokens[tokenType].scopes && Array.isArray(user.twitch_tokens[tokenType].scopes)) {
      const scopes = user.twitch_tokens[tokenType].scopes;
      tokenCache.set(cacheKey, {
        scopes,
        expiresAt: Date.now() + TOKEN_CACHE_TTL,
      });
      return scopes;
    }

    // Validate token to get scopes
    const response = await axios.get("https://id.twitch.tv/oauth2/validate", {
      headers: {
        Authorization: `OAuth ${user.twitch_tokens[tokenType].access_token}`,
      },
      timeout: 10000,
    });

    if (response.data?.scopes) {
      const scopes = response.data.scopes;
      
      // Cache scopes both in memory and in user object
      await updateUserParameter(userId, `twitch_tokens.${tokenType}.scopes`, scopes);
      tokenCache.set(cacheKey, {
        scopes,
        expiresAt: Date.now() + TOKEN_CACHE_TTL,
      });
      
      return scopes;
    }

    return [];
    
  } catch (error) {
    if (error.response?.status === 401) {
      // Token is invalid, try to refresh
      const newToken = await ensureValidToken(userId, tokenType);
      if (newToken) {
        // Retry with new token
        return getUserScopes(userId, tokenType);
      }
    }
    
    logger.error("Twitch", `Error getting user scopes: ${error.message}`);
    return [];
  }
}

/**
 * Enhanced Twitch user ID fetching
 */
async function fetchTwitchUserId(userId, tokenType) {
  try {
    const user = await returnAuthObject(userId);

    if (user.twitch_tokens?.[tokenType]?.twitch_user_id) {
      return user.twitch_tokens[tokenType].twitch_user_id;
    }

    if (!user.twitch_tokens?.[tokenType]?.access_token) {
      logger.error("Twitch", `No access token available for ${userId} (${tokenType})`);
      return null;
    }

    const response = await twitchAPI.makeRequest({
      method: "get",
      url: "https://api.twitch.tv/helix/users",
      headers: {
        "Client-ID": await retrieveConfigValue("twitch.clientId"),
        Authorization: `Bearer ${user.twitch_tokens[tokenType].access_token}`,
      },
    });

    if (response.data.data?.[0]) {
      const userData = response.data.data[0];
      
      // Save all user info
      await ensureParameterPath(userId, `twitch_tokens.${tokenType}`);
      await updateUserParameter(userId, `twitch_tokens.${tokenType}.twitch_user_id`, userData.id);
      await updateUserParameter(userId, `twitch_tokens.${tokenType}.twitch_login`, userData.login);
      await updateUserParameter(userId, `twitch_tokens.${tokenType}.twitch_display_name`, userData.display_name);

      logger.log("Twitch", `Retrieved and saved Twitch user ID for ${userId} (${tokenType}): ${userData.id}`);
      return userData.id;
    }

    logger.error("Twitch", `Failed to get user info for ${userId} (${tokenType})`);
    return null;
    
  } catch (error) {
    logger.error("Twitch", `Error fetching Twitch user ID for ${userId} (${tokenType}): ${error.message}`);
    return null;
  }
}

/**
 * Main registration function with improved error handling
 */
export async function registerAllUsersEventSub() {
  try {
    logger.log("Twitch", "Starting automatic EventSub registration for all users");

    const users = await returnAPIKeys();
    let successCount = 0;
    let failureCount = 0;

    // Process users in smaller batches to avoid overwhelming the API
    const batchSize = 3;
    for (let i = 0; i < users.length; i += batchSize) {
      const batch = users.slice(i, i + batchSize);
      
      const batchPromises = batch.map(async (user) => {
        try {
          if (!user.twitch_tokens?.streamer?.access_token) {
            logger.log("Twitch", `Skipping EventSub for ${user.user_id}: No streamer account connected`);
            return false;
          }

          const validToken = await ensureValidToken(user.user_id, "streamer");
          if (!validToken) {
            logger.log("Twitch", `Skipping EventSub for ${user.user_id}: Token refresh failed`);
            return false;
          }

          const results = await registerUserSubscriptions(user.user_id);
          
          if (results.success) {
            logger.log("Twitch", `Successfully registered EventSub for ${user.user_id}`);
            return true;
          } else {
            logger.log("Twitch", `Failed to register EventSub for ${user.user_id}: ${results.error}`);
            return false;
          }
          
        } catch (userError) {
          logger.error("Twitch", `Error processing user ${user.user_id}: ${userError.message}`);
          return false;
        }
      });

      const batchResults = await Promise.all(batchPromises);
      successCount += batchResults.filter(Boolean).length;
      failureCount += batchResults.filter(result => !result).length;

      // Delay between batches
      if (i + batchSize < users.length) {
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }

    logger.log("Twitch", `EventSub registration complete. Success: ${successCount}, Failures: ${failureCount}`);
    return { success: successCount, failures: failureCount };
    
  } catch (error) {
    logger.error("Twitch", `Error in registerAllUsersEventSub: ${error.message}`);
    throw error;
  }
}

/**
 * Enhanced event processing with better error handling
 */
export async function processEventSubNotification(eventType, eventData, userId, eventVersion = "1") {
  try {
    const { respondToEvent } = await import("./ai-logic.js");

    const mappedEvent = mapEventSubToInternalFormat(eventType, eventData, eventVersion);
    
    logger.log("Twitch", `Processing ${eventType} (v${eventVersion}) event for user ${userId}`);

    const aiResponse = await respondToEvent(mappedEvent, userId);

    if (aiResponse?.response) {
      const chatResult = await sendChatMessage(aiResponse.response, userId);

      if (chatResult.success) {
        logger.log("Twitch", `Sent response to ${eventType} event to chat: ${aiResponse.response.substring(0, 50)}...`);
      } else {
        logger.error("Twitch", `Failed to send ${eventType} response to chat: ${chatResult.error}`);
      }

      return {
        ...aiResponse,
        chatMessageSent: chatResult.success,
        chatMessageId: chatResult.message_id,
      };
    }

    return aiResponse;
    
  } catch (error) {
    logger.error("Twitch", `Error processing notification: ${error.message}`);
    throw error;
  }
}

/**
 * Optimized event mapping function
 */
function mapEventSubToInternalFormat(eventType, eventData, version = "1") {
  const mappedEvent = { eventType: null, eventData: {} };

  switch (eventType) {
    case "channel.chat.message":
      mappedEvent.eventType = "chat";
      mappedEvent.eventData = {
        user: eventData.chatter.user_name,
        user_id: eventData.chatter.user_id,
        message: eventData.message.text,
        is_first: eventData.message.is_first || false,
        chatter_is_broadcaster: eventData.chatter.user_id === eventData.broadcaster_user_id,
        chatter_is_moderator: eventData.chatter.badges?.some(badge => badge.set_id === "moderator") || false,
        chatter_is_subscriber: eventData.chatter.badges?.some(badge => badge.set_id === "subscriber") || false,
        fragments: eventData.message.fragments || [],
        emotes: eventData.message.fragments
          ?.filter(frag => frag.type === "emote")
          .map(emote => ({ id: emote.id, name: emote.text })) || [],
      };
      break;

    case "channel.follow":
      mappedEvent.eventType = "follow";
      mappedEvent.eventData = {
        username: eventData.user_name || "",
        userId: eventData.user_id || "",
        followed_at: eventData.followed_at || new Date().toISOString(),
      };
      break;

    case "channel.subscribe":
      mappedEvent.eventType = "sub";
      mappedEvent.eventData = {
        subType: "sub",
        user: eventData.user_name || "",
        subTier: mapTier(eventData.tier || "1000"),
        isGift: eventData.is_gift || false,
      };
      break;

    case "channel.subscription.gift":
      mappedEvent.eventType = "sub";
      mappedEvent.eventData = {
        subType: "gift_sub",
        user: eventData.is_anonymous ? "Anonymous" : eventData.user_name || "",
        anonymous: eventData.is_anonymous || false,
        subTier: mapTier(eventData.tier || "1000"),
        recipientUserName: eventData.recipient_user_name || "a viewer",
      };
      break;

    case "channel.cheer":
      mappedEvent.eventType = "dono";
      mappedEvent.eventData = {
        donoType: "bits",
        donoFrom: eventData.is_anonymous ? "Anonymous" : eventData.user_name || "",
        donoAmt: eventData.bits || 0,
        donoMessage: eventData.message || "",
      };
      break;

    case "channel.raid":
      mappedEvent.eventType = "raid";
      mappedEvent.eventData = {
        username: eventData.from_broadcaster_user_name || "",
        viewers: eventData.viewers || 0,
      };
      break;

    case "stream.online":
      mappedEvent.eventType = "stream_online";
      mappedEvent.eventData = {
        startTime: eventData.started_at || new Date().toISOString(),
        type: eventData.type || "live",
      };
      break;

    case "stream.offline":
      mappedEvent.eventType = "stream_offline";
      mappedEvent.eventData = {
        endTime: new Date().toISOString(),
      };
      break;

    default:
      mappedEvent.eventType = eventType.replace("channel.", "").replace("stream.", "");
      mappedEvent.eventData = { ...eventData };
  }

  return mappedEvent;
}

/**
 * Helper for tier mapping
 */
function mapTier(tier) {
  switch (tier) {
    case "1000": return "tier 1";
    case "2000": return "tier 2";
    case "3000": return "tier 3";
    default: return "prime";
  }
}

/**
 * Enhanced stream info fetching with better error handling
 */
export async function fetchStreamInfo(userId) {
  try {
    const user = await returnAuthObject(userId);

    if (!user?.twitch_tokens?.streamer?.twitch_user_id) {
      logger.log("Twitch", `No Twitch user ID for ${userId}, can't fetch stream info`);
      return { success: false, isLive: false, error: "Missing Twitch user ID" };
    }

    const appToken = await getAppAccessToken();
    const channelId = user.twitch_tokens.streamer.twitch_user_id;

    const streamResponse = await twitchAPI.makeRequest({
      method: "get",
      url: `https://api.twitch.tv/helix/streams?user_id=${channelId}`,
      headers: {
        "Client-ID": await retrieveConfigValue("twitch.clientId"),
        Authorization: `Bearer ${appToken}`,
      },
    });

    const result = { success: true, isLive: false, data: {} };

    if (streamResponse.data.data?.[0]) {
      const streamData = streamResponse.data.data[0];
      result.isLive = true;
      result.data = {
        viewerCount: streamData.viewer_count || 0,
        startedAt: streamData.started_at || null,
        title: streamData.title || "",
        gameId: streamData.game_id || "",
        gameName: streamData.game_name || "Unknown Game",
        thumbnailUrl: streamData.thumbnail_url
          ?.replace("{width}", "320")
          .replace("{height}", "180") || null,
      };

      // Update user parameters
      await Promise.all([
        updateUserParameter(userId, "current_game", {
          title: streamData.title || "No Title",
          game: streamData.game_name || "none",
          game_id: streamData.game_id || "0",
          thumbnail_url: streamData.thumbnail_url || null,
          updated_at: new Date().toISOString(),
        }),
        updateUserParameter(userId, "current_viewers", streamData.viewer_count || 0),
        updateUserParameter(userId, "stream_status", {
          online: true,
          started_at: streamData.started_at || null,
          type: streamData.type || "live",
          title: streamData.title || "",
          viewer_count: streamData.viewer_count || 0,
          updated_at: new Date().toISOString(),
        })
      ]);

      logger.log("Twitch", `Updated stream info for ${userId}: ${streamData.viewer_count} viewers, playing ${streamData.game_name}`);
    } else {
      // Stream is offline
      await Promise.all([
        updateUserParameter(userId, "stream_status", {
          online: false,
          updated_at: new Date().toISOString(),
        }),
        updateUserParameter(userId, "current_viewers", 0)
      ]);
    }

    // Always fetch follower count
    await fetchFollowerCount(userId, channelId, appToken);

    return result;
    
  } catch (error) {
    logger.error("Twitch", `Error fetching stream info: ${error.message}`);
    return { success: false, isLive: false, error: error.message };
  }
}

/**
 * Fetch follower count with error handling
 */
async function fetchFollowerCount(userId, channelId, appToken) {
  try {
    const followerResponse = await twitchAPI.makeRequest({
      method: "get",
      url: `https://api.twitch.tv/helix/channels/followers?broadcaster_id=${channelId}`,
      headers: {
        "Client-ID": await retrieveConfigValue("twitch.clientId"),
        Authorization: `Bearer ${appToken}`,
      },
    });

    const followerCount = followerResponse.data.total || 0;
    await updateUserParameter(userId, "current_followers", followerCount);
    
    logger.log("Twitch", `Updated follower count for ${userId}: ${followerCount}`);
    return followerCount;
    
  } catch (error) {
    logger.error("Twitch", `Error fetching follower count: ${error.message}`);
    return 0;
  }
}

/**
 * Update all stream info with better error handling and concurrency control
 */
export async function updateAllStreamInfo() {
  try {
    const users = await returnAPIKeys();
    const twitchUsers = users.filter(user => user.twitch_tokens?.streamer?.twitch_user_id);
    
    let updatedCount = 0;
    let errorCount = 0;

    // Process in smaller batches to avoid rate limits
    const batchSize = 5;
    for (let i = 0; i < twitchUsers.length; i += batchSize) {
      const batch = twitchUsers.slice(i, i + batchSize);
      
      const batchPromises = batch.map(async (user) => {
        try {
          await fetchStreamInfo(user.user_id);
          return true;
        } catch (error) {
          logger.error("Twitch", `Error updating stream info for ${user.user_id}: ${error.message}`);
          return false;
        }
      });

      const results = await Promise.all(batchPromises);
      updatedCount += results.filter(Boolean).length;
      errorCount += results.filter(result => !result).length;

      // Short delay between batches
      if (i + batchSize < twitchUsers.length) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    logger.log("Twitch", `Updated stream info for ${updatedCount} users, with ${errorCount} errors`);
    return { updated: updatedCount, errors: errorCount };
    
  } catch (error) {
    logger.error("Twitch", `Error in updateAllStreamInfo: ${error.message}`);
    return { updated: 0, errors: 1 };
  }
}

/**
 * Enhanced cron job setup with better error handling
 */
export function setupTwitchCronJobs() {
  // Update stream info every minute
  cron.schedule("*/1 * * * *", async () => {
    try {
      await updateAllStreamInfo();
    } catch (error) {
      logger.error("Cron", `Error in stream info update job: ${error.message}`);
    }
  });

  // Update follower count every 5 minutes
  cron.schedule("*/5 * * * *", async () => {
    try {
      const users = await returnAPIKeys();
      const twitchUsers = users.filter(user => user.twitch_tokens?.streamer?.twitch_user_id);

      for (const user of twitchUsers) {
        try {
          const channelId = user.twitch_tokens.streamer.twitch_user_id;
          const appToken = await getAppAccessToken();
          await fetchFollowerCount(user.user_id, channelId, appToken);
        } catch (userError) {
          logger.error("Twitch", `Error updating follower count for ${user.user_id}: ${userError.message}`);
        }

        await new Promise(resolve => setTimeout(resolve, 500));
      }
    } catch (error) {
      logger.error("Cron", `Error in follower count update job: ${error.message}`);
    }
  });

  // Periodic token cache cleanup
  cron.schedule("*/15 * * * *", () => {
    const now = Date.now();
    for (const [key, cached] of tokenCache.entries()) {
      if (now > cached.expiresAt) {
        tokenCache.delete(key);
      }
    }
  });

  logger.log("System", "Twitch cron jobs initialized");
}
</file>

<file path="ai-logic.js">
import axios from "axios";
import fs from "fs-extra";
import path from "path";
import fetch from "node-fetch";
import https from "https";
import { performance } from "node:perf_hooks";
import { processAudio } from "./audio-processor.js";

import {
  MilvusClient,
  DataType,
  MetricType,
  IndexType,
  ConsistencyLevelEnum,
  LoadState,
  buildSearchParams,
} from "@zilliz/milvus2-sdk-node";
import OpenAI from "openai";
import FormData from "form-data";
import {
  replyStripped,
  queryPrompt,
  contextPromptChat,
  eventPromptChat,
  rerankPrompt,
  fixTTSString,
  sendChatCompletionRequest,
  sendToolCompletionRequest,
} from "./prompt-helper.js";
import { SummaryRequestBody } from "./oai-requests.js";
import { returnTwitchEvent } from "./twitch-helper.js";
import {
  resultsReranked,
  createRagError,
  pullFromWebScraper,
} from "./data-helper.js";
import { returnAuthObject } from "./api-helper.js";
import { retrieveConfigValue } from "./config-helper.js";
import { fileURLToPath } from "url";
import { 
  processResponseWithExpressions, 
  generateExpressionPrompt 
} from "./expression-parser.js";

// ==================== CONSTANTS AND GLOBALS ====================
const queryCache = new Map();
const collectionLoadStatus = new Map();
const pendingVectors = new Map();
const MAX_BATCH_SIZE = 100;
const MAX_CACHE_SIZE = 150;
const DEFAULT_TTL = 60000;
const MAX_WAIT_MS = 500;
let userExpressions = new Map();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Initialize Milvus client
const milvusDatabaseUrl = await retrieveConfigValue("milvus.endpoint");
const client = new MilvusClient({
  address: milvusDatabaseUrl,
});

// ==================== CACHING UTILITIES ====================
/**
 * Get a cached result if available and not expired
 * @param {string} key - Unique cache key
 * @returns {any} - The cached result or null if not found/expired
 */
function getCachedResult(key) {
  if (!queryCache.has(key)) return null;

  const { result, expiry } = queryCache.get(key);
  if (Date.now() > expiry) {
    queryCache.delete(key);
    return null;
  }

  logger.log("Milvus", `Cache hit for query: ${key}`);
  return result;
}

/**
 * Store a result in the query cache with LRU eviction
 * @param {string} key - Unique cache key
 * @param {any} result - Result to cache
 * @param {number} ttl - Time to live in milliseconds
 */
function setCachedResult(key, result, ttl = DEFAULT_TTL) {
  // Implement LRU eviction if cache gets too large
  if (queryCache.size >= MAX_CACHE_SIZE) {
    let oldestKey = null;
    let oldestTime = Infinity;

    for (const [cachedKey, value] of queryCache.entries()) {
      if (value.expiry < oldestTime) {
        oldestTime = value.expiry;
        oldestKey = cachedKey;
      }
    }

    if (oldestKey) {
      queryCache.delete(oldestKey);
    }
  }

  queryCache.set(key, {
    result,
    expiry: Date.now() + ttl,
  });
}

/**
 * Clear the entire query cache or entries matching a pattern
 * @param {string} [pattern] - Optional pattern to match keys for selective clearing
 */
function clearQueryCache(pattern = null) {
  if (!pattern) {
    queryCache.clear();
    logger.log("Milvus", "Query cache cleared");
    return;
  }

  for (const key of queryCache.keys()) {
    if (key.includes(pattern)) {
      queryCache.delete(key);
    }
  }

  logger.log("Milvus", `Query cache entries matching '${pattern}' cleared`);
}

// ==================== UTILITY FUNCTIONS ====================
/**
 * Retry operation with exponential backoff
 * @param {Function} operation - The operation to retry
 * @param {number} maxRetries - Maximum number of retries
 * @param {number} initialDelay - Initial delay in milliseconds
 * @returns {Promise<any>} - Result of the operation
 */
async function retryMilvusOperation(
  operation,
  maxRetries = 3,
  initialDelay = 100
) {
  let lastError;
  let delay = initialDelay;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error;

      const isRetryable =
        error.message?.includes("connection") ||
        error.message?.includes("timeout") ||
        error.message?.includes("busy") ||
        error.code === "NetworkError" ||
        error.status?.code === "Unavailable";

      if (isRetryable && attempt < maxRetries) {
        logger.log(
          "Milvus",
          `Retrying operation, attempt ${attempt}/${maxRetries} after ${delay}ms delay. Error: ${error.message}`
        );
        await new Promise((resolve) => setTimeout(resolve, delay));
        delay *= 2;
      }
    }
  }

  throw lastError;
}

/**
 * Validate embedding dimensions
 * @param {Buffer} embedding - The embedding buffer
 * @param {number} expectedDim - Expected dimensions
 */
export function validateEmbeddingDimension(embedding, expectedDim) {
  const requiredBytes = expectedDim / 8;
  if (embedding.length !== requiredBytes) {
    throw new Error(
      `Dimension mismatch: expected ${expectedDim} bits (${requiredBytes} bytes), but got ${embedding.length} bytes.`
    );
  }
}

/**
 * Axios request with retry logic
 * @param {object} config - Axios configuration
 * @param {number} attempts - Number of attempts
 * @param {number} initialDelay - Initial delay
 * @returns {Promise<object>} - Response object
 */
export async function axiosRequestWithRetry(
  config,
  attempts = 3,
  initialDelay = 1000
) {
  let delay = initialDelay;
  for (let i = 0; i < attempts; i++) {
    try {
      return await axios(config);
    } catch (error) {
      if (i === attempts - 1) throw error;
      await new Promise((resolve) => setTimeout(resolve, delay));
      delay *= 2;
    }
  }
}

/**
 * Get message embedding
 * @param {string|string[]} message - Message(s) to embed
 * @returns {Promise<number[]|number[][]>} - Embedding(s)
 */
export async function getMessageEmbedding(message) {
  const embeddingData = {
    input: Array.isArray(message) ? message : [message],
    model: await retrieveConfigValue("models.embedding.model"),
  };

  try {
    const config = {
      method: "post",
      url: `${await retrieveConfigValue("models.embedding.endpoint")}/embeddings`,
      data: embeddingData,
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${await retrieveConfigValue("models.embedding.apiKey")}`,
      },
      timeout: 30000,
    };

    const response = await axiosRequestWithRetry(config, 3, 1000);
    const embeddingResp = response.data.data;
    return embeddingResp.length > 1
      ? embeddingResp.map((item) => item.embedding)
      : embeddingResp[0].embedding;
  } catch (error) {
    logger.log("System", `Error generating embedding: ${error}`);
    throw error;
  }
}

// ==================== UNIFIED SCHEMA GENERATOR ====================
/**
 * Unified schema generator for all collection types
 * @param {string} collectionType - Type of collection
 * @param {string} userId - User ID
 * @returns {Promise<object>} - Collection schema
 */
async function generateCollectionSchema(collectionType, userId) {
  const baseConfig = {
    consistency_level: ConsistencyLevelEnum.Strong,
  };

  const schemas = {
    users: {
      collection_name: `${await retrieveConfigValue("milvus.collections.user")}_${userId}`,
      schema: [
        {
          name: "embedding",
          data_type: DataType.BinaryVector,
          dim: 1024,
          is_primary_key: false,
          auto_id: false,
        },
        {
          name: "username",
          data_type: DataType.VarChar,
          max_length: 256,
          is_primary_key: true,
          auto_id: false,
        },
        {
          name: "gender",
          data_type: DataType.VarChar,
          max_length: 256,
          is_primary_key: false,
          auto_id: false,
        },
        {
          name: "age",
          data_type: DataType.Int64,
          is_primary_key: false,
          auto_id: false,
        },
        {
          name: "residence",
          data_type: DataType.VarChar,
          max_length: 256,
          is_primary_key: false,
          auto_id: false,
        },
      ],
      index_params: [
        {
          field_name: "embedding",
          index_name: "emb_user_lookup",
          index_type: IndexType.BIN_IVF_FLAT,
          metric_type: MetricType.JACCARD,
          params: { nlist: 2048 },
        },
      ],
    },

    intelligence: {
      collection_name: `${await retrieveConfigValue("milvus.collections.intelligence")}_${userId}`,
      schema: [
        {
          name: "embedding",
          data_type: DataType.BinaryVector,
          dim: 1024,
          is_primary_key: false,
        },
        {
          name: "relation",
          data_type: DataType.VarChar,
          max_length: 512,
          is_primary_key: true,
          auto_id: true,
        },
        {
          name: "text_content",
          data_type: DataType.VarChar,
          max_length: 8192,
          is_primary_key: false,
        },
      ],
      index_params: [
        {
          field_name: "embedding",
          index_name: "emb_doc_lookup",
          index_type: IndexType.BIN_IVF_FLAT,
          metric_type: MetricType.JACCARD,
          params: { nlist: 2048 },
        },
      ],
    },

    twitch_chat: {
      collection_name: `${await retrieveConfigValue("milvus.collections.chat")}_${userId}`,
      schema: [
        {
          name: "embedding",
          data_type: DataType.BinaryVector,
          dim: 1024,
          is_primary_key: false,
          auto_id: false,
        },
        {
          name: "username",
          data_type: DataType.VarChar,
          max_length: 256,
          is_primary_key: true,
          auto_id: false,
        },
        {
          name: "text_content",
          data_type: DataType.VarChar,
          max_length: 4096,
          is_primary_key: false,
          auto_id: false,
        },
        {
          name: "raw_msg",
          data_type: DataType.VarChar,
          max_length: 1024,
          is_primary_key: false,
          auto_id: false,
        },
        {
          name: "ai_message",
          data_type: DataType.VarChar,
          max_length: 1024,
          is_primary_key: false,
          auto_id: false,
        },
        {
          name: "time_stamp",
          data_type: DataType.Int64,
          is_primary_key: false,
          auto_id: false,
        },
      ],
      index_params: [
        {
          field_name: "embedding",
          index_name: "emb_chat_lookup",
          index_type: IndexType.BIN_IVF_FLAT,
          metric_type: MetricType.JACCARD,
          params: { nlist: 2048 },
        },
        {
          field_name: "time_stamp",
          index_name: "idx_time_stamp",
          index_type: IndexType.RANGE,
        },
      ],
    },

    vocal: {
      collection_name: `${await retrieveConfigValue("milvus.collections.voice")}_${userId}`,
      schema: [
        {
          name: "embedding",
          data_type: DataType.BinaryVector,
          dim: 1024,
          is_primary_key: false,
          auto_id: false,
        },
        {
          name: "username",
          data_type: DataType.VarChar,
          max_length: 32,
          is_primary_key: false,
          auto_id: false,
        },
        {
          name: "user_message",
          data_type: DataType.VarChar,
          max_length: 256,
          is_primary_key: true,
          auto_id: false,
        },
        {
          name: "ai_resp",
          data_type: DataType.VarChar,
          max_length: 4096,
          is_primary_key: false,
          auto_id: false,
        },
        {
          name: "summary",
          data_type: DataType.VarChar,
          max_length: 4096,
          is_primary_key: false,
          auto_id: false,
        },
        {
          name: "date_time",
          data_type: DataType.VarChar,
          max_length: 1024,
          is_primary_key: false,
          auto_id: false,
        },
      ],
      index_params: [
        {
          field_name: "embedding",
          index_name: "emb_voice_lookup",
          index_type: IndexType.BIN_IVF_FLAT,
          metric_type: MetricType.JACCARD,
          params: { nlist: 2048 },
        },
      ],
    },
  };

  const schema = schemas[collectionType];
  if (!schema) {
    logger.log("Milvus", `No schema defined for collection ${collectionType}`);
    return null;
  }

  return { ...baseConfig, ...schema };
}

// ==================== COLLECTION MANAGEMENT ====================
/**
 * CONSOLIDATED: Ensure collection is loaded with optimized caching
 * @param {string} collectionName - Collection name
 * @param {string} userId - User ID
 * @returns {Promise<boolean>} - True if loaded successfully
 */
async function ensureCollectionLoaded(collectionName, userId) {
  const key = `${collectionName}_${userId}`;
  const cacheExpiry = 60 * 60 * 1000; // 1 hour

  // Check cache first
  const cached = collectionLoadStatus.get(key);
  if (cached && cached.loaded && Date.now() - cached.timestamp < cacheExpiry) {
    return true;
  }

  try {
    const collectionStatus = await client.getLoadState({
      collection_name: key,
    });

    if (collectionStatus.state === LoadState.LoadStateNotExist) {
      logger.log("Milvus", `Collection ${key} does not exist`);
      return false;
    }

    if (collectionStatus.state === LoadState.LoadStateNotLoad) {
      await client.loadCollection({
        collection_name: key,
      });
      logger.log("Milvus", `Collection ${key} loaded successfully.`);
    }

    collectionLoadStatus.set(key, { loaded: true, timestamp: Date.now() });
    return true;
  } catch (error) {
    logger.log("Milvus", `Error loading collection: ${error}`);
    collectionLoadStatus.set(key, { loaded: false, timestamp: Date.now() });
    return false;
  }
}

/**
 * CONSOLIDATED: Check if collection exists and create it if needed
 * @param {string} collection - Collection type
 * @param {string} userId - User ID
 * @returns {Promise<boolean>} - True if collection exists or was created
 */
async function checkAndCreateCollection(collection, userId) {
  try {
    const exists = await client.hasCollection({
      collection_name: `${collection}_${userId}`,
    });

    if (!exists.value) {
      logger.log(
        "Milvus",
        `Collection '${collection}_${userId}' does not exist. Creating...`
      );

      const schema = await generateCollectionSchema(collection, userId);
      if (!schema) {
        logger.log(
          "Milvus",
          `Error: No schema found for collection ${collection}.`
        );
        return false;
      }

      const response = await client.createCollection(schema);
      if (response.error_code === "Success") {
        logger.log(
          "Milvus",
          `Collection '${collection}_${userId}' created successfully.`
        );
        return true;
      } else {
        logger.log(
          "Milvus",
          `Failed to create collection '${collection}_${userId}'. Reason: ${response.reason}`
        );
        return false;
      }
    }

    return true;
  } catch (error) {
    logger.log(
      "Milvus",
      `Error checking or creating collection '${collection}_${userId}': ${error}`
    );
    return false;
  }
}

// ==================== LEGACY FUNCTION WRAPPERS ====================
// These maintain backward compatibility with existing function names

/**
 * Legacy wrapper: Returns the appropriate schema for a given collection and user ID
 * @param {string} collection - The name of the collection
 * @param {string} userId - The user ID
 * @returns {object} - The schema for the specified collection
 */
async function returnCollectionSchema(collection, userId) {
  return await generateCollectionSchema(collection, userId);
}

/**
 * Legacy wrapper: Creates a collection in Milvus if it doesn't exist
 * @param {string} collection - The name of the collection to create
 * @param {string} userId - The user ID
 * @returns {Promise<void>}
 */
async function createCollection(collection, userId) {
  await checkAndCreateCollection(collection, userId);
}

/**
 * Legacy wrapper: Loads a collection in Milvus if it's not already loaded
 * @param {string} collectionName - The name of the collection
 * @param {string} userId - The user ID
 * @returns {Promise<boolean>} - True if the collection is loaded
 */
async function loadCollectionIfNeeded(collectionName, userId) {
  return await ensureCollectionLoaded(collectionName, userId);
}

/**
 * Legacy wrapper: Retrieves the schema of a collection in Milvus
 * @param {string} collection - The name of the collection
 * @param {string} userId - The user ID
 * @returns {Promise<object>} - The schema of the collection
 */
async function getCollectionSchema(collection, userId) {
  try {
    const schemaResponse = await client.describeCollection({
      collection_name: `${collection}_${userId}`,
    });
    return schemaResponse.schema;
  } catch (error) {
    logger.log("Milvus", `Error fetching schema: ${error}`);
    throw error;
  }
}

// ==================== VECTOR BATCHING OPTIMIZATION ====================
/**
 * Schedule vector insertion for batch processing
 * @param {string} collectionType - Type of collection
 * @param {string} userId - User ID
 * @param {object} vector - Vector data to insert
 */
async function scheduleVectorInsertion(collectionType, userId, vector) {
  const key = `${collectionType}_${userId}`;

  if (!pendingVectors.has(key)) {
    pendingVectors.set(key, []);
    setTimeout(() => processVectorBatch(collectionType, userId), MAX_WAIT_MS);
  }

  const batch = pendingVectors.get(key);
  batch.push(vector);

  if (batch.length >= MAX_BATCH_SIZE) {
    processVectorBatch(collectionType, userId);
  }
}

/**
 * Process batched vector insertions
 * @param {string} collectionType - Type of collection
 * @param {string} userId - User ID
 */
async function processVectorBatch(collectionType, userId) {
  const key = `${collectionType}_${userId}`;
  if (!pendingVectors.has(key)) return;

  const vectors = pendingVectors.get(key);
  pendingVectors.delete(key);

  if (vectors.length === 0) return;

  try {
    await client.insert({
      collection_name: `${await retrieveConfigValue(`milvus.collections.${collectionType}`)}_${userId}`,
      fields_data: vectors,
    });

    logger.log(
      "Milvus",
      `Batch inserted ${vectors.length} vectors into ${collectionType}_${userId}`
    );
  } catch (error) {
    logger.log("Milvus", `Error batch inserting vectors: ${error}`);
  }
}

// ==================== UNIFIED SEARCH FUNCTIONS ====================
/**
 * Get optimized search parameters based on collection size and requirements
 * @param {string} collectionName - Collection name
 * @param {string} userId - User ID
 * @param {Buffer} queryEmbedding - Query embedding
 * @param {number} limit - Result limit
 * @param {string|string[]} textParam - Output fields
 * @param {object} options - Search options
 * @returns {Promise<object>} - Search parameters
 */
async function getOptimizedSearchParams(
  collectionName,
  userId,
  queryEmbedding,
  limit,
  textParam,
  options = {}
) {
  const collStats = await client.getCollectionStatistics({
    collection_name: `${collectionName}_${userId}`,
  });

  const rowCount = parseInt(collStats.stats.row_count);
  let nprobe = 16;
  let consistencyLevel = ConsistencyLevelEnum.Session;

  if (rowCount < 1000) {
    nprobe = 8;
  } else if (rowCount > 100000) {
    nprobe = 32;
  }

  if (options.requireStrongConsistency) {
    consistencyLevel = ConsistencyLevelEnum.Strong;
  }

  if (options.criticalSearch) {
    nprobe = Math.min(rowCount / 10, 64);
    consistencyLevel = ConsistencyLevelEnum.Strong;
  }

  return {
    collection_name: `${collectionName}_${userId}`,
    data: queryEmbedding,
    topk: limit,
    metric_type: MetricType.JACCARD,
    output_fields: Array.isArray(textParam) ? textParam : [textParam],
    vector_type: DataType.BinaryVector,
    search_params: buildSearchParams({
      nprobe: nprobe,
      limit: limit,
    }),
    consistency_level: consistencyLevel,
  };
}

/**
 * UNIFIED: Core search function for all Milvus collections
 * @param {Buffer} queryEmbedding - Query embedding
 * @param {string} collectionName - Collection name
 * @param {string|string[]} textParam - Output fields
 * @param {number} limit - Result limit
 * @param {string} userId - User ID
 * @param {object} options - Search options
 * @returns {Promise<object>} - Search results
 */
async function searchDocumentsInMilvus(
  queryEmbedding,
  collectionName,
  textParam,
  limit,
  userId,
  options = {}
) {
  if (!queryEmbedding || queryEmbedding.length === 0) {
    logger.log("Milvus", "Query embedding is empty.");
    return { results: [] };
  }

  try {
    const isLoaded = await ensureCollectionLoaded(collectionName, userId);
    if (!isLoaded) {
      logger.log(
        "Milvus",
        `Collection ${collectionName}_${userId} not available for search.`
      );
      return { results: [] };
    }

    const startTime = performance.now();
    const searchParams = await getOptimizedSearchParams(
      collectionName,
      userId,
      queryEmbedding,
      limit,
      textParam,
      options
    );

    const searchResponse = await retryMilvusOperation(
      () => client.search(searchParams),
      options.maxRetries || 3
    );

    const timeElapsed = (performance.now() - startTime) / 1000;
    logger.log(
      "DB Metrics",
      `Vector search took ${timeElapsed.toFixed(3)} seconds for query in collection "${collectionName}".`
    );

    return searchResponse;
  } catch (error) {
    logger.log("Milvus", `Error searching in Milvus: ${error}`);
    return { results: [] };
  }
}

/**
 * UNIFIED: Generic function to find relevant items in any collection
 * @param {string} message - Search message
 * @param {string} userId - User ID
 * @param {string} collectionType - Type of collection to search
 * @param {string|string[]} outputFields - Fields to return
 * @param {number} topK - Number of results
 * @param {object} searchOptions - Additional search options
 * @returns {Promise<array>} - Search results
 */
async function findRelevantItems(
  message,
  userId,
  collectionType,
  outputFields,
  topK = 10,
  searchOptions = {}
) {
  const cacheKey = `${collectionType}_${userId}_${message}`;
  const cachedResult = getCachedResult(cacheKey);
  if (cachedResult) return cachedResult;

  try {
    const configKey = `milvus.collections.${collectionType}`;
    const collectionName = await retrieveConfigValue(configKey);

    const created = await checkAndCreateCollection(collectionName, userId);
    if (!created) {
      return [];
    }

    const messageEmbedding = await getMessageEmbedding(message);
    const binaryEmbedding = Buffer.from(messageEmbedding);

    // Validate embedding dimensions
    const collectionSchema = await getCollectionSchema(collectionName, userId);
    const embeddingField = collectionSchema.fields.find(
      (field) => field.name === "embedding"
    );
    const expectedDim = parseInt(
      embeddingField?.type_params.find((param) => param.key === "dim")?.value
    );
    validateEmbeddingDimension(binaryEmbedding, expectedDim);

    const searchResponse = await searchDocumentsInMilvus(
      binaryEmbedding,
      collectionName,
      outputFields,
      topK,
      userId,
      searchOptions
    );

    // Set appropriate cache TTL based on collection type
    const cacheTTL =
      collectionType === "intelligence"
        ? 300000 // 5 minutes for documents
        : collectionType === "chat"
          ? 30000 // 30 seconds for chats
          : 60000; // 1 minute for others

    setCachedResult(cacheKey, searchResponse.results, cacheTTL);
    return searchResponse.results;
  } catch (error) {
    logger.log(
      "Milvus",
      `Error in findRelevantItems for ${collectionType}: ${error}`
    );
    return [];
  }
}

// ==================== LEGACY SEARCH FUNCTION WRAPPERS ====================
/**
 * Legacy wrapper: Finds relevant chats (with fallback to MongoDB)
 * @param {string} message - The message to search for
 * @param {string} user - The username
 * @param {string} userId - The user ID
 * @param {number} topK - The number of top results to return
 * @returns {Promise<object[]|boolean>} - Search results
 */
async function findRelevantChats(message, user, userId, topK = 10) {
  try {
    // Import MongoDB search function for hybrid approach
    const { findRelevantChatContext } = await import("./mongodb-client.js");
    const results = await findRelevantChatContext(userId, message, user, topK, {
      useVectors: true,
      simpleTextSearch: true,
    });

    return results;
  } catch (error) {
    logger.log("Chat", `Error in findRelevantChats: ${error.message}`);

    // Fallback to Milvus-only search
    return await findRelevantItems(
      message,
      userId,
      "chat",
      ["text_content", "username", "raw_msg", "ai_message"],
      topK,
      { requireStrongConsistency: false }
    );
  }
}

/**
 * Legacy wrapper: Finds relevant documents in intelligence collection
 * @param {string} message - The message to search for
 * @param {string} userId - The user ID
 * @param {number} topK - The number of top results to return
 * @returns {Promise<object[]>} - Search results
 */
async function findRelevantDocuments(message, userId, topK = 10) {
  return await findRelevantItems(
    message,
    userId,
    "intelligence",
    ["text_content", "relation"],
    topK,
    { criticalSearch: true, maxRetries: 3 }
  );
}

/**
 * Legacy wrapper: Finds relevant voice interactions in voice collection
 * @param {string} message - The message to search for
 * @param {string} userId - The user ID
 * @param {number} topK - The number of top results to return
 * @returns {Promise<object[]>} - Search results
 */
async function findRelevantVoiceInMilvus(message, userId, topK = 5) {
  return await findRelevantItems(
    message,
    userId,
    "voice",
    ["summary", "username", "user_message", "ai_resp", "date_time"],
    topK,
    { requireStrongConsistency: false }
  );
}

// ==================== UNIFIED VECTOR INSERTION ====================
/**
 * UNIFIED: Generic vector insertion function for all collection types
 * @param {string} collectionType - Type of collection
 * @param {string} userId - User ID
 * @param {object} vectorData - Data to insert
 * @param {boolean} useBatching - Whether to use batch insertion
 * @returns {Promise<boolean>} - Success status
 */
async function insertVectorToMilvus(
  collectionType,
  userId,
  vectorData,
  useBatching = false
) {
  try {
    const configKey = `milvus.collections.${collectionType}`;
    const collectionName = `${await retrieveConfigValue(configKey)}_${userId}`;

    const exists = await client.hasCollection({
      collection_name: collectionName,
    });
    if (!exists.value) {
      const created = await checkAndCreateCollection(
        await retrieveConfigValue(configKey),
        userId
      );
      if (!created) {
        logger.log("Milvus", `Failed to create collection ${collectionName}.`);
        return false;
      }
    }

    const isLoaded = await ensureCollectionLoaded(
      await retrieveConfigValue(configKey),
      userId
    );
    if (!isLoaded) {
      logger.log("Milvus", `Failed to load collection ${collectionName}.`);
      return false;
    }

    if (useBatching) {
      scheduleVectorInsertion(collectionType, userId, vectorData);
      return true;
    }

    const insertResponse = await client.insert({
      collection_name: collectionName,
      fields_data: [vectorData],
    });

    if (insertResponse.status.error_code === "Success") {
      logger.log("Milvus", `Inserted data into collection ${collectionName}`);
      return true;
    } else {
      logger.log(
        "Milvus",
        `Failed to insert data into ${collectionName}. Reason: ${insertResponse.status.reason}`
      );
      return false;
    }
  } catch (error) {
    logger.log(
      "Milvus",
      `Error in insertVectorToMilvus for ${collectionType}: ${error}`
    );
    return false;
  }
}

// ==================== LEGACY VECTOR INSERTION WRAPPERS ====================
/**
 * Legacy wrapper: Inserts intelligence vectors
 * @param {number[]} vectors - The vector embeddings
 * @param {string} content - The content
 * @param {string} relational - Relational identifier
 * @param {string} userId - The user ID
 * @returns {Promise<boolean>} - Success status
 */
async function insertAugmentVectorsToMilvus(
  vectors,
  content,
  relational,
  userId
) {
  const vectorData = {
    embedding: vectors,
    relation: relational,
    text_content: content,
  };

  return await insertVectorToMilvus("intelligence", userId, vectorData);
}

/**
 * Legacy wrapper: Inserts voice interaction vectors
 * @param {number[]} vectors - The vector embeddings
 * @param {string} summary - Summary of interaction
 * @param {string} message - User message
 * @param {string} response - AI response
 * @param {string} user - Username
 * @param {string} date - Date timestamp
 * @param {string} userId - User ID
 * @returns {Promise<boolean>} - Success status
 */
async function insertVoiceVectorsIntoMilvus(
  vectors,
  summary,
  message,
  response,
  user,
  date,
  userId
) {
  const vectorData = {
    embedding: vectors,
    username: user,
    user_message: message,
    ai_resp: response,
    summary: summary,
    date_time: date,
  };

  return await insertVectorToMilvus("voice", userId, vectorData);
}

/**
 * Legacy wrapper: Adds chat message as vector with batching
 * @param {string} sumText - Summary text
 * @param {string} message - Original message
 * @param {string} username - Username
 * @param {string} date - Date
 * @param {string} response - AI response
 * @param {string} userId - User ID
 * @returns {Promise<boolean>} - Success status
 */
async function addChatMessageAsVector(
  sumText,
  message,
  username,
  date,
  response,
  userId
) {
  try {
    const currentTime = Date.now();
    const embeddingsArray = await getMessageEmbedding(sumText);

    const vectorData = {
      embedding: embeddingsArray,
      username: username,
      text_content: sumText,
      raw_msg: message,
      ai_message: response,
      time_stamp: currentTime,
    };

    scheduleVectorInsertion("chat", userId, vectorData);
    return true;
  } catch (error) {
    logger.log("Milvus", `Error processing chat text: ${error}`);
    return false;
  }
}

/**
 * Legacy wrapper: Adds voice message as vector
 * @param {string} sumString - Summary string
 * @param {string} message - Original message
 * @param {string} username - Username
 * @param {string} date - Date
 * @param {string} response - AI response
 * @param {string} userId - User ID
 */
async function addVoiceMessageAsVector(
  sumString,
  message,
  username,
  date,
  response,
  userId
) {
  try {
    const embeddingsArray = await getMessageEmbedding(message);
    const success = await insertVoiceVectorsIntoMilvus(
      embeddingsArray,
      sumString,
      message,
      response,
      username,
      date,
      userId
    );

    if (success) {
      logger.log("Milvus", "Voice message successfully inserted into Milvus.");
    } else {
      logger.log("Milvus", "Failed to insert voice message into Milvus.");
    }
  } catch (error) {
    logger.log("Milvus", `Error processing voice message: ${error}`);
  }
}

/**
 * Legacy wrapper: Upserts intelligence vectors (batch operation)
 * @param {object[]} data - Array of vector data
 * @param {string} collection - Collection name
 * @param {string} userId - User ID
 * @returns {Promise<boolean>} - Success status
 */
async function upsertIntelligenceToMilvus(data, collection, userId) {
  if (!data || data.length === 0) {
    logger.log("Milvus", "No data to upsert.");
    return false;
  }

  try {
    const upsertResponse = await client.upsert({
      collection_name: `${collection}_${userId}`,
      fields_data: data,
    });

    if (upsertResponse.status.error_code === "Success") {
      logger.log(
        "Milvus",
        `Upserted ${data.length} items into ${collection}_${userId}`
      );
      return true;
    } else {
      logger.log(
        "Milvus",
        `Failed to upsert data into ${collection}_${userId}. Reason: ${upsertResponse.status.reason}`
      );
      return false;
    }
  } catch (error) {
    logger.log("Milvus", `Error upserting data: ${error}`);
    return false;
  }
}

// ==================== REMAINING FUNCTIONS (UNCHANGED) ====================
// These functions remain as they were, since they don't have redundancy issues
// and are working well as specialized functions

async function returnRecentChats(
  userId,
  fromConsole = false,
  allChats = false
) {
  try {
    const userObj = await returnAuthObject(userId);
    const { getRecentChats } = await import("./mongodb-client.js");
    const startTime = performance.now();
    const limit = allChats ? 1000 : userObj.max_chats || 25;
    const messages = await getRecentChats(userId, limit);
    const sortedResults = messages.sort((a, b) => a.time_stamp - b.time_stamp);
    const formattedResults = sortedResults
      .map(
        (item) =>
          `- ${item.username} sent the following message in ${userObj.user_name}'s Twitch channel: ${item.raw_msg}`
      )
      .join("\n");

    const timeElapsed = (performance.now() - startTime) / 1000;
    logger.log(
      "DB Metrics",
      `Recent chats took ${timeElapsed.toFixed(3)} seconds for query.`
    );

    if (fromConsole) {
      return { chatList: formattedResults, executionTime: timeElapsed };
    } else {
      return formattedResults;
    }
  } catch (error) {
    logger.log("MongoDB", `Error in findRecentChats: ${error.message}`);
    return [];
  }
}

async function upsertUserInfo(userId, userInfo) {
  try {
    const collectionName = `${await retrieveConfigValue("milvus.collections.user")}_${userId}`;
    const userEmbedding = await getMessageEmbedding(userInfo.username);

    const fieldsData = [
      {
        embedding: userEmbedding,
        username: userInfo.username,
        gender: userInfo.gender || "",
        age: userInfo.age || 0,
        residence: userInfo.residence || "",
      },
    ];

    await client.upsert({
      collection_name: collectionName,
      fields_data: fieldsData,
    });

    logger.log(
      "Milvus",
      `User info for ${userInfo.username} upserted in collection ${collectionName}.`
    );
  } catch (error) {
    logger.log("Milvus", `Error upserting user info: ${error}`);
  }
}

async function findUserInMilvus(username, userId) {
  try {
    const collectionName = `${await retrieveConfigValue("milvus.collections.user")}_${userId}`;
    const collectionExists = await client.hasCollection({
      collection_name: collectionName,
    });

    if (!collectionExists.value) {
      logger.log("Milvus", `Collection ${collectionName} does not exist.`);
      return null;
    }

    const isLoaded = await ensureCollectionLoaded(collectionName, userId);
    if (!isLoaded) {
      logger.log("Milvus", `Collection ${collectionName} is not loaded.`);
      return null;
    }

    const usernameEmbedding = await getMessageEmbedding(username);
    const binaryEmbedding = Buffer.from(usernameEmbedding);

    const searchParams = {
      collection_name: collectionName,
      data: binaryEmbedding,
      search_params: buildSearchParams({
        anns_field: "embedding",
        topk: 1,
        metric_type: MetricType.JACCARD,
        params: JSON.stringify({ nprobe: 128 }),
      }),
      vector_type: DataType.BinaryVector,
      output_fields: ["gender", "age", "residence"],
    };

    const searchResponse = await client.search(searchParams);

    if (searchResponse.results.length > 0) {
      return searchResponse.results[0];
    } else {
      logger.log(
        "Milvus",
        `User ${username} not found in collection ${collectionName}.`
      );
      return null;
    }
  } catch (error) {
    logger.log("Milvus", `Error searching for user: ${error}`);
    return null;
  }
}

async function deleteVectorsFromMilvus(relations, collection, userId) {
  try {
    for (const relation of relations) {
      const deleteResponse = await client.deleteEntities({
        collection_name: `${collection}_${userId}`,
        expr: `relation in ['${relation}']`,
      });

      if (deleteResponse.status.error_code === "Success") {
        logger.log(
          "Milvus",
          `Deleted vector with relation '${relation}' from ${collection}_${userId}`
        );
      } else {
        logger.log(
          "Milvus",
          `Failed to delete vector with relation '${relation}' from ${collection}_${userId}. Reason: ${deleteResponse.status.reason}`
        );
      }
    }
  } catch (error) {
    logger.log("Milvus", `Error deleting vectors: ${error}`);
  }
}

export async function retrieveWebContext(urls, query, subject, userId) {
  if (!urls || urls.length === 0) {
    return createRagError(
      "context-retrieval",
      "No URLs provided for context extraction",
      { query: query }
    );
  }

  try {
    logger.log(
      "LLM",
      `Starting optimized web context retrieval for '${query}'`
    );

    const scrapePromises = urls.map((urlObj) =>
      pullFromWebScraper([urlObj], subject)
    );
    const pageContentsArray = await Promise.all(scrapePromises);
    const validContents = pageContentsArray.filter(
      (content) =>
        content && typeof content === "string" && content.trim() !== ""
    );

    if (validContents.length === 0) {
      return createRagError(
        "content-scraping",
        "No valid content found from scraped URLs",
        { urlCount: urls.length }
      );
    }

    const summaryPromises = validContents.map((content) =>
      summarizePage(content, subject)
    );
    const individualSummaries = await Promise.all(summaryPromises);

    const validSummaries = individualSummaries.filter(
      (summary) =>
        summary &&
        !summary.error &&
        summary.vectorString &&
        summary.summaryContents
    );

    if (validSummaries.length === 0) {
      return createRagError(
        "summarization",
        "Failed to generate valid summaries from content",
        { contentCount: validContents.length }
      );
    }

    const finalSummary = await finalCombinedSummary(validSummaries, subject);

    if (finalSummary && finalSummary.error) {
      return finalSummary;
    }

    if (
      !finalSummary ||
      !finalSummary.vectorString ||
      !finalSummary.summaryContents
    ) {
      return createRagError(
        "final-summary",
        "Failed to generate final combined summary",
        { summaryCount: validSummaries.length }
      );
    }

    const finalText = `### Final Summary for ${subject}:\n${finalSummary.summaryContents}`;
    const embeddingArray = await getMessageEmbedding(finalSummary.vectorString);

    if (!embeddingArray) {
      return createRagError(
        "embedding-generation",
        "Failed to generate embedding for summary",
        { vectorString: finalSummary.vectorString.substring(0, 100) + "..." }
      );
    }

    const upsertData = [
      {
        relation: finalSummary.vectorString.slice(0, 512),
        text_content: finalText,
        embedding: embeddingArray,
      },
    ];

    const upsertResult = await upsertIntelligenceToMilvus(
      upsertData,
      await retrieveConfigValue("milvus.collections.intelligence"),
      userId
    );

    if (!upsertResult) {
      return createRagError(
        "vector-storage",
        "Failed to store summary in vector database",
        { subject: subject }
      );
    }

    logger.log("Augment", `Final combined summary stored for '${subject}'`);
    return finalText;
  } catch (error) {
    logger.log(
      "Augment",
      `Error in web context retrieval for '${query}': ${error.message}`,
      "err"
    );
    return createRagError("web-context", error.message, {
      query: query,
      subject: subject,
    });
  }
}

// Helper functions for web context retrieval
async function summarizePage(pageContent, subject) {
  try {
    const instruct = await SummaryRequestBody.create(
      `Please summarize the following content about "${subject}" in a way that provides both a concise vector-optimized sentence and a detailed summary.`,
      await retrieveConfigValue("models.summary.model"),
      pageContent
    );

    const chatTask = await sendToolCompletionRequest(
      instruct,
      await retrieveConfigValue("models.summary")
    );

    if (!chatTask) {
      logger.log("Augment", "Empty response from summary request");
      return null;
    }

    if (chatTask.error) {
      logger.log("Augment", `Error in summary request: ${chatTask.error}`);
      return { error: chatTask.error };
    }

    if (typeof chatTask.response === "object" && chatTask.response !== null) {
      return chatTask.response;
    }

    try {
      return JSON.parse(chatTask.response);
    } catch (parseError) {
      logger.log(
        "Augment",
        `Failed to parse summary response as JSON: ${parseError.message}`
      );
      return { error: "JSON parsing failed", details: parseError.message };
    }
  } catch (error) {
    logger.log("Augment", `Error in summarizePage: ${error.message}`);
    return { error: error.message };
  }
}

async function finalCombinedSummary(summaries, subject) {
  try {
    const combinedText = summaries
      .map(
        (s) => `Vector hint: ${s.vectorString}\nDetailed: ${s.summaryContents}`
      )
      .join("\n\n");

    const finalPrompt = `You are provided with multiple summaries for content about "${subject}". Please consolidate these into a final summary. Your output must be in JSON format with two properties: "vectorString" (a single concise sentence optimized for vector search) and "summaryContents" (the complete final summary). Here are the individual summaries:\n\n${combinedText}`;

    const instruct = await SummaryRequestBody.create(
      finalPrompt,
      await retrieveConfigValue("models.summary.model"),
      combinedText
    );

    const chatTask = await sendToolCompletionRequest(
      instruct,
      await retrieveConfigValue("models.summary")
    );

    if (!chatTask) {
      logger.log("Augment", "Empty response from final summary request");
      return createRagError(
        "summary-generation",
        "Empty response from summary tool"
      );
    }

    if (chatTask.error) {
      logger.log(
        "Augment",
        `Error in final summary request: ${chatTask.error}`
      );
      return createRagError("summary-generation", chatTask.error);
    }

    if (typeof chatTask.response === "object" && chatTask.response !== null) {
      if (
        !chatTask.response.vectorString ||
        !chatTask.response.summaryContents
      ) {
        logger.log(
          "Augment",
          "Final summary response missing required properties"
        );
        return createRagError(
          "summary-format",
          "Summary response missing required properties",
          {
            response:
              JSON.stringify(chatTask.response).substring(0, 100) + "...",
          }
        );
      }
      return chatTask.response;
    }

    try {
      const parsedResponse = JSON.parse(chatTask.response);
      if (!parsedResponse.vectorString || !parsedResponse.summaryContents) {
        logger.log(
          "Augment",
          "Parsed final summary response missing required properties"
        );
        return createRagError(
          "summary-format",
          "Parsed summary response missing required properties",
          { response: JSON.stringify(parsedResponse).substring(0, 100) + "..." }
        );
      }
      return parsedResponse;
    } catch (parseError) {
      logger.log(
        "Augment",
        `Failed to parse final summary response as JSON: ${parseError.message}`
      );
      return createRagError(
        "summary-parsing",
        "Failed to parse summary as JSON",
        {
          error: parseError.message,
          rawResponse: chatTask.response.substring(0, 100) + "...",
        }
      );
    }
  } catch (error) {
    logger.log("Augment", `Error in finalCombinedSummary: ${error.message}`);
    return createRagError("summary-execution", error.message, {
      stack: error.stack,
    });
  }
}

async function searchBraveAPI(query, freshness) {
  try {
    const url = new URL("https://api.search.brave.com/res/v1/web/search");
    url.searchParams.set("q", query);
    url.searchParams.set("result_filter", "web");
    url.searchParams.set("freshness", freshness);

    const httpsAgent = new https.Agent({
      keepAlive: true,
      rejectUnauthorized: true,
      timeout: 10000,
    });

    const response = await fetch(url.toString(), {
      method: "GET",
      agent: httpsAgent,
      headers: {
        "X-Subscription-Token": await retrieveConfigValue("brave.apiKey"),
        Accept: "application/json",
        "User-Agent": "curl/7.68.0",
      },
    });

    const data = await response.json();
    if (data && data.web && Array.isArray(data.web.results)) {
      const chosenResults = data.web.results.slice(0, 4);
      let resultStuff = [];
      for await (const item of chosenResults) {
        const relevantItems = {
          url: item.url,
          title: item.title,
          source: item.meta_url.hostname,
        };
        resultStuff.push(relevantItems);
      }
      return resultStuff;
    } else {
      logger.log(
        "Brave Search",
        `No web results found from Brave for '${query}' using freshness '${freshness}'`,
        "err"
      );
      return [];
    }
  } catch (error) {
    console.error("Error:", error);
    return [];
  }
}

export async function searchSearXNG(query, freshness) {
  try {
    const url = new URL("https://search.prolix.dev/search");
    url.searchParams.set("q", query);
    url.searchParams.set("safesearch", 0);
    url.searchParams.set("categories", "general");
    url.searchParams.set("engines", "google,bing");
    url.searchParams.set("format", "json");

    const response = await axios.get(url.toString());

    if (!response.data || !Array.isArray(response.data.results)) {
      return createRagError("search-api", "Invalid response from search API", {
        query: query,
        responseStatus: response.status,
      });
    }

    if (response.data.results.length === 0) {
      return createRagError("search-results", "No results found for query", {
        query: query,
        freshness: freshness,
      });
    }

    const chosenResults = response.data.results.slice(0, 4);
    let resultStuff = [];

    for await (const item of chosenResults) {
      const relevantItems = {
        url: item.url,
        title: item.title,
        source: item.parsed_url[1],
      };
      resultStuff.push(relevantItems);
    }

    return resultStuff;
  } catch (error) {
    logger.log("SearXNG Search", `Error searching: ${error.message}`);
    return createRagError("search-execution", error.message, { query: query });
  }
}

export async function inferSearchParam(query, userId) {
  try {
    const instruct = await queryPrompt(query, userId);
    const chatTask = await sendToolCompletionRequest(
      instruct,
      await retrieveConfigValue("models.query")
    );

    if (!chatTask || chatTask.error) {
      return createRagError(
        "query-generation",
        "Failed to generate search query",
        { originalError: chatTask?.error || "Unknown error" }
      );
    }

    const fullChat = chatTask.response;

    if (!fullChat || typeof fullChat !== "object") {
      return createRagError(
        "query-parsing",
        "Invalid response structure from query builder",
        { responseType: typeof fullChat }
      );
    }

    if (fullChat.valid === false) {
      logger.log(
        "LLM",
        `Query builder opted out of search for this query. Reason: ${fullChat.reason}`
      );
      return {
        success: false,
        optedOut: true,
        reason: fullChat.reason,
      };
    } else {
      logger.log(
        "LLM",
        `Returned optimized search param: '${fullChat.searchTerm}'. Time to first token: ${chatTask.timeToFirstToken} seconds. Process speed: ${chatTask.tokensPerSecond}tps`
      );
      return {
        success: true,
        searchTerm: fullChat.searchTerm,
        subject: fullChat.subject,
        freshness: fullChat.freshness,
        vectorString: fullChat.vectorString,
      };
    }
  } catch (error) {
    logger.log("LLM", `Error inferring search parameter: ${error}`);
    return createRagError("query-inference", error.message, {
      stack: error.stack,
    });
  }
}

async function readFilesFromDirectory(directory) {
  const files = [];
  try {
    const items = await fs.readdir(directory, { withFileTypes: true });
    for (const item of items) {
      const fullPath = path.join(directory, item.name);
      if (item.isDirectory()) {
        const subDirFiles = await readFilesFromDirectory(fullPath);
        files.push(...subDirFiles);
      } else if (item.isFile() && path.extname(item.name) === ".json") {
        files.push(fullPath);
      }
    }
  } catch (error) {
    logger.log("File System", `Error reading directory ${directory}: ${error}`);
    return [];
  }
  return files;
}

async function compareDocuments(directory, userId, collectionName) {
  const filenames = await readFilesFromDirectory(`${directory}/${userId}`);
  const localDocuments = (
    await Promise.all(
      filenames.map(async (filename) => {
        try {
          const content = await fs.readFile(filename, "utf8");
          return isValidJson(content) ? JSON.parse(content) : null;
        } catch (error) {
          logger.log(
            "File System",
            `Error reading or parsing file ${filename}: ${error}`
          );
          return null;
        }
      })
    )
  ).filter((content) => content !== null);

  const existingDocsResponse = await client.query({
    collection_name: collectionName,
    output_fields: ["relation", "text_content", "embedding"],
    limit: 10000,
  });

  logger.log(
    "Milvus",
    `Retrieved ${existingDocsResponse.data.length} existing documents from Milvus for user ${userId}.`
  );

  const existingDocsMap = new Map(
    existingDocsResponse.data.map((doc) => [doc.relation, doc])
  );

  const toInsert = [];
  const toUpdate = [];
  const toDelete = new Set(existingDocsMap.keys());

  for (const localDoc of localDocuments) {
    if (!localDoc || !localDoc.relation || localDoc.content === undefined) {
      logger.log(
        "Milvus",
        `Skipping invalid local document: ${JSON.stringify(localDoc)}`
      );
      continue;
    }
    const existingDoc = existingDocsMap.get(localDoc.relation);

    const embedding = await getMessageEmbedding(localDoc.relation);
    const flattenedEmbedding = embedding.flat();

    if (!existingDoc) {
      toInsert.push({
        relation: localDoc.relation,
        text_content: localDoc.content,
        embedding: flattenedEmbedding,
      });
    } else {
      toDelete.delete(localDoc.relation);

      if (existingDoc.text_content !== localDoc.content) {
        toUpdate.push({
          relation: localDoc.relation,
          text_content: localDoc.content,
          embedding: flattenedEmbedding,
        });
      }
    }
  }

  return {
    missing: toInsert,
    update: toUpdate,
    remove: Array.from(toDelete).map((relation) => ({ relation })),
  };
}

async function processFiles(directory, userId) {
  try {
    const collectionName = `${await retrieveConfigValue("milvus.collections.intelligence")}_${userId}`;
    const collectionCreated = await checkAndCreateCollection(
      await retrieveConfigValue("milvus.collections.intelligence"),
      userId
    );
    if (!collectionCreated) {
      logger.log(
        "Milvus",
        `Failed to create or verify collection for ${userId}.`
      );
      return;
    }

    const loadedColl = await ensureCollectionLoaded(
      await retrieveConfigValue("milvus.collections.intelligence"),
      userId
    );
    if (!loadedColl) {
      logger.log("Milvus", `Failed to load collection for ${userId}.`);
      return;
    }

    const actions = await compareDocuments(directory, userId, collectionName);

    if (actions.missing.length > 0) {
      await upsertIntelligenceToMilvus(
        [...actions.missing],
        await retrieveConfigValue("milvus.collections.intelligence"),
        userId
      );
      logger.log(
        "Milvus",
        `Adding ${actions.missing.length} documents to ${userId}'s intelligence collection...`
      );
    }

    if (actions.update.length > 0) {
      await upsertIntelligenceToMilvus(
        [...actions.update],
        await retrieveConfigValue("milvus.collections.intelligence"),
        userId
      );
      logger.log(
        "Milvus",
        `Updating ${actions.update.length} documents from ${userId}'s intelligence collection...`
      );
    }

    if (actions.remove.length > 0) {
      await deleteVectorsFromMilvus(
        actions.remove.map((doc) => doc.relation),
        await retrieveConfigValue("milvus.collections.intelligence"),
        userId
      );
      logger.log(
        "Milvus",
        `Removing ${actions.remove.length} documents from ${userId}'s intelligence collection...`
      );
    }
  } catch (error) {
    logger.log("Milvus", `Error processing files for ${userId}: ${error}`);
  }
}

export async function respondToChat(messageData, userId) {
  try {
    const { message, user } = messageData;
    const formattedDate = new Date().toLocaleString();

    logger.log(
      "AI",
      `Starting respondToChat for user ${userId}: "${message.substring(0, 50)}..."`
    );

    // FIXED: Enhanced error handling with detailed logging
    const response = await respondWithContext(message, user, userId);

    if (!response) {
      logger.error(
        "AI",
        `respondWithContext returned null/undefined for user ${userId}`
      );
      return {
        success: false,
        error: "No response generated from AI system",
        details: "respondWithContext returned null or undefined",
      };
    }

    if (!response.response || response.response.trim() === "") {
      logger.error(
        "AI",
        `respondWithContext returned empty response for user ${userId}`
      );
      return {
        success: false,
        error: "AI generated empty response",
        details: "Response object exists but response field is empty",
      };
    }

    logger.log(
      "AI",
      `AI response generated successfully for user ${userId}: "${response.response.substring(0, 50)}..."`
    );

    // FIXED: Enhanced vector storage with error handling
    try {
      const summaryString = `On ${formattedDate}, ${user} said: "${message}". You responded by saying: ${response.response}`;

      // Store the interaction asynchronously
      addChatMessageAsVector(
        summaryString,
        message,
        user,
        formattedDate,
        response.response,
        userId
      ).catch((err) => {
        logger.error(
          "AI",
          `Error saving chat message vector for user ${userId}: ${err.message}`
        );
        // Don't fail the main response for vector storage errors
      });
    } catch (vectorError) {
      logger.error(
        "AI",
        `Error preparing chat message vector for user ${userId}: ${vectorError.message}`
      );
      // Continue with response even if vector storage fails
    }

    return {
      success: true,
      text: response.response,
      thoughtProcess: response.thoughtProcess || null,
      metadata: {
        timestamp: formattedDate,
        userId: userId,
        username: user,
      },
    };
  } catch (error) {
    logger.error(
      "AI",
      `Critical error in respondToChat for user ${userId}: ${error.message}`
    );
    logger.error("AI", `Stack trace: ${error.stack}`);

    return {
      success: false,
      error: `Failed to process chat: ${error.message}`,
      details: error.stack,
    };
  }
}

async function respondWithContext(message, username, userID) {
  const contextId = `ctx_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`;

  try {
    logger.log(
      "AI",
      `[${contextId}] Starting respondWithContext for user ${userID}: "${message.substring(0, 50)}..."`
    );

    // ENHANCED: Check if we should use cached response
    const responseCacheKey = `response_${userID}_${message}_${username}`;
    const cachedResponse = getCachedResult(responseCacheKey);
    if (cachedResponse) {
      logger.log(
        "AI",
        `[${contextId}] Using cached response from previous identical query`
      );
      return cachedResponse;
    }

    // ENHANCED: Validate configuration before proceeding
    logger.log("AI", `[${contextId}] Validating model configuration...`);

    const modelConfig = await retrieveConfigValue("models.chat");
    if (!modelConfig) {
      throw new Error("Chat model configuration is missing");
    }

    if (!modelConfig.endpoint || !modelConfig.apiKey || !modelConfig.model) {
      logger.error("AI", `[${contextId}] Invalid model configuration:`, {
        hasEndpoint: !!modelConfig.endpoint,
        hasApiKey: !!modelConfig.apiKey,
        hasModel: !!modelConfig.model,
        endpoint: modelConfig.endpoint || "MISSING",
        model: modelConfig.model || "MISSING",
      });
      throw new Error(
        "Incomplete chat model configuration - missing endpoint, apiKey, or model"
      );
    }

    logger.log("AI", `[${contextId}] Model configuration validated:`, {
      endpoint: modelConfig.endpoint,
      model: modelConfig.model,
      maxTokens: modelConfig.maxTokens,
    });

    // ENHANCED: Parallel vector searches with individual error handling and timeouts
    logger.log("AI", `[${contextId}] Starting parallel vector searches...`);

    const searchPromises = [
      Promise.race([
        findRelevantDocuments(message, userID, 8),
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error("Document search timeout")), 10000)
        ),
      ]).catch((error) => {
        logger.warn(
          "AI",
          `[${contextId}] Document search failed: ${error.message}`
        );
        return [];
      }),

      Promise.race([
        findRelevantVoiceInMilvus(message, userID, 3),
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error("Voice search timeout")), 8000)
        ),
      ]).catch((error) => {
        logger.warn(
          "AI",
          `[${contextId}] Voice search failed: ${error.message}`
        );
        return [];
      }),

      Promise.race([
        findRelevantChats(message, username, userID, 3),
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error("Chat search timeout")), 8000)
        ),
      ]).catch((error) => {
        logger.warn(
          "AI",
          `[${contextId}] Chat search failed: ${error.message}`
        );
        return [];
      }),
    ];

    const [rawContext, voiceCtx, chatHistory] =
      await Promise.all(searchPromises);

    logger.log("AI", `[${contextId}] Vector searches completed:`, {
      documents: rawContext?.length || 0,
      voice: voiceCtx?.length || 0,
      chat: chatHistory?.length || 0,
    });

    // ENHANCED: Parallel reranking with error handling
    logger.log("AI", `[${contextId}] Starting reranking process...`);

    const rerankPromises = [
      resultsReranked(rawContext, message, userID, true).catch((error) => {
        logger.warn(
          "AI",
          `[${contextId}] Document reranking failed: ${error.message}`
        );
        return "- No additional context available due to processing error.";
      }),

      resultsReranked(chatHistory, message, userID).catch((error) => {
        logger.warn(
          "AI",
          `[${contextId}] Chat reranking failed: ${error.message}`
        );
        return [];
      }),

      resultsReranked(voiceCtx, message, userID).catch((error) => {
        logger.warn(
          "AI",
          `[${contextId}] Voice reranking failed: ${error.message}`
        );
        return [];
      }),
    ];

    const [contextBody, relChatBody, relVoiceBody] =
      await Promise.all(rerankPromises);

    logger.log("AI", `[${contextId}] Reranking completed successfully`);

    // ENHANCED: Build prompt data with validation
    const promptData = {
      relChats: Array.isArray(relChatBody) ? relChatBody : [],
      relContext: contextBody || "- No additional context available.",
      relVoice: Array.isArray(relVoiceBody) ? relVoiceBody : [],
      chat_user: username,
    };

    logger.log("AI", `[${contextId}] Building context prompt...`);

    // ENHANCED: Generate prompt with error handling
    let body;
    try {
      body = await contextPromptChat(promptData, message, userID);

      if (!body || !body.messages || !Array.isArray(body.messages)) {
        throw new Error("Invalid prompt body structure");
      }

      logger.log("AI", `[${contextId}] Prompt generated successfully:`, {
        messageCount: body.messages.length,
        model: body.model,
        maxTokens: body.max_tokens,
      });
    } catch (promptError) {
      logger.error(
        "AI",
        `[${contextId}] Error generating prompt: ${promptError.message}`
      );
      throw new Error(`Failed to generate prompt: ${promptError.message}`);
    }

    // ENHANCED: Send completion request with comprehensive error handling
    logger.log("AI", `[${contextId}] Sending completion request to vLLM...`);

    const chatTask = await retryMilvusOperation(
      async () => {
        const startTime = Date.now();

        try {
          const result = await sendChatCompletionRequest(body, modelConfig);

          const elapsedTime = Date.now() - startTime;
          logger.log(
            "AI",
            `[${contextId}] Completion request completed in ${elapsedTime}ms`
          );

          if (!result) {
            throw new Error("Empty response from chat completion");
          }

          if (result.error) {
            throw new Error(`Chat completion error: ${result.error}`);
          }

          if (!result.response || result.response.trim() === "") {
            logger.error("AI", `[${contextId}] Empty response received:`, {
              hasResponse: !!result.response,
              responseLength: result.response?.length || 0,
              requestId: result.requestId,
            });
            throw new Error("Chat completion returned empty response");
          }

          return result;
        } catch (requestError) {
          logger.error(
            "AI",
            `[${contextId}] Request error: ${requestError.message}`
          );
          throw requestError;
        }
      },
      3, // Max retries
      1000 // Initial delay
    );

    logger.log("AI", `[${contextId}] Chat completion successful:`, {
      responseLength: chatTask.response?.length || 0,
      timeToFirstToken: chatTask.timeToFirstToken,
      tokensPerSecond: chatTask.tokensPerSecond,
      requestId: chatTask.requestId,
    });

    if (chatTask.thoughtProcess) {
      logger.log("AI", `[${contextId}] Thought process received:`, {
        thoughtLength: chatTask.thoughtProcess.length,
        thoughts: Array.isArray(chatTask.thoughtProcess)
          ? chatTask.thoughtProcess.length
          : "string",
      });
    }

    // ENHANCED: Process and validate response
    logger.log("AI", `[${contextId}] Processing response...`);

    const strippedResp = await replyStripped(chatTask.response, userID);

    if (!strippedResp || strippedResp.trim() === "") {
      logger.error(
        "AI",
        `[${contextId}] Response stripping resulted in empty text`
      );
      throw new Error("Response processing resulted in empty text");
    }

    const finalResponse = {
      response: strippedResp,
      thoughtProcess: chatTask.thoughtProcess,
      metadata: {
        contextId: contextId,
        timeToFirstToken: chatTask.timeToFirstToken,
        tokensPerSecond: chatTask.tokensPerSecond,
        requestId: chatTask.requestId,
        contextUsed: {
          documents: rawContext?.length || 0,
          voice: voiceCtx?.length || 0,
          chat: chatHistory?.length || 0,
        },
        endpoint: modelConfig.endpoint,
        model: modelConfig.model,
      },
    };

    // ENHANCED: Cache successful responses
    setCachedResult(responseCacheKey, finalResponse, 10000);

    logger.log(
      "AI",
      `[${contextId}] Response processing completed successfully:`,
      {
        finalLength: strippedResp.length,
        cached: true,
      }
    );

    return finalResponse;
  } catch (error) {
    logger.error(
      "AI",
      `[${contextId}] Error in respondWithContext: ${error.message}`
    );
    logger.error("AI", `[${contextId}] Stack trace: ${error.stack}`);

    // ENHANCED: Return a contextual fallback response instead of throwing
    const fallbackResponse = {
      response: determineFallbackResponse(error.message),
      thoughtProcess: `Error: ${error.message}`,
      isErrorResponse: true,
      metadata: {
        contextId: contextId,
        errorType: error.name || "Unknown",
        errorMessage: error.message,
      },
    };

    return fallbackResponse;
  }
}

async function rerankString(message, userId) {
  const promptRerank = await rerankPrompt(message, userId);
  const chatTask = await sendToolCompletionRequest(
    promptRerank,
    await retrieveConfigValue("models.rerankTransform")
  );
  return chatTask.response;
}

async function respondWithoutContext(message, userId) {
  try {
    const promptData = {
      relChats: "- No relevant chat context available.",
      relContext: "- No additional context to provide.",
      relVoice: "- No voice conversation history.",
      chat_user: "User",
    };

    const body = await contextPromptChat(promptData, message, userId);
    const chatTask = await sendChatCompletionRequest(
      body,
      await retrieveConfigValue("models.chat")
    );

    const strippedResp = await replyStripped(chatTask.response, userId);
    return {
      response: strippedResp,
      thoughtProcess: chatTask.thoughtProcess,
    };
  } catch (error) {
    logger.log("System", `Error in respondWithoutContext: ${error}`);
    return {
      response: "I'm sorry, I encountered an error processing your request.",
      thoughtProcess: `Error: ${error.message}`,
    };
  }
}

async function respondWithVoice(message, userId) {
  const startTime = performance.now();

  const fixedAcro = await fixTTSString(message);
  const userObj = await returnAuthObject(userId);

  logger.log(
    "LLM",
    `Converted ${fixedAcro.acronymCount} acronyms in ${userObj.bot_name}'s TTS message.`
  );

  try {
    const tempDir = path.join(__dirname, "temp");
    await fs.mkdir(tempDir, { recursive: true }).catch(() => {});

    const ttsPreference = await retrieveConfigValue("ttsPreference");

    let audioFilePath;
    let outputFileName;
    let externalGenUrl;
    let internalGenUrl;
    if (ttsPreference === "fish") {
      const fishParameters = {
        text: fixedAcro.fixedString,
        chunk_length: 400,
        format: "wav",
        reference_id: userObj.fishTTSVoice,
        seed: null,
        normalize: false,
        streaming: false,
        max_new_tokens: 4096,
        top_p: 0.82,
        repetition_penalty: 1.2,
        temperature: 0.75,
      };

      const res = await axios.post(
        new URL(await retrieveConfigValue("fishTTS.ttsGenEndpoint.internal")),
        fishParameters,
        { responseType: "arraybuffer" }
      );

      outputFileName = `fish_${userId}_${Date.now()}.wav`;
      const tempFilePath = path.join("./final", outputFileName);
      await fs.writeFile(tempFilePath, Buffer.from(res.data));

      audioFilePath = tempFilePath;
    } else {
      const voiceForm = new FormData();
      voiceForm.append("text_input", fixedAcro.fixedString);
      voiceForm.append("text_filtering", "standard");
      voiceForm.append("character_voice_gen", userObj.speaker_file);
      voiceForm.append("narrator_enabled", "false");
      voiceForm.append("text_not_inside", "character");
      voiceForm.append("language", "en");
      voiceForm.append("output_file_name", userObj.user_id);
      voiceForm.append("output_file_timestamp", "true");
      voiceForm.append("autoplay", "false");
      voiceForm.append("temperature", "0.9");
      voiceForm.append("repetition_penalty", "1.5");

      const res = await axios.post(
        new URL(await retrieveConfigValue("alltalk.ttsGenEndpoint.internal")),
        voiceForm
      );
      internalGenUrl = `${await retrieveConfigValue("alltalk.ttsServeEndpoint.internal")}${res.data.output_file_url}`;
      externalGenUrl = `${await retrieveConfigValue("alltalk.ttsServeEndpoint.external")}${res.data.output_file_url}`;
      const fileRes = await axios({
        method: "GET",
        url: `${await retrieveConfigValue("alltalk.ttsServeEndpoint.internal")}${res.data.output_file_url}`,
        responseType: "arraybuffer",
      });

      outputFileName = `${userId}_${Date.now()}.wav`;
      const tempFilePath = path.join("./final", outputFileName);
      await fs.writeFile(tempFilePath, Buffer.from(fileRes.data));

      audioFilePath = tempFilePath;
    }

    const timeElapsed = (performance.now() - startTime) / 1000;

    if (userObj.ttsUpsamplePref) {
      try {
        const processedFilePath = processAudio(audioFilePath, {
          preset: userObj.ttsEqPref || "clarity",
          userId: userObj.user_id,
        });

        logger.log("API", `Processed audio file to ${processedFilePath}`);

        const serviceEndpoint =
          ttsPreference === "fish" ? "fishTTS" : "alltalk";
        const audioUrl = userObj.is_local ? internalGenUrl : externalGenUrl;

        logger.log(
          "LLM",
          `TTS request completed in ${timeElapsed.toFixed(2)} seconds.`
        );
        return audioUrl;
      } catch (processingError) {
        logger.error(
          "API",
          `Error processing audio: ${processingError.message}`
        );
        const serviceEndpoint =
          ttsPreference === "fish" ? "fishTTS" : "alltalk";
        return userObj.is_local
          ? `${await retrieveConfigValue(`${serviceEndpoint}.ttsServeEndpoint.internal`)}/${path.basename(audioFilePath)}`
          : `${await retrieveConfigValue(`${serviceEndpoint}.ttsServeEndpoint.external`)}/${path.basename(audioFilePath)}`;
      }
    } else {
      const audioUrl = userObj.is_local ? internalGenUrl : externalGenUrl;

      logger.log(
        "LLM",
        `TTS request completed in ${timeElapsed.toFixed(2)} seconds.`
      );
      return audioUrl;
    }
  } catch (error) {
    logger.error("TTS", `Error during TTS request: ${error.message}`);
    return { error: error.message };
  }
}

export async function respondToDirectVoice(message, userId, withVoice = false) {
  try {
    logger.log(
      "Voice",
      `Processing voice interaction for user ${userId}: "${message.substring(0, 50)}..."`
    );

    const userObj = await returnAuthObject(userId);
    if (!userObj) {
      throw new Error(`User ${userId} not found`);
    }

    // FIXED: Enhanced parallel processing for voice context
    const [voiceCtx, rawContext] = await Promise.allSettled([
      findRelevantVoiceInMilvus(message, userId, 3),
      findRelevantDocuments(message, userId, 6),
    ]);

    const voiceResults = voiceCtx.status === "fulfilled" ? voiceCtx.value : [];
    const contextResults =
      rawContext.status === "fulfilled" ? rawContext.value : [];

    logger.log(
      "Voice",
      `Voice context search completed for user ${userId}. Voice: ${voiceResults.length}, Context: ${contextResults.length}`
    );

    // FIXED: Enhanced reranking with error handling
    const [contextBody, voiceCtxBody] = await Promise.allSettled([
      resultsReranked(contextResults, message, userId, true),
      withVoice
        ? resultsReranked(voiceResults, message, userId, false)
        : Promise.resolve("- No additional voice conversations to supply."),
    ]);

    const finalContextBody =
      contextBody.status === "fulfilled"
        ? contextBody.value
        : "- No additional context available due to processing error.";
    const finalVoiceBody =
      voiceCtxBody.status === "fulfilled"
        ? voiceCtxBody.value
        : "- No additional voice conversations to supply.";

    const promptData = {
      relChats: "- No additional chat content.",
      relContext: finalContextBody,
      relVoice: finalVoiceBody,
      user: userObj.user_name,
    };

    logger.log("Voice", `Generating voice response for user ${userId}`);

    const body = await contextPromptChat(promptData, message, userId);
    const chatTask = await sendChatCompletionRequest(
      body,
      await retrieveConfigValue("models.chat")
    );

    if (!chatTask.response) {
      throw new Error("No response generated for voice interaction");
    }

    await fs.writeFile(
      "./chat_cmp_resp.json",
      JSON.stringify(chatTask.response, null, 2)
    );

    logger.log(
      "Voice",
      `Voice response generated for user ${userId}. Time to first token: ${chatTask.timeToFirstToken} seconds. Process speed: ${chatTask.tokensPerSecond}tps`
    );

    const strippedResp = await replyStripped(chatTask.response, userId);

    // FIXED: Store voice interaction in vectors
    try {
      const formattedDate = new Date().toLocaleString();
      const summaryString = `On ${formattedDate}, ${userObj.user_name} said via voice: "${message}". You responded by saying: ${strippedResp}`;

      addVoiceMessageAsVector(
        summaryString,
        message,
        userObj.user_name,
        formattedDate,
        strippedResp,
        userId
      ).catch((err) =>
        logger.error("Voice", `Error storing voice vector: ${err.message}`)
      );
    } catch (vectorError) {
      logger.error(
        "Voice",
        `Error preparing voice vector: ${vectorError.message}`
      );
    }

    if (withVoice) {
      logger.log("Voice", `Generating TTS audio for user ${userId}`);
      const audioUrl = await respondWithVoice(strippedResp, userId);
      return {
        response: strippedResp,
        audio_url: audioUrl,
        thoughtProcess: chatTask.thoughtProcess,
      };
    } else {
      return {
        response: strippedResp,
        thoughtProcess: chatTask.thoughtProcess,
      };
    }
  } catch (error) {
    logger.error(
      "Voice",
      `Error in respondToDirectVoice for user ${userId}: ${error.message}`
    );
    return {
      response:
        "I'm sorry, I'm having trouble processing voice interactions right now. Please try again.",
      error: error.message,
    };
  }
}

/**
 * Store available expressions for a user
 * @param {string} userId - User ID
 * @param {string[]} expressions - Available expressions from the model
 */
export function setUserExpressions(userId, expressions) {
  if (!expressions || !Array.isArray(expressions)) {
    logger.log("Expression", `Invalid expressions array for user ${userId}`);
    return;
  }

  userExpressions.set(userId, expressions);
  logger.log(
    "Expression",
    `Stored ${expressions.length} expressions for user ${userId}: ${expressions.join(", ")}`
  );
}

/**
 * Get available expressions for a user
 * @param {string} userId - User ID
 * @returns {string[]} - Available expressions
 */
export function getUserExpressions(userId) {
  return userExpressions.get(userId) || [];
}

/**
 * Enhanced respondToChat with expression support
 * @param {Object} messageData - Message data containing message and user
 * @param {string} userId - User ID
 * @returns {Object} - Enhanced response with expressions
 */
export async function respondToChatWithExpressions(messageData, userId) {
  try {
    const { message, user } = messageData;
    const formattedDate = new Date().toLocaleString();

    logger.log(
      "AI",
      `Starting respondToChatWithExpressions for user ${userId}: "${message.substring(0, 50)}..."`
    );

    // Get available expressions for this user
    const availableExpressions = getUserExpressions(userId);

    // Enhanced context response with expression support
    const response = await respondWithContextAndExpressions(
      message,
      user,
      userId,
      availableExpressions
    );

    if (!response || !response.success) {
      logger.error(
        "AI",
        `respondWithContextAndExpressions failed for user ${userId}:`,
        response?.error || "Unknown error"
      );
      return {
        success: false,
        error: response?.error || "No response generated from AI system",
        details: response?.details || "respondWithContextAndExpressions failed",
      };
    }

    if (!response.cleanText || response.cleanText.trim() === "") {
      logger.error("AI", `AI generated empty response for user ${userId}`);
      return {
        success: false,
        error: "AI generated empty response",
        details: "Response object exists but cleanText field is empty",
      };
    }

    logger.log(
      "AI",
      `AI response with expressions generated for user ${userId}: "${response.cleanText.substring(0, 50)}..." (${response.expressions.length} expressions)`
    );

    // Store the interaction asynchronously
    try {
      const summaryString = `On ${formattedDate}, ${user} said: "${message}". You responded by saying: ${response.cleanText}`;

      addChatMessageAsVector(
        summaryString,
        message,
        user,
        formattedDate,
        response.cleanText,
        userId
      ).catch((err) => {
        logger.error(
          "AI",
          `Error saving chat message vector for user ${userId}: ${err.message}`
        );
      });
    } catch (vectorError) {
      logger.error(
        "AI",
        `Error preparing chat message vector for user ${userId}: ${vectorError.message}`
      );
    }

    return {
      success: true,
      text: response.cleanText,
      expressions: response.expressions,
      estimatedDuration: response.estimatedDuration,
      thoughtProcess: response.thoughtProcess || null,
      metadata: {
        timestamp: formattedDate,
        userId: userId,
        username: user,
        expressionCount: response.expressions.length,
        debug: response.debug,
      },
    };
  } catch (error) {
    logger.error(
      "AI",
      `Critical error in respondToChatWithExpressions for user ${userId}: ${error.message}`
    );
    logger.error("AI", `Stack trace: ${error.stack}`);

    return {
      success: false,
      error: `Failed to process chat: ${error.message}`,
      details: error.stack,
    };
  }
}

/**
 * Enhanced respondWithContext that includes expression processing
 * @param {string} message - User message
 * @param {string} username - Username
 * @param {string} userID - User ID
 * @param {string[]} availableExpressions - Available expressions
 * @returns {Object} - Response with expressions
 */
async function respondWithContextAndExpressions(
  message,
  username,
  userID,
  availableExpressions = []
) {
  const contextId = `ctx_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`;

  try {
    logger.log(
      "AI",
      `[${contextId}] Starting respondWithContextAndExpressions for user ${userID}: "${message.substring(0, 50)}..."`
    );

    // Check if we should use cached response
    const responseCacheKey = `response_expr_${userID}_${message}_${username}`;
    const cachedResponse = getCachedResult(responseCacheKey);
    if (cachedResponse) {
      logger.log(
        "AI",
        `[${contextId}] Using cached response from previous identical query`
      );
      return cachedResponse;
    }

    // Validate configuration
    logger.log("AI", `[${contextId}] Validating model configuration...`);

    const modelConfig = await retrieveConfigValue("models.chat");
    if (
      !modelConfig ||
      !modelConfig.endpoint ||
      !modelConfig.apiKey ||
      !modelConfig.model
    ) {
      throw new Error("Incomplete chat model configuration");
    }

    logger.log(
      "AI",
      `[${contextId}] Model configuration validated. Available expressions: ${availableExpressions.length}`
    );

    // Parallel vector searches (same as before)
    logger.log("AI", `[${contextId}] Starting parallel vector searches...`);

    const searchPromises = [
      Promise.race([
        findRelevantDocuments(message, userID, 8),
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error("Document search timeout")), 10000)
        ),
      ]).catch((error) => {
        logger.warn(
          "AI",
          `[${contextId}] Document search failed: ${error.message}`
        );
        return [];
      }),

      Promise.race([
        findRelevantVoiceInMilvus(message, userID, 3),
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error("Voice search timeout")), 8000)
        ),
      ]).catch((error) => {
        logger.warn(
          "AI",
          `[${contextId}] Voice search failed: ${error.message}`
        );
        return [];
      }),

      Promise.race([
        findRelevantChats(message, username, userID, 3),
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error("Chat search timeout")), 8000)
        ),
      ]).catch((error) => {
        logger.warn(
          "AI",
          `[${contextId}] Chat search failed: ${error.message}`
        );
        return [];
      }),
    ];

    const [rawContext, voiceCtx, chatHistory] =
      await Promise.all(searchPromises);

    // Parallel reranking
    logger.log("AI", `[${contextId}] Starting reranking process...`);

    const rerankPromises = [
      resultsReranked(rawContext, message, userID, true).catch((error) => {
        logger.warn(
          "AI",
          `[${contextId}] Document reranking failed: ${error.message}`
        );
        return "- No additional context available due to processing error.";
      }),

      resultsReranked(chatHistory, message, userID).catch((error) => {
        logger.warn(
          "AI",
          `[${contextId}] Chat reranking failed: ${error.message}`
        );
        return [];
      }),

      resultsReranked(voiceCtx, message, userID).catch((error) => {
        logger.warn(
          "AI",
          `[${contextId}] Voice reranking failed: ${error.message}`
        );
        return [];
      }),
    ];

    const [contextBody, relChatBody, relVoiceBody] =
      await Promise.all(rerankPromises);

    // Build prompt data
    const promptData = {
      relChats: Array.isArray(relChatBody) ? relChatBody : [],
      relContext: contextBody || "- No additional context available.",
      relVoice: Array.isArray(relVoiceBody) ? relVoiceBody : [],
      chat_user: username,
    };

    logger.log(
      "AI",
      `[${contextId}] Building context prompt with expression support...`
    );

    // Generate prompt with expression enhancement
    let body;
    try {
      body = await contextPromptChatWithExpressions(
        promptData,
        message,
        userID,
        availableExpressions
      );

      if (!body || !body.messages || !Array.isArray(body.messages)) {
        throw new Error("Invalid prompt body structure");
      }

      logger.log(
        "AI",
        `[${contextId}] Enhanced prompt generated with ${availableExpressions.length} expressions available`
      );
    } catch (promptError) {
      logger.error(
        "AI",
        `[${contextId}] Error generating prompt: ${promptError.message}`
      );
      throw new Error(`Failed to generate prompt: ${promptError.message}`);
    }

    // Send completion request
    logger.log("AI", `[${contextId}] Sending completion request...`);

    const chatTask = await retryMilvusOperation(
      async () => {
        const startTime = Date.now();

        try {
          const result = await sendChatCompletionRequest(body, modelConfig);
          const elapsedTime = Date.now() - startTime;

          logger.log(
            "AI",
            `[${contextId}] Completion request completed in ${elapsedTime}ms`
          );

          if (
            !result ||
            result.error ||
            !result.response ||
            result.response.trim() === ""
          ) {
            throw new Error(
              result?.error || "Empty response from chat completion"
            );
          }

          return result;
        } catch (requestError) {
          logger.error(
            "AI",
            `[${contextId}] Request error: ${requestError.message}`
          );
          throw requestError;
        }
      },
      3, // Max retries
      1000 // Initial delay
    );

    logger.log("AI", `[${contextId}] Chat completion successful`);

    // Process response for expressions
    logger.log("AI", `[${contextId}] Processing response for expressions...`);

    const expressionResult = await processResponseWithExpressions(
      chatTask.response,
      availableExpressions,
      { enableDebugLogging: true }
    );

    if (!expressionResult.success) {
      logger.error(
        "AI",
        `[${contextId}] Expression processing failed: ${expressionResult.error}`
      );
      // Fall back to original response without expressions
      const strippedResp = await replyStripped(chatTask.response, userID);

      return {
        success: true,
        cleanText: strippedResp,
        expressions: [],
        thoughtProcess: chatTask.thoughtProcess,
        error: expressionResult.error,
      };
    }

    // Strip response text of any remaining artifacts
    const finalCleanText = await replyStripped(
      expressionResult.cleanText,
      userID
    );

    if (!finalCleanText || finalCleanText.trim() === "") {
      logger.error(
        "AI",
        `[${contextId}] Response stripping resulted in empty text`
      );
      throw new Error("Response processing resulted in empty text");
    }

    const finalResponse = {
      success: true,
      cleanText: finalCleanText,
      expressions: expressionResult.expressions,
      estimatedDuration: expressionResult.estimatedDuration,
      thoughtProcess: chatTask.thoughtProcess,
      debug: expressionResult.debug,
      metadata: {
        contextId: contextId,
        timeToFirstToken: chatTask.timeToFirstToken,
        tokensPerSecond: chatTask.tokensPerSecond,
        requestId: chatTask.requestId,
        expressionCount: expressionResult.expressions.length,
        endpoint: modelConfig.endpoint,
        model: modelConfig.model,
      },
    };

    // Cache successful responses
    setCachedResult(responseCacheKey, finalResponse, 10000);

    logger.log(
      "AI",
      `[${contextId}] Response processing completed with ${expressionResult.expressions.length} expressions`
    );

    return finalResponse;
  } catch (error) {
    logger.error(
      "AI",
      `[${contextId}] Error in respondWithContextAndExpressions: ${error.message}`
    );
    logger.error("AI", `[${contextId}] Stack trace: ${error.stack}`);

    // Return a fallback response
    return {
      success: false,
      error: error.message,
      details: error.stack,
      contextId: contextId,
    };
  }
}

/**
 * Enhanced prompt generation with expression support
 * @param {Object} promptData - Prompt data with context
 * @param {string} message - User message
 * @param {string} userID - User ID
 * @param {string[]} availableExpressions - Available expressions
 * @returns {Object} - Enhanced prompt body
 */
async function contextPromptChatWithExpressions(
  promptData,
  message,
  userID,
  availableExpressions = []
) {
  // Get the base prompt from the original function
  const basePromptBody = await contextPromptChat(promptData, message, userID);

  if (
    !basePromptBody ||
    !basePromptBody.messages ||
    !Array.isArray(basePromptBody.messages)
  ) {
    throw new Error("Invalid base prompt structure");
  }

  // Find the system message to enhance with expression instructions
  const systemMessageIndex = basePromptBody.messages.findIndex(
    (msg) => msg.role === "system"
  );

  if (systemMessageIndex !== -1 && availableExpressions.length > 0) {
    const originalSystemContent =
      basePromptBody.messages[systemMessageIndex].content;
    const enhancedSystemContent = generateExpressionPrompt(
      availableExpressions,
      originalSystemContent
    );

    basePromptBody.messages[systemMessageIndex].content = enhancedSystemContent;

    logger.log(
      "Expression",
      `Enhanced system prompt with ${availableExpressions.length} expressions`
    );
  } else {
    logger.log(
      "Expression",
      `No expressions available or no system message found for enhancement`
    );
  }

  return basePromptBody;
}

/**
 * Enhanced voice response with expression support
 * @param {string} message - User message
 * @param {string} userId - User ID
 * @param {boolean} withVoice - Whether to generate audio
 * @returns {Object} - Response with expressions and optional audio
 */
export async function respondToDirectVoiceWithExpressions(
  message,
  userId,
  withVoice = false
) {
  try {
    logger.log(
      "Voice",
      `Processing voice interaction with expressions for user ${userId}: "${message.substring(0, 50)}..."`
    );

    const userObj = await returnAuthObject(userId);
    if (!userObj) {
      throw new Error(`User ${userId} not found`);
    }

    // Get available expressions for this user
    const availableExpressions = getUserExpressions(userId);

    // Enhanced parallel processing for voice context
    const [voiceCtx, rawContext] = await Promise.allSettled([
      findRelevantVoiceInMilvus(message, userId, 3),
      findRelevantDocuments(message, userId, 6),
    ]);

    const voiceResults = voiceCtx.status === "fulfilled" ? voiceCtx.value : [];
    const contextResults =
      rawContext.status === "fulfilled" ? rawContext.value : [];

    logger.log(
      "Voice",
      `Voice context search completed for user ${userId}. Voice: ${voiceResults.length}, Context: ${contextResults.length}`
    );

    // Enhanced reranking with error handling
    const [contextBody, voiceCtxBody] = await Promise.allSettled([
      resultsReranked(contextResults, message, userId, true),
      withVoice
        ? resultsReranked(voiceResults, message, userId, false)
        : Promise.resolve("- No additional voice conversations to supply."),
    ]);

    const finalContextBody =
      contextBody.status === "fulfilled"
        ? contextBody.value
        : "- No additional context available due to processing error.";
    const finalVoiceBody =
      voiceCtxBody.status === "fulfilled"
        ? voiceCtxBody.value
        : "- No additional voice conversations to supply.";

    const promptData = {
      relChats: "- No additional chat content.",
      relContext: finalContextBody,
      relVoice: finalVoiceBody,
      user: userObj.user_name,
    };

    logger.log(
      "Voice",
      `Generating voice response with expressions for user ${userId}`
    );

    // Use enhanced prompt generation
    const body = await contextPromptChatWithExpressions(
      promptData,
      message,
      userId,
      availableExpressions
    );
    const chatTask = await sendChatCompletionRequest(
      body,
      await retrieveConfigValue("models.chat")
    );

    if (!chatTask.response) {
      throw new Error("No response generated for voice interaction");
    }

    logger.log(
      "Voice",
      `Voice response generated for user ${userId}. Time to first token: ${chatTask.timeToFirstToken} seconds`
    );

    // Process response for expressions
    const expressionResult = await processResponseWithExpressions(
      chatTask.response,
      availableExpressions,
      { enableDebugLogging: true }
    );

    const finalText = expressionResult.success
      ? expressionResult.cleanText
      : await replyStripped(chatTask.response, userId);

    // Store voice interaction in vectors
    try {
      const formattedDate = new Date().toLocaleString();
      const summaryString = `On ${formattedDate}, ${userObj.user_name} said via voice: "${message}". You responded by saying: ${finalText}`;

      addVoiceMessageAsVector(
        summaryString,
        message,
        userObj.user_name,
        formattedDate,
        finalText,
        userId
      ).catch((err) =>
        logger.error("Voice", `Error storing voice vector: ${err.message}`)
      );
    } catch (vectorError) {
      logger.error(
        "Voice",
        `Error preparing voice vector: ${vectorError.message}`
      );
    }

    if (withVoice) {
      logger.log("Voice", `Generating TTS audio for user ${userId}`);
      const audioUrl = await respondWithVoice(finalText, userId);

      return {
        response: finalText,
        expressions: expressionResult.success
          ? expressionResult.expressions
          : [],
        estimatedDuration: expressionResult.estimatedDuration || 0,
        audio_url: audioUrl,
        thoughtProcess: chatTask.thoughtProcess,
        debug: expressionResult.debug,
      };
    } else {
      return {
        response: finalText,
        expressions: expressionResult.success
          ? expressionResult.expressions
          : [],
        estimatedDuration: expressionResult.estimatedDuration || 0,
        thoughtProcess: chatTask.thoughtProcess,
        debug: expressionResult.debug,
      };
    }
  } catch (error) {
    logger.error(
      "Voice",
      `Error in respondToDirectVoiceWithExpressions for user ${userId}: ${error.message}`
    );
    return {
      response:
        "I'm sorry, I'm having trouble processing voice interactions right now. Please try again.",
      expressions: [],
      error: error.message,
    };
  }
}

async function respondToEvent(event, userId) {
  try {
    const eventMessage = await returnTwitchEvent(event, userId);
    const instructPrompt = await eventPromptChat(eventMessage, userId);

    const chatTask = await sendChatCompletionRequest(
      instructPrompt,
      await retrieveConfigValue("models.chat")
    );
    logger.log(
      "LLM",
      `Generated event response. Time to first token: ${chatTask.timeToFirstToken} seconds. Process speed: ${chatTask.tokensPerSecond}tps`
    );

    const strippedResp = await replyStripped(chatTask.response, userId);
    return { response: strippedResp, thoughtProcess: chatTask.thoughtProcess };
  } catch (error) {
    logger.log("System", `Error in respondToEvent: ${error}`);
    return {
      response: "I'm sorry, I encountered an error processing this event.",
      thoughtProcess: `Error: ${error.message}`,
    };
  }
}

async function startIndexingVectors(userId) {
  const authObjects = await returnAuthObject(userId);
  logger.log("Milvus", `Beginning indexing for ${authObjects.user_id}`);
  await processFiles(
    `${await retrieveConfigValue("milvus.localTextDirectory")}`,
    authObjects.user_id
  );
}

async function checkMilvusHealth() {
  const isUp = await client.checkHealth();
  return isUp.isHealthy;
}

async function checkMilvusHealthDetailed(userId = null) {
  try {
    const isHealthy = await client.checkHealth();

    const healthData = {
      isHealthy: isHealthy.isHealthy,
      timestamp: Date.now(),
      metrics: {},
    };

    if (!isHealthy.isHealthy) {
      logger.log("Milvus", "Milvus health check failed");
      return healthData;
    }

    if (userId) {
      const collections = [
        await retrieveConfigValue("milvus.collections.user"),
        await retrieveConfigValue("milvus.collections.intelligence"),
        await retrieveConfigValue("milvus.collections.chat"),
        await retrieveConfigValue("milvus.collections.voice"),
      ];

      const collectionStats = {};

      for (const collection of collections) {
        const collName = `${collection}_${userId}`;
        try {
          const exists = await client.hasCollection({
            collection_name: collName,
          });

          if (exists.value) {
            const stats = await client.getCollectionStatistics({
              collection_name: collName,
            });
            const loadState = await client.getLoadState({
              collection_name: collName,
            });

            collectionStats[collection] = {
              exists: true,
              rowCount: parseInt(stats.stats.row_count || 0),
              loadState: loadState.state,
            };
          } else {
            collectionStats[collection] = {
              exists: false,
            };
          }
        } catch (err) {
          collectionStats[collection] = {
            exists: "error",
            error: err.message,
          };
        }
      }

      healthData.metrics.collections = collectionStats;
    }

    try {
      const sysInfo = await client.getMetric({ request: {} });

      if (sysInfo && sysInfo.response) {
        healthData.metrics.system = sysInfo.response;
      }
    } catch (error) {
      healthData.metrics.system = { error: error.message };
    }

    healthData.metrics.cache = {
      queryCache: {
        size: queryCache.size,
        maxSize: MAX_CACHE_SIZE,
      },
      collectionLoadStatus: {
        size: collectionLoadStatus.size,
      },
    };

    return healthData;
  } catch (error) {
    logger.log("Milvus", `Error in detailed health check: ${error}`);
    return {
      isHealthy: false,
      error: error.message,
      timestamp: Date.now(),
    };
  }
}

async function weGottaGoBald(collection, userId) {
  try {
    if (userId === "all") {
      const allUsers = await returnAPIKeys();
      let allDropsSuccessful = true;

      for (const user of allUsers) {
        if (collection === "all") {
          const allCollections = [
            await retrieveConfigValue("milvus.collections.user"),
            await retrieveConfigValue("milvus.collections.intelligence"),
            await retrieveConfigValue("milvus.collections.chat"),
            await retrieveConfigValue("milvus.collections.voice"),
          ];
          for (const coll of allCollections) {
            const success = await dropCollection(coll, user.user_id);
            if (!success) {
              allDropsSuccessful = false;
            }
          }
        } else {
          const success = await dropCollection(collection, user.user_id);
          if (!success) {
            allDropsSuccessful = false;
          }
        }
      }
      return allDropsSuccessful;
    } else {
      return await dropCollection(collection, userId);
    }
  } catch (error) {
    logger.log("Milvus", `Error during database reload: ${error}`);
    return false;
  }
}

async function dropCollection(collection, userId) {
  const collectionName = `${collection}_${userId}`;
  try {
    const exists = await client.hasCollection({
      collection_name: collectionName,
    });

    if (!exists.value) {
      logger.log("Milvus", `Collection '${collectionName}' does not exist.`);
      return false;
    }

    const status = await client.dropCollection({
      collection_name: collectionName,
    });

    if (status.error_code === "Success") {
      logger.log(
        "Milvus",
        `Collection '${collectionName}' dropped successfully.`
      );
      return true;
    } else {
      logger.log(
        "Milvus",
        `Failed to drop collection '${collectionName}'. Reason: ${status.reason}`
      );
      return false;
    }
  } catch (error) {
    logger.log(
      "Milvus",
      `Error dropping collection '${collectionName}': ${error}`
    );
    return false;
  }
}

const isValidJson = (input) => {
  if (typeof input === "string") {
    try {
      JSON.parse(input);
      return true;
    } catch {
      return false;
    }
  } else if (typeof input === "object" && input !== null) {
    return true;
  }
  return false;
};

async function checkEndpoint(endpoint, key, modelName) {
  try {
    if (endpoint === (await retrieveConfigValue("models.embedding.endpoint"))) {
      if (
        (await retrieveConfigValue("models.embedding.apiKeyType")) ===
        "infinity"
      ) {
        const response = await axios.get(`${endpoint}/models`, {
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json",
          },
          validateStatus: (status) => status < 500,
        });

        if (
          response.status === 200 &&
          response.data &&
          Array.isArray(response.data.data)
        ) {
          const modelFound = response.data.data.some(
            (model) => model.id === modelName
          );
          if (modelFound) {
            return true;
          } else {
            throw new Error(
              `Model ${modelName} not found in the list of available models.`
            );
          }
        } else {
          throw new Error(
            `Invalid response from embedding endpoint: ${response.status}`
          );
        }
      } else if (
        (await retrieveConfigValue("models.embedding.apiKeyType")) ===
        "enspiraEmb"
      ) {
        const response = await axios.get(
          `${await retrieveConfigValue("models.embedding.endpoint")}/health`,
          {
            headers: {
              Authorization: `Bearer ${await retrieveConfigValue("models.embedding.apiKey")}`,
            },
          }
        );
        if (response.status == 200) {
          return true;
        } else {
          return false;
        }
      }
    } else {
      const openai = new OpenAI({
        baseURL: endpoint,
        apiKey: key,
      });
      const response = await openai.models.list();
      if (
        response.data &&
        Array.isArray(response.data) &&
        response.data.length > 0
      ) {
        return true;
      } else {
        throw new Error(`Invalid or empty response from LLM endpoint`);
      }
    }
  } catch (err) {
    logger.log("INIT", `Error checking endpoint ${endpoint}: ${err}`);
    return false;
  }
}

// ==================== EXPORTS ====================
export {
  checkEndpoint,
  respondWithContext,
  checkMilvusHealth,
  rerankString,
  searchBraveAPI,
  addVoiceMessageAsVector,
  loadCollectionIfNeeded,
  addChatMessageAsVector,
  insertAugmentVectorsToMilvus,
  respondWithoutContext,
  respondWithVoice,
  respondToEvent,
  processFiles,
  startIndexingVectors,
  findRelevantVoiceInMilvus,
  findRelevantDocuments,
  weGottaGoBald,
  checkAndCreateCollection,
  returnRecentChats,
  ensureCollectionLoaded,
  retryMilvusOperation,
  getOptimizedSearchParams,
  scheduleVectorInsertion,
  processVectorBatch,
  getCachedResult,
  setCachedResult,
  clearQueryCache,
  checkMilvusHealthDetailed,
  // Legacy function exports for backward compatibility
  returnCollectionSchema,
  createCollection,
  getCollectionSchema,
  findRelevantChats,
  upsertIntelligenceToMilvus,
  insertVoiceVectorsIntoMilvus,
  respondWithContextAndExpressions,
  contextPromptChatWithExpressions
};
</file>

<file path="index.js">
import Fastify from "fastify";
import fs from "fs-extra";
import { join } from "path";
import { audioRoutes } from "./routes/audio.js";
import twitchEventSubRoutes from "./routes/twitch.js";
import * as aiHelper from "./ai-logic.js";
import webRoutes from "./routes/web.js";
import { initAllAPIs, returnAPIKeys } from "./api-helper.js";
import { preloadAllTokenizers } from "./token-helper.js";
import { retrieveConfigValue, loadConfig } from "./config-helper.js";
import routes from "./routes/v1.js";
import "./create-global-logger.js"; // This ensures the logger is properly set up
import { logger } from "./create-global-logger.js";
import fastifyCookie from "@fastify/cookie";
import * as crypto from "crypto";
import { setupTemplating } from "./template-engine.js";

process.on("uncaughtException", (err) => {
  logger.error("System", `UNCAUGHT EXCEPTION: ${err.message}`);
  logger.error("System", `Stack trace: ${err.stack}`);
  // Keep process alive for debugging
});

process.on("unhandledRejection", (reason, promise) => {
  logger.error("System", `UNHANDLED REJECTION: ${reason}`);
  logger.error(
    "System",
    `Stack trace: ${reason?.stack || "No stack trace available"}`
  );
  // Keep process alive for debugging
});

// Create the fastify instance
const createServer = async () => {
  // Check if certificates exist, if not create HTTP server for development
  const certPath = join(process.cwd(), "self_signed.crt");
  const keyPath = join(process.cwd(), "self_signed.key");

  let serverOptions = {
    trustProxy: true,
    methodNotAllowed: true,
    logger: false,
    requestTimeout: 30000,
    bodyLimit: 10485760, // 10MB for request body size
    maxParamLength: 2000, // Increase param length limit
  };

  // Only use HTTPS if certificates exist
  if ((await fs.pathExists(certPath)) && (await fs.pathExists(keyPath))) {
    serverOptions.https = {
      allowHTTP1: true,
      key: await fs.readFile(keyPath),
      cert: await fs.readFile(certPath),
    };
    serverOptions.http2 = true;
    // Add HTTP/1 header size configuration
    serverOptions.http = {
      maxHeaderSize: 81920, // 80KB
      keepAliveTimeout: 120000, // 2 minutes
      headersTimeout: 65000, // 65 seconds
    };
    logger.log(
      "Server",
      "HTTPS server configured with self-signed certificates"
    );
  } else {
    logger.warn(
      "Server",
      "SSL certificates not found, running HTTP server for development"
    );
  }

  const fastify = Fastify(serverOptions);

  await fastify.register(fastifyCookie, {
    secret:
      (await retrieveConfigValue("server.cookieSecret")) ||
      crypto.randomBytes(32).toString("hex"),
    parseOptions: {},
  });

  await fastify.register(import("@fastify/multipart"), {
    limits: {
      fieldNameSize: 100,
      fieldSize: 1000000,
      fields: 20,
      fileSize: 5000000,
      files: 5,
      headerPairs: 2000,
    },
    attachFieldsToBody: true,
  });

  fastify.setErrorHandler((error, request, reply) => {
    if (
      error instanceof Fastify.errorCodes.FST_ERR_ROUTE_METHOD_NOT_SUPPORTED
    ) {
      reply.code(405).send({
        error: "Method Not Allowed",
        message: `HTTP method "${request.method}" is not supported for this route.`,
        allowedMethods: reply.context.config.allowedMethods,
      });
    } else {
      reply.send(error);
    }
  });

  await setupTemplating(fastify);

  // Register WebSocket plugin globally with proper error handling
  await fastify.register(import("@fastify/websocket"), {
    errorHandler: function (error, conn, req, reply) {
      logger.error("WebSocket", `WebSocket error: ${error.message}`);
    },
    preClose: function (done) {
      logger.log("WebSocket", "WebSocket server closing...");
      done();
    },
  });

  // Enhanced WebSocket connection tracking with proper state management
  // Enhanced WebSocket connection tracking with correct API
  const activeConnections = new Map();
  const connectionCleanupQueue = new Set();

  // Helper function to safely get connection state
  function getConnectionState(clientId) {
    const state = activeConnections.get(clientId);
    if (!state) {
      logger.warn("WebSocket", `Connection state not found for ${clientId}`);
      return null;
    }

    if (state.isDestroyed) {
      logger.warn("WebSocket", `Connection ${clientId} is marked as destroyed`);
      return null;
    }

    return state;
  }

  // Socket validation function
  function validateSocket(socket, clientId) {
    if (!socket) {
      logger.warn("WebSocket", `Socket is null/undefined for ${clientId}`);
      return false;
    }

    if (typeof socket.send !== "function") {
      logger.error(
        "WebSocket",
        `Socket for ${clientId} is not a valid WebSocket - missing send method`
      );
      return false;
    }

    const readyState = socket.readyState;
    if (readyState === undefined || readyState === null) {
      logger.warn(
        "WebSocket",
        `Socket for ${clientId} has invalid readyState: ${readyState}`
      );
      return false;
    }

    return true;
  }

  // FIXED: WebSocket route using the correct API pattern
  fastify.register(async function (fastify) {
    fastify.get(
      "/ws-client",
      {
        websocket: true,
        preHandler: async (request, reply) => {
          reply.header("Access-Control-Allow-Origin", "*");
          reply.header(
            "Access-Control-Allow-Methods",
            "GET, POST, PUT, DELETE, OPTIONS"
          );
          reply.header(
            "Access-Control-Allow-Headers",
            "Content-Type, Authorization"
          );
        },
      },
      // FIXED: Correct handler signature - socket is the first parameter
      async (socket, request) => {
        const clientId = `client_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`;
        const clientIP =
          request.ip || request.socket.remoteAddress || "unknown";

        logger.log(
          "WebSocket",
          `New client connecting: ${clientId} from ${clientIP}`
        );

        // FIXED: Direct socket validation - no connection object
        if (!validateSocket(socket, clientId)) {
          logger.error("WebSocket", `Socket validation failed for ${clientId}`);
          try {
            socket.close(1003, "Socket validation failed");
          } catch (closeError) {
            logger.error(
              "WebSocket",
              `Error closing invalid socket: ${closeError.message}`
            );
          }
          return;
        }

        logger.log(
          "WebSocket",
          `Socket validation passed for ${clientId} - readyState: ${socket.readyState}`
        );

        // FIXED: Enhanced connection state with direct socket reference
        const connectionState = {
          id: clientId,
          socket: socket, // Direct socket reference
          user: null,
          isAuthenticated: false,
          lastPingTime: Date.now(),
          modelInfo: null,
          currentResponseId: null,
          connectedAt: new Date(),
          isDestroyed: false,
          processingMessage: false,
          sendInProgress: false,
          connectionIP: clientIP,
          messageCount: 0,
          lastActivity: Date.now(),
          authAttempts: 0,
          maxAuthAttempts: 3,
        };

        // Store connection
        activeConnections.set(clientId, connectionState);
        logger.log(
          "WebSocket",
          `Connection ${clientId} stored - Active connections: ${activeConnections.size}`
        );

        // Enhanced message sending function
        function sendMessage(message, retryCount = 0) {
          const maxRetries = 2;

          try {
            const state = getConnectionState(clientId);
            if (!state) {
              logger.error(
                "WebSocket",
                `Cannot send message - connection state not found for ${clientId}`
              );
              return false;
            }

            if (connectionCleanupQueue.has(clientId)) {
              logger.warn(
                "WebSocket",
                `Cannot send message - ${clientId} is being cleaned up`
              );
              return false;
            }

            if (state.sendInProgress) {
              if (retryCount < maxRetries) {
                setTimeout(
                  () => sendMessage(message, retryCount + 1),
                  100 * (retryCount + 1)
                );
                return true;
              } else {
                logger.warn(
                  "WebSocket",
                  `Send still in progress for ${clientId} after retries, dropping message`
                );
                return false;
              }
            }

            state.sendInProgress = true;

            const currentSocket = state.socket;
            if (!validateSocket(currentSocket, clientId)) {
              logger.warn(
                "WebSocket",
                `Socket validation failed during send for ${clientId}`
              );
              state.sendInProgress = false;
              return false;
            }

            // Check socket state
            const WebSocketStates = {
              CONNECTING: 0,
              OPEN: 1,
              CLOSING: 2,
              CLOSED: 3,
            };

            if (currentSocket.readyState !== WebSocketStates.OPEN) {
              logger.warn(
                "WebSocket",
                `Cannot send to ${clientId} - socket not open (state: ${currentSocket.readyState})`
              );
              state.sendInProgress = false;
              return false;
            }

            // Create and send message
            const messageToSend = JSON.stringify({
              timestamp: new Date().toISOString(),
              client_id: clientId,
              server_time: new Date().toISOString(),
              ...message,
            });

            try {
              currentSocket.send(messageToSend);

              // Update activity tracking
              state.lastActivity = Date.now();
              state.messageCount++;

              logger.log(
                "WebSocket",
                `Message sent successfully to ${clientId}: ${message.type} (total: ${state.messageCount})`
              );

              state.sendInProgress = false;
              return true;
            } catch (sendError) {
              logger.error(
                "WebSocket",
                `Send operation failed for ${clientId}: ${sendError.message}`
              );
              state.sendInProgress = false;

              if (
                retryCount < maxRetries &&
                !sendError.message.includes("ENOTCONN")
              ) {
                logger.log(
                  "WebSocket",
                  `Retrying send for ${clientId} (attempt ${retryCount + 1})`
                );
                setTimeout(
                  () => sendMessage(message, retryCount + 1),
                  200 * (retryCount + 1)
                );
                return true;
              }

              return false;
            }
          } catch (error) {
            const state = getConnectionState(clientId);
            if (state) {
              state.sendInProgress = false;
            }

            logger.error(
              "WebSocket",
              `Failed to send message to ${clientId}: ${error.message}`
            );
            return false;
          }
        }

        // Authentication function
        async function authenticateMessage(message) {
          const state = getConnectionState(clientId);
          if (!state) return null;

          state.authAttempts++;
          if (state.authAttempts > state.maxAuthAttempts) {
            logger.warn(
              "WebSocket",
              `Too many auth attempts for ${clientId}, blocking`
            );
            return null;
          }

          logger.log(
            "WebSocket",
            `Authentication attempt ${state.authAttempts}/${state.maxAuthAttempts} for ${clientId}:`,
            {
              hasAuthToken: !!message.auth_token,
              tokenLength: message.auth_token?.length || 0,
              messageType: message.type,
            }
          );

          if (!message.auth_token) {
            logger.warn(
              "WebSocket",
              `No auth_token in message from ${clientId}`
            );
            return null;
          }

          try {
            const { checkForAuth } = await import("./api-helper.js");
            const authResult = await checkForAuth(message.auth_token);

            if (authResult && authResult.valid) {
              logger.log(
                "WebSocket",
                `Authentication successful for ${clientId}: user ${authResult.user_id}`
              );
              state.authAttempts = 0;
              return authResult;
            } else {
              logger.warn(
                "WebSocket",
                `Authentication failed for ${clientId}: invalid token`
              );
              return null;
            }
          } catch (error) {
            logger.error(
              "WebSocket",
              `Authentication error for ${clientId}: ${error.message}`
            );
            return null;
          }
        }

        // Connection cleanup function
        function cleanupConnection(reason = "unknown") {
          if (connectionCleanupQueue.has(clientId)) {
            logger.log(
              "WebSocket",
              `Cleanup already in progress for ${clientId}`
            );
            return;
          }

          connectionCleanupQueue.add(clientId);
          logger.log(
            "WebSocket",
            `Starting cleanup for ${clientId} - reason: ${reason}`
          );

          try {
            const state = activeConnections.get(clientId);
            if (state) {
              state.isDestroyed = true;
              state.socket = null;

              logger.log(
                "WebSocket",
                `Connection ${clientId} stats: ${state.messageCount} messages, active for ${Date.now() - state.connectedAt.getTime()}ms`
              );
            }

            if (heartbeatInterval) {
              clearInterval(heartbeatInterval);
            }

            activeConnections.delete(clientId);

            logger.log(
              "WebSocket",
              `Cleanup completed for ${clientId} - Active connections: ${activeConnections.size}`
            );
          } catch (error) {
            logger.error(
              "WebSocket",
              `Error during cleanup for ${clientId}: ${error.message}`
            );
          } finally {
            connectionCleanupQueue.delete(clientId);
          }
        }

        // Heartbeat with proper socket validation
        const heartbeatInterval = setInterval(() => {
          try {
            const state = getConnectionState(clientId);
            if (!state) {
              logger.log(
                "WebSocket",
                `No valid state for ${clientId} in heartbeat, cleaning up`
              );
              clearInterval(heartbeatInterval);
              return;
            }

            if (connectionCleanupQueue.has(clientId)) {
              logger.log(
                "WebSocket",
                `Connection ${clientId} is being cleaned up, stopping heartbeat`
              );
              clearInterval(heartbeatInterval);
              return;
            }

            const currentSocket = state.socket;
            if (
              !validateSocket(currentSocket, clientId) ||
              currentSocket.readyState !== 1
            ) {
              logger.log(
                "WebSocket",
                `Socket not available for ${clientId} in heartbeat, cleaning up`
              );
              clearInterval(heartbeatInterval);
              cleanupConnection("heartbeat_socket_unavailable");
              return;
            }

            const pingSuccess = sendMessage({ type: "ping" });
            if (!pingSuccess) {
              logger.warn("WebSocket", `Failed to send ping to ${clientId}`);
            }

            // Check for stale connections
            const timeSinceLastPing = Date.now() - state.lastPingTime;
            const timeSinceLastActivity = Date.now() - state.lastActivity;

            if (timeSinceLastPing > 90000 || timeSinceLastActivity > 120000) {
              logger.warn(
                "WebSocket",
                `Connection ${clientId} is stale, closing`
              );
              try {
                currentSocket.close(1000, "Connection timeout");
              } catch (error) {
                logger.error(
                  "WebSocket",
                  `Error closing stale connection ${clientId}: ${error.message}`
                );
              }
              cleanupConnection("stale_connection");
            }
          } catch (error) {
            logger.error(
              "WebSocket",
              `Error in heartbeat for ${clientId}: ${error.message}`
            );
            clearInterval(heartbeatInterval);
            cleanupConnection("heartbeat_error");
          }
        }, 30000);

        // FIXED: Message handler using direct socket API
        socket.on("message", async (data) => {
          try {
            const state = getConnectionState(clientId);
            if (!state) {
              logger.warn(
                "WebSocket",
                `Received message for invalid connection ${clientId}`
              );
              return;
            }

            if (connectionCleanupQueue.has(clientId)) {
              logger.warn(
                "WebSocket",
                `Ignoring message for ${clientId} - cleanup in progress`
              );
              return;
            }

            state.processingMessage = true;
            state.lastActivity = Date.now();

            let message;
            try {
              message = JSON.parse(data.toString());
            } catch (parseError) {
              logger.error(
                "WebSocket",
                `Failed to parse message from ${clientId}: ${parseError.message}`
              );
              sendMessage({
                type: "error",
                message: "Invalid message format",
              });
              state.processingMessage = false;
              return;
            }

            logger.log(
              "WebSocket",
              `Processing ${message.type} from ${clientId} (msg #${state.messageCount + 1})`
            );

            // Handle authentication for non-system messages
            if (
              !state.isAuthenticated &&
              message.type !== "ping" &&
              message.type !== "pong"
            ) {
              const user = await authenticateMessage(message);

              if (!user) {
                sendMessage({
                  type: "auth-failed",
                  message: "Invalid or missing authentication token",
                });
                state.processingMessage = false;
                return;
              }

              state.user = user;
              state.isAuthenticated = true;

              sendMessage({
                type: "auth-success",
                message: "Authentication successful",
                user_id: user.user_id,
              });

              logger.log(
                "WebSocket",
                `Client ${clientId} authenticated as user: ${user.user_id}`
              );
            }

            // Process message types
            switch (message.type) {
              case "ping":
                sendMessage({ type: "pong" });
                break;

              case "pong":
                state.lastPingTime = Date.now();
                break;

              case "model-info":
                if (state.isAuthenticated && message.model_info) {
                  state.modelInfo = message.model_info;
                  logger.log(
                    "WebSocket",
                    `Model info received for ${clientId}: ${message.model_info.name || "Unknown"}`
                  );
                  sendMessage({
                    type: "model-info-received",
                    message: "Model information updated successfully",
                  });
                }
                break;

              case "text-input":
                if (state.isAuthenticated) {
                  await handleTextInput(state, message);
                } else {
                  sendMessage({
                    type: "error",
                    message: "Authentication required for text input",
                  });
                }
                break;

              case "interrupt":
                if (state.isAuthenticated) {
                  handleInterrupt(state);
                }
                break;

              case "connection-test":
                sendMessage({
                  type: "connection-test-response",
                  message: "Connection is working properly",
                  client_id: clientId,
                  connection_stats: {
                    messages_processed: state.messageCount,
                    connected_duration:
                      Date.now() - state.connectedAt.getTime(),
                    last_activity: state.lastActivity,
                  },
                });
                break;

              default:
                logger.warn(
                  "WebSocket",
                  `Unknown message type: ${message.type} from ${clientId}`
                );
                sendMessage({
                  type: "error",
                  message: `Unknown message type: ${message.type}`,
                });
            }
          } catch (error) {
            logger.error(
              "WebSocket",
              `Error processing message from ${clientId}: ${error.message}`
            );
            sendMessage({
              type: "error",
              message: "Failed to process message",
            });
          } finally {
            const state = getConnectionState(clientId);
            if (state) {
              state.processingMessage = false;
            }
          }
        });

        // Text input handler
        async function handleTextInput(connectionState, message) {
          const { user } = connectionState;

          if (!message.text || !message.text.trim()) {
            sendMessage({
              type: "error",
              message: "Empty text input received",
            });
            return;
          }

          const responseId = `resp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          connectionState.currentResponseId = responseId;

          try {
            sendMessage({
              type: "response-queued",
              response_id: responseId,
            });

            // FIXED: Apply alternateSpell replacements for vocal inputs
            let processedText = await applyAlternateSpelling(
              message.text,
              user.user_id
            );

            logger.log(
              "WebSocket",
              `Processing text input for user ${user.user_id}: "${processedText.substring(0, 50)}..."`
            );

            // FIXED: Enhanced chat response with better error handling and logging
            const chatResponse = await aiHelper.respondToChat(
              {
                message: processedText,
                user: user.user_name || "User",
              },
              user.user_id
            );

            // FIXED: Better error handling and response validation
            if (!chatResponse) {
              logger.error(
                "WebSocket",
                `No response object returned for user ${user.user_id}`
              );
              throw new Error("No response generated from AI system");
            }

            if (!chatResponse.success) {
              logger.error(
                "WebSocket",
                `AI response failed for user ${user.user_id}: ${chatResponse.error}`
              );
              throw new Error(
                chatResponse.error || "Failed to generate response"
              );
            }

            if (!chatResponse.text || chatResponse.text.trim() === "") {
              logger.error(
                "WebSocket",
                `Empty response text for user ${user.user_id}`
              );
              throw new Error("AI generated empty response");
            }

            // FIXED: Send the text response immediately
            sendMessage({
              type: "full-text",
              text: chatResponse.text,
              response_id: responseId,
            });

            logger.log(
              "WebSocket",
              `Text response sent for user ${user.user_id}: "${chatResponse.text.substring(0, 50)}..."`
            );

            // FIXED: Enhanced TTS generation with better error handling
            if (user.tts_enabled) {
              await generateAndSendAudio(
                connectionState,
                chatResponse.text,
                responseId
              );
            } else {
              logger.log(
                "WebSocket",
                `TTS disabled for user ${user.user_id}, skipping audio generation`
              );
              // Still mark the response as complete
              sendMessage({
                type: "synthesis-complete",
                response_id: responseId,
              });
            }

            logger.log(
              "WebSocket",
              `Response completed successfully for user ${user.user_id} (${clientId})`
            );
          } catch (error) {
            logger.error(
              "WebSocket",
              `Error processing text input for ${clientId}: ${error.message}`
            );

            // FIXED: Send proper error response
            sendMessage({
              type: "error",
              message: "Failed to generate response: " + error.message,
              response_id: responseId,
            });

            // Reset AI state if this was set
            connectionState.currentResponseId = null;
          }
        }

        /**
         * FIXED: Apply alternate spelling replacements for vocal inputs
         * @param {string} text - The original text from speech recognition
         * @param {string} userId - User ID for getting alternate spellings
         * @returns {Promise<string>} - Text with alternate spellings replaced
         */
        async function applyAlternateSpelling(text, userId) {
          try {
            const userObj = await import("./api-helper.js").then((m) =>
              m.returnAuthObject(userId)
            );

            if (
              !userObj ||
              !userObj.alternateSpell ||
              !Array.isArray(userObj.alternateSpell)
            ) {
              // No alternate spellings configured, return original text
              return text;
            }

            let processedText = text;

            // Apply each alternate spelling replacement
            for (const alternateEntry of userObj.alternateSpell) {
              if (typeof alternateEntry === "string") {
                // Simple string replacement - replace with bot name
                const regex = new RegExp(
                  `\\b${escapeRegExp(alternateEntry)}\\b`,
                  "gi"
                );
                processedText = processedText.replace(regex, userObj.bot_name);

                logger.log(
                  "WebSocket",
                  `Replaced "${alternateEntry}" with "${userObj.bot_name}" in vocal input`
                );
              } else if (
                typeof alternateEntry === "object" &&
                alternateEntry.from &&
                alternateEntry.to
              ) {
                // Object with from/to mapping
                const regex = new RegExp(
                  `\\b${escapeRegExp(alternateEntry.from)}\\b`,
                  "gi"
                );
                processedText = processedText.replace(regex, alternateEntry.to);

                logger.log(
                  "WebSocket",
                  `Replaced "${alternateEntry.from}" with "${alternateEntry.to}" in vocal input`
                );
              }
            }

            return processedText;
          } catch (error) {
            logger.error(
              "WebSocket",
              `Error applying alternate spelling: ${error.message}`
            );
            return text; // Return original text if replacement fails
          }
        }

        /**
         * Escape special regex characters
         * @param {string} string - String to escape
         * @returns {string} - Escaped string
         */
        function escapeRegExp(string) {
          return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }

        // Audio generation
        async function generateAndSendAudio(connectionState, text, responseId) {
          const { user, modelInfo } = connectionState;

          try {
            sendMessage({
              type: "synthesis-started",
              response_id: responseId,
            });

            logger.log(
              "WebSocket",
              `Generating TTS audio for user ${user.user_id} (${clientId})`
            );

            const audioResult = await aiHelper.respondWithVoice(
              text,
              user.user_id
            );

            if (audioResult.error) {
              throw new Error(audioResult.error);
            }

            // FIXED: Send audio URL directly instead of converting to base64
            sendMessage({
              type: "synthesis-complete",
              response_id: responseId,
            });

            const displayText = {
              text: text,
              name: user.bot_name || "Assistant",
              avatar: user.avatar_url || "",
            };

            const actions = {};
            if (
              modelInfo &&
              modelInfo.expressions &&
              Array.isArray(modelInfo.expressions)
            ) {
              actions.expressions = selectExpressions(
                text,
                modelInfo.expressions
              );
            }

            // UPDATED: Send audio URL instead of base64 data
            sendMessage({
              type: "audio-url", // Changed message type to indicate URL format
              audio_url: audioResult, // Direct URL instead of base64
              display_text: displayText,
              actions: Object.keys(actions).length > 0 ? actions : undefined,
              response_id: responseId,
              audio_format: "wav", // Additional metadata for client
              sample_rate: 22050, // TTS output format info
              bit_depth: 16, // TTS output format info
            });

            logger.log(
              "WebSocket",
              `Audio URL sent for user ${user.user_id} (${clientId}): ${audioResult}`
            );
          } catch (error) {
            logger.error(
              "WebSocket",
              `Error generating audio for ${user.user_id} (${clientId}): ${error.message}`
            );
            sendMessage({
              type: "error",
              message: "Failed to generate audio response",
              response_id: responseId,
              error_details: error.message,
            });
          }
        }

        function handleInterrupt(connectionState) {
          const { user } = connectionState;
          logger.log(
            "WebSocket",
            `Interrupt received from user ${user?.user_id || "unknown"} (${clientId})`
          );
          connectionState.currentResponseId = null;
          sendMessage({
            type: "interrupt",
            message: "Response interrupted",
          });
        }

        // FIXED: Connection close handler using direct socket API
        socket.on("close", (code, reason) => {
          logger.log(
            "WebSocket",
            `Client ${clientId} disconnected: ${code} - ${reason || "no reason"}`
          );
          cleanupConnection(`close_${code}`);
        });

        // FIXED: Error handler using direct socket API
        socket.on("error", (error) => {
          logger.error(
            "WebSocket",
            `Socket error for ${clientId}: ${error.message}`
          );
          cleanupConnection(`error_${error.message}`);
        });

        // Send initial messages with proper timing
        setTimeout(() => {
          const state = getConnectionState(clientId);
          if (!state) {
            logger.error(
              "WebSocket",
              `Connection ${clientId} not available for initial messages`
            );
            return;
          }

          if (!validateSocket(state.socket, clientId)) {
            logger.error(
              "WebSocket",
              `Socket invalid for initial messages ${clientId}`
            );
            cleanupConnection("invalid_socket_initial");
            return;
          }

          const establishmentSuccess = sendMessage({
            type: "connection-established",
            client_id: clientId,
            server_time: new Date().toISOString(),
            server_info: {
              version: "1.0.0",
              capabilities: ["text-input", "model-info", "audio", "interrupt"],
            },
          });

          if (establishmentSuccess) {
            setTimeout(() => {
              const currentState = getConnectionState(clientId);
              if (
                currentState &&
                validateSocket(currentState.socket, clientId)
              ) {
                sendMessage({
                  type: "auth-required",
                  message: "Please provide authentication token",
                });
              }
            }, 200);
          }
        }, 300);

        logger.log(
          "WebSocket",
          `Client ${clientId} setup completed successfully`
        );
      }
    );
  });

  // Enhanced status endpoint
  fastify.get("/ws-status", async (request, reply) => {
    const connections = Array.from(activeConnections.values()).map((conn) => ({
      id: conn.id,
      authenticated: conn.isAuthenticated,
      user_id: conn.user?.user_id || null,
      connected_at: conn.connectedAt,
      socket_state:
        conn.socket?.readyState !== undefined
          ? conn.socket.readyState
          : "unknown",
      is_destroyed: conn.isDestroyed,
      processing_message: conn.processingMessage,
      send_in_progress: conn.sendInProgress,
      message_count: conn.messageCount,
      last_activity: conn.lastActivity,
      connection_ip: conn.connectionIP,
      auth_attempts: conn.authAttempts,
    }));

    return {
      websocket_enabled: true,
      active_connections: activeConnections.size,
      cleanup_queue_size: connectionCleanupQueue.size,
      connections: connections,
      system_info: {
        uptime: process.uptime(),
        memory_usage: process.memoryUsage(),
        timestamp: new Date().toISOString(),
      },
    };
  });

  logger.log(
    "WebSocket",
    "Fixed VTuber WebSocket route registered at /ws-client"
  );

  /**
   * Expression selection utility
   */
  function selectExpressions(text, availableExpressions) {
    const emotionKeywords = {
      happy: [
        "happy",
        "joy",
        "excited",
        "great",
        "awesome",
        "wonderful",
        "amazing",
        "!",
        "😊",
        "😄",
      ],
      sad: [
        "sad",
        "sorry",
        "disappointed",
        "unfortunate",
        "regret",
        "😢",
        "😞",
      ],
      surprised: [
        "wow",
        "amazing",
        "incredible",
        "unbelievable",
        "surprise",
        "!",
        "😮",
        "😲",
      ],
      angry: ["angry", "frustrated", "annoyed", "mad", "irritated", "😠", "😡"],
      neutral: ["hello", "hi", "okay", "alright", "yes", "no", "maybe"],
    };

    const textLower = text.toLowerCase();
    let detectedEmotion = "neutral";
    let maxMatches = 0;

    for (const [emotion, keywords] of Object.entries(emotionKeywords)) {
      const matches = keywords.filter((keyword) =>
        textLower.includes(keyword)
      ).length;
      if (matches > maxMatches) {
        maxMatches = matches;
        detectedEmotion = emotion;
      }
    }

    const expressionMapping = {
      happy: ["smile", "happy", "joy", "cheerful", 0, 1],
      sad: ["sad", "disappointed", "down", 2, 3],
      surprised: ["surprised", "shock", "amazed", 4, 5],
      angry: ["angry", "mad", "annoyed", 6, 7],
      neutral: ["neutral", "default", "calm", 8, 9],
    };

    const possibleExpressions =
      expressionMapping[detectedEmotion] || expressionMapping.neutral;
    const selectedExpressions = [];

    for (const expr of possibleExpressions) {
      if (availableExpressions.includes(expr)) {
        selectedExpressions.push(expr);
        break;
      }
    }

    if (selectedExpressions.length === 0 && availableExpressions.length > 0) {
      selectedExpressions.push(availableExpressions[0]);
    }

    return selectedExpressions;
  }

  logger.log("WebSocket", "VTuber WebSocket route registered at /ws-client");

  // Register other routes
  await fastify.register(routes, { prefix: "/api/v1" });
  await fastify.register(audioRoutes, {
    outputDir: "final",
    prefix: "/files/audio",
    addContentDisposition: true,
  });
  await fastify.register(twitchEventSubRoutes, { prefix: "/api/v1/twitch" });
  await fastify.register(webRoutes, { prefix: "/web" });

  return fastify;
};

/**
 * Preflight checks
 */
export async function preflightChecks() {
  try {
    const axios = (await import("axios")).default;
    let ttsRes = { status: 0 };
    const ttsPreference = await retrieveConfigValue("ttsPreference");

    try {
      switch (ttsPreference) {
        case "fish":
          ttsRes = await axios.get(
            await retrieveConfigValue("fishTTS.healthcheck.internal")
          );
          break;
        case "alltalk":
          ttsRes = await axios.get(
            await retrieveConfigValue("alltalk.healthcheck.internal")
          );
          break;
        default:
          ttsRes = { status: 200 };
          break;
      }
    } catch (ttsError) {
      logger.log("API", `TTS healthcheck error: ${ttsError.message}`);
    }

    logger.log(
      "API",
      `Current TTS engine: ${ttsPreference}, ${ttsRes.status == 200 ? "is alive." : "is not alive."}`
    );
    const databaseRes = await aiHelper.checkMilvusHealth();

    return {
      llmStatuses: {
        allTalkIsOnline: ttsRes.status == 200 ? true : false,
        embeddingIsOnline: await aiHelper.checkEndpoint(
          await retrieveConfigValue("models.embedding.endpoint"),
          await retrieveConfigValue("models.embedding.apiKey"),
          await retrieveConfigValue("models.embedding.model")
        ),
        llmIsOnline: await aiHelper.checkEndpoint(
          await retrieveConfigValue("models.chat.endpoint"),
          await retrieveConfigValue("models.chat.apiKey"),
          await retrieveConfigValue("models.chat.model")
        ),
        summaryIsOnline: await aiHelper.checkEndpoint(
          await retrieveConfigValue("models.summary.endpoint"),
          await retrieveConfigValue("models.summary.apiKey"),
          await retrieveConfigValue("models.summary.model")
        ),
        queryIsOnline: await aiHelper.checkEndpoint(
          await retrieveConfigValue("models.query.endpoint"),
          await retrieveConfigValue("models.query.apiKey"),
          await retrieveConfigValue("models.query.model")
        ),
        conversionIsOnline: await aiHelper.checkEndpoint(
          await retrieveConfigValue("models.conversion.endpoint"),
          await retrieveConfigValue("models.conversion.apiKey"),
          await retrieveConfigValue("models.conversion.model")
        ),
      },
      restIsOnline: true,
      dbIsOnline: databaseRes,
      websocketEnabled: true,
    };
  } catch (error) {
    logger.error("System", `Error during preflight checks: ${error.message}`);
    return {
      llmStatuses: {
        allTalkIsOnline: false,
        embeddingIsOnline: false,
        llmIsOnline: false,
        summaryIsOnline: false,
        queryIsOnline: false,
        conversionIsOnline: false,
      },
      restIsOnline: false,
      dbIsOnline: false,
      websocketEnabled: false,
    };
  }
}

/**
 * Server launch
 */
export async function launchRest(fastify) {
  const portNum = await retrieveConfigValue("server.port");
  const internalHost = await retrieveConfigValue("server.endpoints.internal");

  try {
    await fastify.listen({ port: portNum, host: internalHost });

    const isHttps = fastify.initialConfig.https ? true : false;
    const protocol = isHttps ? "https" : "http";
    const wsProtocol = isHttps ? "wss" : "ws";

    logger.log(
      "API",
      `Fastify server launched successfully on ${protocol}://${internalHost}:${portNum}`
    );
    logger.log(
      "WebSocket",
      `WebSocket endpoint available at ${wsProtocol}://${internalHost}:${portNum}/ws-client`
    );
    logger.log(
      "WebSocket",
      `WebSocket status endpoint available at ${protocol}://${internalHost}:${portNum}/ws-status`
    );

    return Promise.resolve();
  } catch (err) {
    logger.error("API", `Failed to launch API server with error: ${err}`);
    await fs.writeFile("./error.txt", JSON.stringify(err));
    throw err;
  }
}

/**
 * Application initialization
 */
export async function initializeApp() {
  try {
    const allUsers = await returnAPIKeys();

    const collectionNames = [
      await retrieveConfigValue("milvus.collections.user"),
      await retrieveConfigValue("milvus.collections.intelligence"),
      await retrieveConfigValue("milvus.collections.chat"),
      await retrieveConfigValue("milvus.collections.voice"),
    ];

    await loadConfig();
    for await (const user of allUsers) {
      for await (const collectionName of collectionNames) {
        try {
          const collectionExists = await aiHelper.checkAndCreateCollection(
            collectionName,
            user.user_id
          );
          if (!collectionExists) {
            logger.error(
              "Milvus",
              `Failed to create collection ${collectionName} for user ${user.user_id}`
            );
            continue;
          }

          const isLoaded = await aiHelper.loadCollectionIfNeeded(
            collectionName,
            user.user_id
          );
          if (!isLoaded) {
            logger.error(
              "Milvus",
              `Failed to load collection ${collectionName} for user ${user.user_id}`
            );
            continue;
          }
        } catch (error) {
          logger.error(
            "Milvus",
            `Error with collection ${collectionName} for user ${user.user_id}: ${error.message}`
          );
          continue;
        }
      }
    }

    await Promise.all(
      allUsers.map((user) => aiHelper.startIndexingVectors(user.user_id))
    );
    await preloadAllTokenizers();

    const server = await createServer();
    await launchRest(server);

    const status = await preflightChecks();
    await initAllAPIs();

    try {
      logger.log("System", "Importing Twitch EventSub manager...");
      const { registerAllUsersEventSub, setupTwitchCronJobs } = await import(
        "./twitch-eventsub-manager.js"
      );

      logger.log("System", "Registering Twitch EventSub subscriptions...");
      const eventSubResults = await registerAllUsersEventSub();
      logger.log(
        "System",
        `EventSub registration complete: ${eventSubResults.success} successful, ${eventSubResults.failures} failed`
      );

      logger.log("System", "Setting up Twitch cron jobs...");
      setupTwitchCronJobs();
    } catch (eventSubError) {
      logger.error(
        "System",
        `Error with Twitch integration: ${eventSubError.message}`
      );
    }

    logger.log("System", "Enspira is fully initialized and ready!");
    logger.log(
      "WebSocket",
      "VTuber WebSocket integration is active and ready for connections!"
    );

    return { server, status };
  } catch (error) {
    logger.error(
      "System",
      `Failed to initialize the application: ${error.message}`
    );
    throw error;
  }
}

if (import.meta.url === import.meta.main) {
  initializeApp().catch((err) => {
    logger.error("System", `Fatal error in application: ${err.message}`);
    process.exit(1);
  });
}

export default initializeApp;
</file>

<file path="routes/v1.js">
import * as aiHelper from "../ai-logic.js";
import { containsCharacterName, containsAuxBotName } from "../prompt-helper.js";
import {
  checkForAuth,
  updateUserParameter,
  returnAuthObject,
} from "../api-helper.js";
import { maintainVoiceContext } from "../data-helper.js";
import * as twitchHelper from "../twitch-helper.js";
import { retrieveConfigValue } from "../config-helper.js";
import moment from "moment";
import fastifyFormbody from "@fastify/formbody";
import cors from "@fastify/cors";
import fastifyCompress from "@fastify/compress";
import fs from "fs-extra";
import * as crypto from "crypto";
import path from "path";

async function requireAuth(request, reply) {
  // First check if cookies object exists
  if (!request.cookies) {
    logger.error(
      "Auth",
      "Cookie parser not available - make sure fastify-cookie is registered"
    );
    return reply.redirect("/web/auth/login");
  }

  const sessionToken = request.cookies.enspira_session;

  if (!sessionToken) {
    return reply.redirect("/web/auth/login");
  }

  try {
    // Verify and decode the session token
    const decoded = verifySessionToken(sessionToken);

    if (!decoded || !decoded.userId) {
      // Invalid token
      reply.clearCookie("enspira_session");
      return reply.redirect("/web/auth/login");
    }

    // Get user from database
    const user = await returnAuthObject(decoded.userId);

    if (!user) {
      // User doesn't exist
      reply.clearCookie("enspira_session");
      return reply.redirect("/web/auth/login");
    }

    // Add user to request for use in route handlers
    request.user = user;

    // Continue to route handler
    return;
  } catch (error) {
    logger.error("Auth", `Session validation error: ${error.message}`);
    reply.clearCookie("enspira_session");
    return reply.redirect("/web/auth/login");
  }
}

export function createSessionToken(userId, expiresIn = "7d") {
  // Create a token payload
  const payload = {
    userId,
    exp: Math.floor(Date.now() / 1000) + 60 * 60 * 24 * 7, // 7 days
  };

  // Sign the token
  const token = crypto
    .createHmac("sha256", process.env.COOKIE_SECRET || "enspira-secret-key")
    .update(JSON.stringify(payload))
    .digest("hex");

  // Return token and payload together
  return `${token}.${Buffer.from(JSON.stringify(payload)).toString("base64")}`;
}

// Function to verify a session token
export function verifySessionToken(token) {
  try {
    const [signature, payloadBase64] = token.split(".");

    // Decode the payload
    const payload = JSON.parse(Buffer.from(payloadBase64, "base64").toString());

    // Check if token is expired
    if (payload.exp < Math.floor(Date.now() / 1000)) {
      return null;
    }

    // Verify the signature
    const expectedSignature = crypto
      .createHmac("sha256", process.env.COOKIE_SECRET || "enspira-secret-key")
      .update(JSON.stringify(payload))
      .digest("hex");

    if (signature !== expectedSignature) {
      return null;
    }

    return payload;
  } catch (error) {
    logger.error("Auth", `Token verification error: ${error.message}`);
    return null;
  }
}

/**
 * Checks if the input contains a jailbreak attempt.
 * @param {string} input - The input string to check.
 * @returns {boolean} - True if the input contains a jailbreak attempt, false otherwise.
 */
function containsJailbreakAttempt(input) {
  const pattern =
    /\b(ignore|disregard|bypass|override|forget|delete|remove|disable|break|reset|unlock|nullify|circumvent|destroy)\b\s+(all\s+)?(previous\s+|prior\s+|any\s+)?(instructions?|prompts?|rules?|filters?|limitations?|constraints?|policies?|protocols?|restrictions?|directives?|guidelines?)/i;
  return pattern.test(input);
}

async function routes(fastify, options) {
  await configureResponseHandling(fastify);

  await fastify.register(import("@fastify/rate-limit"), {
    max: 100,
    timeWindow: "20 seconds",
  });

  await fastify.register(cors, {
    origin: true,
  });

  await fastify.register(fastifyCompress, {
    global: true,
    threshold: 1024, // Start compressing at 1KB
    encodings: ["gzip", "deflate", "br"],
    inflateIfDeflated: true, // Handle already compressed payloads
    zlibOptions: {
      level: 4, // Balance between compression level and CPU usage
      memLevel: 8, // Use more memory for better compression
      windowBits: 15, // Maximum window size
    },
  });
  await fastify.register(fastifyFormbody);

  fastify.setErrorHandler((error, request, reply) => {
    if (error && error.code === "FST_ERR_ROUTE_METHOD_NOT_SUPPORTED") {
      reply.code(405).send({
        error: "Method Not Allowed",
        message: `HTTP method "${request.method}" is not supported for this route.`,
        allowedMethods: reply.context.config.allowedMethods,
      });
      return reply;
    } else {
      reply.send(error);
      return reply;
    }
  });

  // Login POST handler
  fastify.post("/auth/login", async (request, reply) => {
    try {
      const { user_id, password } = request.body;

      if (!user_id || !password) {
        return reply.redirect(
          "/web/auth/auth/login?error=Missing+required+fields"
        );
      }

      // Get user
      const user = await returnAuthObject(user_id);

      if (!user) {
        return reply.redirect("/web/auth/login?error=Invalid+credentials");
      }

      // Check password
      if (!user.webPasswordHash || !user.webPasswordSalt) {
        return reply.redirect("/web/auth/login?error=No+password+set");
      }

      const passwordCorrect = await isPasswordCorrect(
        user.webPasswordHash,
        user.webPasswordSalt,
        user.webPasswordIterations || 20480,
        password
      );

      if (!passwordCorrect) {
        return reply.redirect("/web/auth/login?error=Invalid+credentials");
      }

      // Create session
      const sessionToken = createSessionToken(user_id);

      // Set cookie
      reply.setCookie("enspira_session", sessionToken, {
        path: "/",
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "lax",
        maxAge: 60 * 60 * 24 * 7, // 7 days
      });

      // Redirect to dashboard
      return reply.redirect("/web/dashboard");
    } catch (error) {
      logger.error("Auth", `Login error: ${error.message}`);
      return reply.redirect("/web/auth/auth/login?error=An+error+occurred");
    }
  });

  // Voice file upload endpoint
  // Updated server route to use the new JSON endpoint on the helper API
  fastify.post(
    "/character/voice-upload",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Debug logging
        logger.log(
          "Audio",
          `Voice upload request received for user ${user.user_id}`
        );

        // Extract file data from the request body
        const fileData = request.body.files || [];

        logger.log(
          "Audio",
          `Received ${fileData.length} files in Base64 format`
        );

        if (fileData.length === 0) {
          logger.error("Audio", "No files received in request");
          return reply.redirect("/web/character?error=No+files+uploaded");
        }

        // Validate file count
        if (fileData.length > 4) {
          logger.error("Audio", `Too many files: ${fileData.length}`);
          return reply.redirect("/web/character?error=Maximum+4+files+allowed");
        }

        // Process each file
        const processedFiles = [];

        for (const file of fileData) {
          try {
            // Validate the file data
            if (!file.name || !file.data) {
              logger.error("Audio", "Invalid file data: missing name or data");
              continue;
            }

            // Check file name
            if (!file.name.toLowerCase().endsWith(".wav")) {
              logger.error("Audio", `File ${file.name} is not a WAV file`);
              return reply.redirect(
                "/web/character?error=Only+WAV+files+are+accepted"
              );
            }

            // Decode Base64 data
            const base64Data = file.data.split(";base64,").pop();
            const buffer = Buffer.from(base64Data, "base64");

            // Check file size
            if (buffer.length > 3 * 1024 * 1024) {
              logger.error(
                "Audio",
                `File ${file.name} exceeds 3MB limit (${buffer.length} bytes)`
              );
              return reply.redirect(
                "/web/character?error=File+exceeds+3MB+limit"
              );
            }

            logger.log("Audio", `Decoded ${file.name}: ${buffer.length} bytes`);

            // Validate audio file - now using our lightweight parser
            const validationResult = await validateWavBuffer(buffer);

            if (!validationResult.valid) {
              logger.error(
                "Audio",
                `Audio validation failed for ${file.name}: ${validationResult.reason}`
              );
              return reply.redirect(
                `/web/character?error=${encodeURIComponent(validationResult.reason)}`
              );
            }

            // Add to processed files - we'll pass along the Base64 data directly
            processedFiles.push({
              name: file.name,
              data: file.data,
            });

            logger.log(
              "Audio",
              `Validated ${file.name}: sampleRate=${validationResult.sampleRate}Hz, duration=${validationResult.duration.toFixed(1)}s`
            );
          } catch (fileError) {
            logger.error(
              "Audio",
              `Error processing file ${file.name}: ${fileError.message}`
            );
            return reply.redirect("/web/character?error=Error+processing+file");
          }
        }

        // Check if we have any valid files
        if (processedFiles.length === 0) {
          logger.error("Audio", "No valid files found in request");
          return reply.redirect("/web/character?error=No+valid+files+uploaded");
        }

        // Get the base URL for the helper API
        const helperApiBase =
          (await retrieveConfigValue("voiceHelper.endpoint")) ||
          "http://localhost:3500";

        // Construct the JSON endpoint URL - now using the new create-json endpoint
        const helperApiEndpoint = `${helperApiBase}/voice/create-json`;

        // Log that we're sending files to the helper API
        logger.log(
          "Audio",
          `Sending ${processedFiles.length} files to voice helper API at ${helperApiEndpoint}`
        );

        // Send to helper API using JSON
        try {
          const axios = (await import("axios")).default;

          // Create the JSON payload
          const jsonPayload = {
            files: processedFiles,
          };

          // Send the request with JSON payload
          const response = await axios.post(
            `${helperApiEndpoint}?userID=${user.user_id}&characterName=${encodeURIComponent(user.bot_name || "character")}`,
            jsonPayload,
            {
              headers: {
                "Content-Type": "application/json",
              },
              timeout: 60000, // 60 second timeout
              maxContentLength: Infinity,
              maxBodyLength: Infinity,
            }
          );

          // Check response
          if (
            response.data &&
            response.data.success &&
            response.data.filename
          ) {
            // Update user's speaker_file with the returned filename
            await updateUserParameter(
              user.user_id,
              "speaker_file",
              response.data.filename
            );

            logger.log(
              "Audio",
              `Successfully processed voice files for user ${user.user_id}, saved as ${response.data.filename}`
            );

            // Redirect with success message
            return reply.redirect(
              "/web/character?success=Voice+files+uploaded+successfully"
            );
          } else {
            logger.error(
              "Audio",
              `Helper API error: ${JSON.stringify(response.data)}`
            );
            return reply.redirect(
              "/web/character?error=Failed+to+process+voice+files"
            );
          }
        } catch (apiError) {
          logger.error(
            "Audio",
            `Helper API request failed: ${apiError.message}`
          );

          let errorMessage = "Upload+failed";
          if (
            apiError.code === "ECONNREFUSED" ||
            apiError.code === "ECONNABORTED"
          ) {
            errorMessage = "Voice+processing+service+unavailable";
          } else if (apiError.response && apiError.response.status) {
            errorMessage = `Server+error+${apiError.response.status}`;
          }

          return reply.redirect(`/web/character?error=${errorMessage}`);
        }
      } catch (error) {
        logger.error("Audio", `Error in voice upload route: ${error.message}`);
        return reply.redirect("/web/character?error=Internal+server+error");
      }
    }
  );

  // Logout route
  fastify.get("/auth/logout", async (request, reply) => {
    reply.clearCookie("enspira_session");
    return reply.redirect("/web/auth/login");
  });

  fastify.post(
    "/character/features",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Extract values from form data
        const funFacts = getFieldValue(request.body.funFacts) === "true";
        const funFactsInterval = parseInt(
          getFieldValue(request.body.funFactsInterval),
          10
        );
        const ttsEnabled = getFieldValue(request.body.tts_enabled) === "true";
        const ttsEqPref = getFieldValue(request.body.ttsEqPref);
        const ttsUpsamplePref =
          getFieldValue(request.body.ttsUpsamplePref) === "true";

        // Validate funFactsInterval
        const interval = Math.max(5, Math.min(240, funFactsInterval || 30));

        // Update user parameters
        await updateUserParameter(user.user_id, "funFacts", funFacts);
        await updateUserParameter(user.user_id, "funFactsInterval", interval);
        await updateUserParameter(user.user_id, "tts_enabled", ttsEnabled);

        // Only update TTS-related settings if TTS is enabled
        if (ttsEnabled) {
          await updateUserParameter(user.user_id, "ttsEqPref", ttsEqPref);
          await updateUserParameter(
            user.user_id,
            "ttsUpsamplePref",
            ttsUpsamplePref
          );
        }

        reply.send({
          success: true,
          message: "Character features updated successfully",
        });
      } catch (error) {
        logger.error(
          "Web",
          `Error updating character features: ${error.message}`
        );
        reply.code(500).send({
          success: false,
          error: "An error occurred while updating character features",
        });
      }
    }
  );

  fastify.get(
    "/auth/twitch/connect",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const { type } = request.query;
        const user = request.user;

        if (!type || (type !== "bot" && type !== "streamer")) {
          return reply.code(400).send({ error: "Invalid account type" });
        }

        // Generate auth token and store it temporarily
        const authToken = crypto.randomBytes(32).toString("hex");

        global.pendingTwitchAuths = global.pendingTwitchAuths || new Map();
        global.pendingTwitchAuths.set(authToken, {
          userId: user.user_id,
          createdAt: Date.now(),
          authType: type,
        });

        // Get the scopes based on auth type
        const scopeType = type;
        let scopeValue;

        try {
          // Get the scopes from config
          const configScopes = await retrieveConfigValue(
            `twitch.scopes.${scopeType}`
          );

          // Handle different possible formats
          if (Array.isArray(configScopes)) {
            scopeValue = configScopes.join(" ");
          } else if (typeof configScopes === "string") {
            scopeValue = configScopes;
          } else if (configScopes === null || configScopes === undefined) {
            if (scopeType === "bot") {
              scopeValue = "chat:read chat:edit user:read:email";
            } else {
              scopeValue =
                "channel:read:broadcast channel:read:subscriptions channel:read:hype_train channel:read:follows";
            }
            logger.log(
              "Auth",
              `No twitch.scopes.${scopeType} found in config, using defaults`
            );
          } else {
            scopeValue = String(configScopes);
            logger.log(
              "Auth",
              `Unexpected type for twitch.scopes.${scopeType}: ${typeof configScopes}. Converting to string.`
            );
          }
        } catch (error) {
          logger.error(
            "Auth",
            `Error getting Twitch scopes: ${error.message}. Using defaults.`
          );
          if (scopeType === "bot") {
            scopeValue = "chat:read chat:edit user:read:email";
          } else {
            scopeValue =
              "channel:read:broadcast channel:read:subscriptions channel:read:hype_train channel:read:follows";
          }
        }

        // Create the Twitch OAuth URL
        const authUrl = new URL("https://id.twitch.tv/oauth2/authorize");
        authUrl.searchParams.set(
          "client_id",
          await retrieveConfigValue("twitch.clientId")
        );
        authUrl.searchParams.set(
          "redirect_uri",
          await retrieveConfigValue("twitch.redirectUri")
        );
        authUrl.searchParams.set("response_type", "code");
        authUrl.searchParams.set("scope", scopeValue);
        authUrl.searchParams.set("state", authToken);

        // Force login prompt if connecting a bot account
        if (type === "bot") {
          authUrl.searchParams.set("force_verify", "true");
        }

        return reply.redirect(authUrl.toString());
      } catch (error) {
        logger.error("Auth", `Error in Twitch connect: ${error.message}`);
        return reply.code(500).send({ error: "An error occurred" });
      }
    }
  );

  // 2. Authentication endpoint that verifies credentials
  fastify.post("/auth/twitch/authenticate", async (request, reply) => {
    try {
      // 1. Validate request body
      if (!request.body || typeof request.body !== "object") {
        return reply.code(400).send({ error: "Invalid request format" });
      }

      const { user_id, password, auth_type } = request.body;

      // 2. Check for required fields
      if (!user_id || !password) {
        return reply.code(400).send({ error: "Missing required fields" });
      }

      // Log the auth_type to debug
      logger.log(
        "Auth",
        `Authenticating user: ${user_id} for ${auth_type || "streamer"} account`
      );

      // 4. Get user details
      const user = await returnAuthObject(user_id);

      if (!user) {
        return reply.code(401).send({ error: "User not found" });
      }

      // 5. Check if password hash and salt exist
      if (!user.webPasswordHash || !user.webPasswordSalt) {
        logger.log("Auth", `User ${user_id} has no password set`);
        return reply.code(401).send({
          error: "No password set for this account",
          setupRequired: true,
        });
      }

      // 6. Validate parameters for isPasswordCorrect
      const iterations = user.webPasswordIterations || 20480;

      logger.log(
        "Auth",
        `Verifying password with hash=${user.webPasswordHash ? "exists" : "missing"}, salt=${user.webPasswordSalt ? "exists" : "missing"}`
      );

      // 7. Verify password with explicit parameter validation
      const passwordCorrect = await isPasswordCorrect(
        user.webPasswordHash,
        user.webPasswordSalt,
        iterations,
        password
      );

      if (!passwordCorrect) {
        return reply.code(401).send({ error: "Invalid credentials" });
      }

      // Generate auth token and store it temporarily
      const authToken = crypto.randomBytes(32).toString("hex");

      global.pendingTwitchAuths = global.pendingTwitchAuths || new Map();
      global.pendingTwitchAuths.set(authToken, {
        userId: user_id,
        createdAt: Date.now(),
        authType: auth_type || "streamer", // Default to streamer if not specified
      });

      // Get the scopes based on auth type (bot or streamer)
      const scopeType = auth_type === "bot" ? "bot" : "streamer";
      let scopeValue;

      try {
        // Get the scopes from config
        const configScopes = await retrieveConfigValue(
          `twitch.scopes.${scopeType}`
        );

        // Handle different possible formats
        if (Array.isArray(configScopes)) {
          // If it's already an array, just join it
          scopeValue = configScopes.join(" ");
        } else if (typeof configScopes === "string") {
          // If it's a single string, use it directly
          scopeValue = configScopes;
        } else if (configScopes === null || configScopes === undefined) {
          // If not configured, use default scopes based on type
          if (scopeType === "bot") {
            scopeValue = "chat:read chat:edit user:read:email";
          } else {
            scopeValue =
              "channel:read:broadcast channel:read:subscriptions channel:read:hype_train channel:read:follows";
          }
          logger.log(
            "Auth",
            `No twitch.scopes.${scopeType} found in config, using defaults`
          );
        } else {
          // Unexpected type, convert to string
          scopeValue = String(configScopes);
          logger.log(
            "Auth",
            `Unexpected type for twitch.scopes.${scopeType}: ${typeof configScopes}. Converting to string.`
          );
        }
      } catch (error) {
        // Fallback to default scopes if there's an error
        logger.error(
          "Auth",
          `Error getting Twitch scopes: ${error.message}. Using defaults.`
        );
        if (scopeType === "bot") {
          scopeValue = "chat:read chat:edit user:read:email";
        } else {
          scopeValue =
            "channel:read:broadcast channel:read:subscriptions channel:read:hype_train channel:read:follows";
        }
      }

      // Now use scopeValue in the URL
      const authUrl = new URL("https://id.twitch.tv/oauth2/authorize");
      authUrl.searchParams.set(
        "client_id",
        await retrieveConfigValue("twitch.clientId")
      );
      authUrl.searchParams.set(
        "redirect_uri",
        await retrieveConfigValue("twitch.redirectUri")
      );
      authUrl.searchParams.set("response_type", "code");
      authUrl.searchParams.set("scope", scopeValue);
      authUrl.searchParams.set("state", authToken);
      if (auth_type === "bot") {
        authUrl.searchParams.set("force_verify", "true");
      }
      return reply.redirect(authUrl.toString());
    } catch (error) {
      logger.error(
        "Auth",
        `Error during Twitch authentication: ${error.message}`
      );
      return reply
        .code(500)
        .send({ error: "Authentication error", details: error.message });
    }
  });

  // 3. Callback from Twitch OAuth
  fastify.get("/auth/twitch/callback", async (request, reply) => {
    const { code, state } = request.query;

    // Verify state token exists in our pending auths
    if (!global.pendingTwitchAuths || !global.pendingTwitchAuths.has(state)) {
      return reply.code(400).send("Invalid or expired authorization request");
    }

    // Get user ID from the stored mapping
    const { userId, createdAt, authType } =
      global.pendingTwitchAuths.get(state);

    // Check if the token has expired (e.g., after 10 minutes)
    if (Date.now() - createdAt > 10 * 60 * 1000) {
      global.pendingTwitchAuths.delete(state);
      return reply.code(400).send("Authorization request expired");
    }

    try {
      const axios = (await import("axios")).default;
      // Exchange code for access token
      const tokenResponse = await axios.post(
        "https://id.twitch.tv/oauth2/token",
        {
          client_id: await retrieveConfigValue("twitch.clientId"),
          client_secret: await retrieveConfigValue("twitch.clientSecret"),
          code,
          grant_type: "authorization_code",
          redirect_uri: await retrieveConfigValue("twitch.redirectUri"),
        }
      );

      const { access_token, refresh_token, expires_in } = tokenResponse.data;

      // Get user info from Twitch
      const userResponse = await axios.get(
        "https://api.twitch.tv/helix/users",
        {
          headers: {
            "Client-ID": await retrieveConfigValue("twitch.clientId"),
            Authorization: `Bearer ${access_token}`,
          },
        }
      );

      const twitchUserInfo = userResponse.data.data[0];

      // Store tokens in user record - use the appropriate field based on auth type
      const tokenPath =
        authType === "bot" ? "twitch_tokens.bot" : "twitch_tokens.streamer";

      await updateUserParameter(userId, tokenPath, {
        access_token,
        refresh_token,
        expires_at: Date.now() + expires_in * 1000,
        twitch_user_id: twitchUserInfo.id,
        twitch_login: twitchUserInfo.login,
        twitch_display_name: twitchUserInfo.display_name,
      });

      // Clean up the pending auth
      global.pendingTwitchAuths.delete(state);

      // Redirect back to the management page
      return reply.redirect("/web/dashboard");
    } catch (error) {
      logger.log(
        "Auth",
        `Error during Twitch token exchange: ${error.message}`
      );
      return reply.code(500).send("Failed to complete Twitch authorization");
    }
  });

  function getFieldValue(field) {
    if (!field) return "";

    // If the field is a Part object from @fastify/multipart
    if (field.value !== undefined) {
      return field.value;
    }

    // If the field is already a string
    if (typeof field === "string") {
      return field;
    }

    // If the field is a readable stream (file upload)
    if (field.pipe && typeof field.pipe === "function") {
      // For this implementation, we're not handling file uploads
      // If needed, use stream handling here
      return "";
    }

    // Return empty string for any other case
    return "";
  }

  // Character personality update endpoint
  fastify.post(
    "/character/personality",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Extract values safely from multipart form data
        const botName = getFieldValue(request.body.bot_name);
        const personality = getFieldValue(request.body.personality);

        // Update bot name in user record
        await updateUserParameter(user.user_id, "bot_name", botName);

        // Save personality to file
        const success = await saveTextContent(
          user.user_id,
          "character_personality",
          personality
        );

        if (success) {
          reply.send({
            success: true,
            message: "Personality updated successfully",
          });
        } else {
          reply
            .code(500)
            .send({ success: false, error: "Failed to save personality" });
        }
      } catch (error) {
        logger.error("Web", `Error updating personality: ${error.message}`);
        reply.code(500).send({
          success: false,
          error: "An error occurred while updating personality",
        });
      }
    }
  );

  // Character description update endpoint
  fastify.post(
    "/character/description",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Extract values safely from multipart form data
        const description = getFieldValue(request.body.description);
        const botTwitch = getFieldValue(request.body.bot_twitch);

        // Save description to file
        const success = await saveTextContent(
          user.user_id,
          "character_card",
          description
        );

        // Update bot_twitch if provided
        if (botTwitch) {
          await updateUserParameter(user.user_id, "bot_twitch", botTwitch);
        }

        if (success) {
          reply.send({
            success: true,
            message: "Description updated successfully",
          });
        } else {
          reply
            .code(500)
            .send({ success: false, error: "Failed to save description" });
        }
      } catch (error) {
        logger.error("Web", `Error updating description: ${error.message}`);
        reply.code(500).send({
          success: false,
          error: "An error occurred while updating description",
        });
      }
    }
  );

  // Character examples update endpoint
  fastify.post(
    "/character/examples",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Extract value safely from multipart form data
        const examples = getFieldValue(request.body.examples);

        // Save examples to file
        const success = await saveTextContent(
          user.user_id,
          "examples",
          examples
        );

        if (success) {
          reply.send({
            success: true,
            message: "Examples updated successfully",
          });
        } else {
          reply
            .code(500)
            .send({ success: false, error: "Failed to save examples" });
        }
      } catch (error) {
        logger.error("Web", `Error updating examples: ${error.message}`);
        reply.code(500).send({
          success: false,
          error: "An error occurred while updating examples",
        });
      }
    }
  );

  // World info update endpoint
  fastify.post(
    "/world/info",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Extract values safely from multipart form data
        const worldInfo = getFieldValue(request.body.world_info);
        const weatherEnabled = getFieldValue(request.body.weather_enabled);

        // Update weather flag in user record
        await updateUserParameter(
          user.user_id,
          "weather",
          weatherEnabled === "true"
        );

        // Save world info to file
        const success = await saveTextContent(
          user.user_id,
          "world_lore",
          worldInfo
        );

        if (success) {
          reply.send({
            success: true,
            message: "World information updated successfully",
          });
        } else {
          reply.code(500).send({
            success: false,
            error: "Failed to save world information",
          });
        }
      } catch (error) {
        logger.error("Web", `Error updating world info: ${error.message}`);
        reply.code(500).send({
          success: false,
          error: "An error occurred while updating world information",
        });
      }
    }
  );

  // Player info update endpoint
  fastify.post(
    "/world/player",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Extract values safely from multipart form data
        const playerInfo = getFieldValue(request.body.player_info);
        const commandsList = getFieldValue(request.body.commands_list);

        // Update commands list in user record if provided
        if (commandsList) {
          const commandsArray = commandsList
            .split("\n")
            .map((cmd) => cmd.trim())
            .filter((cmd) => cmd.length > 0);
          await updateUserParameter(
            user.user_id,
            "commands_list",
            commandsArray
          );
        }

        // Save player info to file
        const success = await saveTextContent(
          user.user_id,
          "player_info",
          playerInfo
        );

        if (success) {
          reply.send({
            success: true,
            message: "Player information updated successfully",
          });
        } else {
          reply.code(500).send({
            success: false,
            error: "Failed to save player information",
          });
        }
      } catch (error) {
        logger.error("Web", `Error updating player info: ${error.message}`);
        reply.code(500).send({
          success: false,
          error: "An error occurred while updating player information",
        });
      }
    }
  );

  // Scenario update endpoint
  fastify.post(
    "/world/scenario",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Extract values safely from multipart form data
        const scenario = getFieldValue(request.body.scenario);
        const auxBots = getFieldValue(request.body.aux_bots);

        // Update aux bots list in user record if provided
        if (auxBots) {
          const auxBotsArray = auxBots
            .split("\n")
            .map((bot) => bot.trim())
            .filter((bot) => bot.length > 0);
          await updateUserParameter(user.user_id, "aux_bots", auxBotsArray);
        }

        // Save scenario to file
        const success = await saveTextContent(
          user.user_id,
          "scenario",
          scenario
        );

        if (success) {
          reply.send({
            success: true,
            message: "Scenario updated successfully",
          });
        } else {
          reply
            .code(500)
            .send({ success: false, error: "Failed to save scenario" });
        }
      } catch (error) {
        logger.error("Web", `Error updating scenario: ${error.message}`);
        reply.code(500).send({
          success: false,
          error: "An error occurred while updating scenario",
        });
      }
    }
  );

  fastify.post(
    "/alternate-spellings",
    {
      preHandler: fastify.authenticate,
      schema: {
        body: {
          type: "object",
          properties: {
            spelling: {
              oneOf: [
                { type: "string" },
                {
                  type: "object",
                  properties: {
                    from: { type: "string" },
                    to: { type: "string" },
                  },
                  required: ["from", "to"],
                },
              ],
            },
          },
          required: ["spelling"],
        },
      },
    },
    async (request, reply) => {
      try {
        const userId = request.user.user_id;
        const { spelling } = request.body;

        // Import the function from mongodb-client
        const { addAlternateSpelling } = await import("../mongodb-client.js");

        const success = await addAlternateSpelling(userId, spelling);

        if (success) {
          return reply.send({
            success: true,
            message: "Alternate spelling added successfully",
            data: { spelling },
          });
        } else {
          return reply.code(400).send({
            success: false,
            error: "Failed to add alternate spelling",
          });
        }
      } catch (error) {
        logger.error(
          "API",
          `Error adding alternate spelling: ${error.message}`
        );
        return reply.code(500).send({
          success: false,
          error: "Internal server error",
        });
      }
    }
  );

  fastify.delete(
    "/alternate-spellings",
    {
      preHandler: fastify.authenticate,
      schema: {
        body: {
          type: "object",
          properties: {
            spelling: {
              oneOf: [
                { type: "string" },
                {
                  type: "object",
                  properties: {
                    from: { type: "string" },
                    to: { type: "string" },
                  },
                  required: ["from", "to"],
                },
              ],
            },
          },
          required: ["spelling"],
        },
      },
    },
    async (request, reply) => {
      try {
        const userId = request.user.user_id;
        const { spelling } = request.body;

        // Import the function from mongodb-client
        const { removeAlternateSpelling } = await import(
          "../mongodb-client.js"
        );

        const success = await removeAlternateSpelling(userId, spelling);

        if (success) {
          return reply.send({
            success: true,
            message: "Alternate spelling removed successfully",
            data: { spelling },
          });
        } else {
          return reply.code(400).send({
            success: false,
            error: "Failed to remove alternate spelling",
          });
        }
      } catch (error) {
        logger.error(
          "API",
          `Error removing alternate spelling: ${error.message}`
        );
        return reply.code(500).send({
          success: false,
          error: "Internal server error",
        });
      }
    }
  );

  // Test alternate spelling replacement
  fastify.post(
    "/alternate-spellings/test",
    {
      preHandler: fastify.authenticate,
      schema: {
        body: {
          type: "object",
          properties: {
            text: { type: "string" },
          },
          required: ["text"],
        },
      },
    },
    async (request, reply) => {
      try {
        const userId = request.user.user_id;
        const { text } = request.body;
        const userObj = await returnAuthObject(userId);

        if (!userObj) {
          return reply.code(404).send({
            success: false,
            error: "User not found",
          });
        }

        // Apply alternate spelling logic
        let processedText = text;
        const alternateSpellings = userObj.alternateSpell || [];

        function escapeRegExp(string) {
          return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }

        const replacements = [];

        for (const alternateEntry of alternateSpellings) {
          if (typeof alternateEntry === "string") {
            const regex = new RegExp(
              `\\b${escapeRegExp(alternateEntry)}\\b`,
              "gi"
            );
            const matches = text.match(regex);
            if (matches) {
              processedText = processedText.replace(regex, userObj.bot_name);
              replacements.push({
                from: alternateEntry,
                to: userObj.bot_name,
                occurrences: matches.length,
              });
            }
          } else if (
            typeof alternateEntry === "object" &&
            alternateEntry.from &&
            alternateEntry.to
          ) {
            const regex = new RegExp(
              `\\b${escapeRegExp(alternateEntry.from)}\\b`,
              "gi"
            );
            const matches = text.match(regex);
            if (matches) {
              processedText = processedText.replace(regex, alternateEntry.to);
              replacements.push({
                from: alternateEntry.from,
                to: alternateEntry.to,
                occurrences: matches.length,
              });
            }
          }
        }

        return reply.send({
          success: true,
          data: {
            original_text: text,
            processed_text: processedText,
            replacements: replacements,
            bot_name: userObj.bot_name,
            alternate_spellings_used: alternateSpellings,
          },
        });
      } catch (error) {
        logger.error(
          "API",
          `Error testing alternate spellings: ${error.message}`
        );
        return reply.code(500).send({
          success: false,
          error: "Internal server error",
        });
      }
    }
  );

  fastify.get(
    "/alternate-spellings",
    {
      preHandler: fastify.authenticate,
    },
    async (request, reply) => {
      try {
        const userId = request.user.user_id;
        const userObj = await returnAuthObject(userId);

        if (!userObj) {
          return reply.code(404).send({
            success: false,
            error: "User not found",
          });
        }

        return reply.send({
          success: true,
          data: {
            bot_name: userObj.bot_name,
            alternate_spellings: userObj.alternateSpell || [],
            count: (userObj.alternateSpell || []).length,
          },
        });
      } catch (error) {
        logger.error(
          "API",
          `Error fetching alternate spellings: ${error.message}`
        );
        return reply.code(500).send({
          success: false,
          error: "Internal server error",
        });
      }
    }
  );

  // Bot configuration update endpoint
  fastify.post(
    "/world/bot-config",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Extract values safely from multipart form data
        const commandsList = getFieldValue(request.body.commands_list);
        const auxBots = getFieldValue(request.body.aux_bots);

        // Update commands list in user record
        const commandsArray = commandsList
          .split("\n")
          .map((cmd) => cmd.trim())
          .filter((cmd) => cmd.length > 0);

        await updateUserParameter(user.user_id, "commands_list", commandsArray);

        // Update aux bots list in user record
        const auxBotsArray = auxBots
          .split("\n")
          .map((bot) => bot.trim())
          .filter((bot) => bot.length > 0);

        await updateUserParameter(user.user_id, "aux_bots", auxBotsArray);

        reply.send({
          success: true,
          message: "Bot configuration updated successfully",
        });
      } catch (error) {
        logger.error(
          "Web",
          `Error updating bot configuration: ${error.message}`
        );
        reply.code(500).send({
          success: false,
          error: "An error occurred while updating bot configuration",
        });
      }
    }
  );
  // Preferences settings update endpoint
  fastify.post(
    "/settings/preferences",
    { preHandler: requireAuth },
    async (request, reply) => {
      try {
        const user = request.user;

        // Extract values from form data
        const storeAllChat =
          getFieldValue(request.body.store_all_chat) === "true";
        const ttsEnabled = getFieldValue(request.body.tts_enabled) === "true";
        const ttsEqPref = getFieldValue(request.body.ttsEqPref);
        const ttsUpsamplePref =
          getFieldValue(request.body.ttsUpsamplePref) === "true";

        // Update user parameters
        await updateUserParameter(user.user_id, "store_all_chat", storeAllChat);
        await updateUserParameter(user.user_id, "tts_enabled", ttsEnabled);
        await updateUserParameter(user.user_id, "ttsEqPref", ttsEqPref);
        await updateUserParameter(
          user.user_id,
          "ttsUpsamplePref",
          ttsUpsamplePref
        );

        return reply.send({
          success: true,
          message: "Preferences updated successfully",
        });
      } catch (error) {
        logger.error("Web", `Error updating preferences: ${error.message}`);
        return reply.code(500).send({
          success: false,
          error: "An error occurred while updating preferences",
        });
      }
    }
  );
  fastify.post(
    "/gallery/:characterId/use",
    { preHandler: requireAuth },
    async (request, reply) => {
      const { user } = request;
      const { characterId } = request.params;

      try {
        const preset = await loadPreset(characterId);
        if (!preset) {
          return reply
            .code(404)
            .send({ success: false, error: "Character preset not found" });
        }

        logger.log(
          "Web",
          `Applying character preset: ${preset.name} (${characterId}) for user ${user.user_id}`
        );

        // Extract the internal format for saving to user files
        const personalityContent =
          preset.personality.internalFmt || preset.personality || "";
        const descriptionContent =
          preset.char_description.internalFmt || preset.char_description || "";

        // Apply the preset data to the user
        const nameUpdate = await updateUserParameter(
          user.user_id,
          "bot_name",
          preset.name
        );

        // Save personality and description to files
        const personalitySave = await saveTextContent(
          user.user_id,
          "character_personality",
          personalityContent
        );
        const descriptionSave = await saveTextContent(
          user.user_id,
          "character_card",
          descriptionContent
        );

        // Make sure bot_twitch is set if present in the preset
        if (preset.bot_twitch) {
          await updateUserParameter(
            user.user_id,
            "bot_twitch",
            preset.bot_twitch
          );
        }

        if (nameUpdate && personalitySave && descriptionSave) {
          logger.log(
            "Web",
            `Successfully applied preset '${characterId}' for user ${user.user_id}`
          );

          // Respond with success and a redirect URL for the frontend handler
          return reply.send({
            success: true,
            message: `Character preset "${preset.name}" applied successfully!`,
            redirect: "/web/character",
          });
        } else {
          logger.error(
            "Web",
            `Failed to fully apply preset '${characterId}' for user ${user.user_id}`
          );
          return reply.code(500).send({
            success: false,
            error: "Failed to save all character data",
          });
        }
      } catch (error) {
        logger.error(
          "Web",
          `Error applying preset '${characterId}' for user ${user.user_id}: ${error.message}`
        );
        return reply.code(500).send({
          success: false,
          error: "An error occurred while applying the preset",
        });
      }
    }
  );
}

/**
 * Lightweight WAV file parser that doesn't require audio output devices
 * @param {Buffer} buffer - The WAV file buffer to analyze
 * @returns {Object} - Validation result with audio properties
 */
async function validateWavBuffer(buffer) {
  try {
    // Log the buffer size for debugging
    logger.log("Audio", `Analyzing WAV buffer of size: ${buffer.length} bytes`);

    // Check if the buffer is valid and has enough bytes for a WAV header
    if (!buffer || buffer.length < 44) {
      return {
        valid: false,
        reason: "Invalid WAV file: too small or corrupted",
      };
    }

    // Check WAV header magic bytes (RIFF....WAVE)
    const isRiff = buffer.slice(0, 4).toString() === "RIFF";
    const isWave = buffer.slice(8, 12).toString() === "WAVE";

    if (!isRiff || !isWave) {
      logger.error(
        "Audio",
        `Invalid WAV header: RIFF=${isRiff}, WAVE=${isWave}`
      );
      return {
        valid: false,
        reason: "Invalid WAV file: incorrect format",
      };
    }

    // Find the 'fmt ' chunk
    let offset = 12; // Start after "WAVE"
    let fmtChunkFound = false;

    // Parse all chunks until we find 'fmt '
    while (offset < buffer.length - 8) {
      const chunkId = buffer.slice(offset, offset + 4).toString();
      const chunkSize = buffer.readUInt32LE(offset + 4);

      if (chunkId === "fmt ") {
        fmtChunkFound = true;
        break;
      }

      offset += 8 + chunkSize;
    }

    if (!fmtChunkFound) {
      logger.error("Audio", "WAV file missing 'fmt ' chunk");
      return {
        valid: false,
        reason: "Invalid WAV file: missing format information",
      };
    }

    // Now parse the format chunk
    offset += 8; // Skip chunk ID and size

    // Audio format (PCM = 1)
    const audioFormat = buffer.readUInt16LE(offset);

    // Number of channels
    const numChannels = buffer.readUInt16LE(offset + 2);

    // Sample rate
    const sampleRate = buffer.readUInt32LE(offset + 4);

    // Bytes per second
    const byteRate = buffer.readUInt32LE(offset + 8);

    // Bits per sample
    const bitsPerSample = buffer.readUInt16LE(offset + 14);

    // Find data chunk to calculate duration
    let dataSize = 0;
    offset = 12; // Reset to start after "WAVE"

    while (offset < buffer.length - 8) {
      const chunkId = buffer.slice(offset, offset + 4).toString();
      const chunkSize = buffer.readUInt32LE(offset + 4);

      if (chunkId === "data") {
        dataSize = chunkSize;
        break;
      }

      offset += 8 + chunkSize;
    }

    // Calculate duration
    const bytesPerSample = bitsPerSample / 8;
    const totalSamples = dataSize / (bytesPerSample * numChannels);
    const duration = totalSamples / sampleRate;

    // Log the results
    logger.log(
      "Audio",
      `WAV analysis: format=${audioFormat}, channels=${numChannels}, sampleRate=${sampleRate}Hz, bitsPerSample=${bitsPerSample}, duration=${duration.toFixed(2)}s`
    );

    // Validate requirements
    if (numChannels !== 1) {
      return {
        valid: false,
        reason: `Audio must be mono (found ${numChannels} channels)`,
      };
    }

    // Accept common sample rates: 22050Hz, 44100Hz, 48000Hz
    const acceptableSampleRates = [22050, 44100, 48000];
    const closestRate = acceptableSampleRates.reduce((prev, curr) =>
      Math.abs(curr - sampleRate) < Math.abs(prev - sampleRate) ? curr : prev
    );

    // Allow more variance (within 10% of target rate)
    if (Math.abs(sampleRate - closestRate) / closestRate > 0.1) {
      logger.warn(
        "Audio",
        `Unusual sample rate detected: ${sampleRate}Hz, closest standard rate: ${closestRate}Hz`
      );
      // We'll still accept it and let the voice API handle resampling
    }

    if (duration > 20) {
      return {
        valid: false,
        reason: `Duration exceeds 20 seconds (${duration.toFixed(1)}s)`,
      };
    }

    // Return all the parsed information
    return {
      valid: true,
      sampleRate,
      numChannels,
      bitsPerSample,
      duration,
      format: audioFormat === 1 ? "PCM" : "Non-PCM",
      closestStandardRate: closestRate,
    };
  } catch (error) {
    logger.error("Audio", `Error analyzing WAV file: ${error.message}`);
    return {
      valid: false,
      reason: `Failed to analyze WAV file: ${error.message}`,
    };
  }
}

/**
 * Saves text content to a file
 * @param {string} userId - The user ID
 * @param {string} fileName - The file name
 * @param {string} content - The content to save
 * @returns {Promise<boolean>} - True if successful, false otherwise
 */
export async function saveTextContent(userId, fileName, content) {
  try {
    const filePath = path.join(
      process.cwd(),
      "world_info",
      userId,
      `${fileName}.txt`
    );

    // Create directory if it doesn't exist
    await fs.ensureDir(path.join(process.cwd(), "world_info", userId));

    // Write content to file
    await fs.writeFile(filePath, content);
    return true;
  } catch (error) {
    logger.error(
      "Web",
      `Error saving ${fileName} for user ${userId}: ${error.message}`
    );
    return false;
  }
}

export async function hashPassword(password) {
  return new Promise((resolve, reject) => {
    try {
      const salt = crypto.randomBytes(128).toString("base64");
      const iterations = 20480;
      const keylen = 64;
      const digest = "sha512";

      crypto.pbkdf2(
        password,
        salt,
        iterations,
        keylen,
        digest,
        (err, derivedKey) => {
          if (err) {
            reject(err);
            return;
          }

          resolve({
            salt: salt,
            hash: derivedKey.toString("hex"),
            iterations: iterations,
            digest: digest,
          });
        }
      );
    } catch (error) {
      reject(error);
    }
  });
}

export async function isPasswordCorrect(
  savedHash,
  savedSalt,
  savedIterations,
  passwordAttempt
) {
  // Validate parameters
  if (!savedHash || !savedSalt || !passwordAttempt) {
    throw new Error("Missing required parameters for password verification");
  }

  // Ensure all parameters are strings
  savedHash = String(savedHash);
  savedSalt = String(savedSalt);
  passwordAttempt = String(passwordAttempt);

  // Ensure iterations is a number
  const iterations = Number(savedIterations) || 20480;

  return new Promise((resolve, reject) => {
    try {
      const digest = "sha512";
      const keylen = 64;

      crypto.pbkdf2(
        passwordAttempt,
        savedSalt,
        iterations,
        keylen,
        digest,
        (err, derivedKey) => {
          if (err) {
            reject(err);
            return;
          }

          const hash = derivedKey.toString("hex");
          resolve(savedHash === hash);
        }
      );
    } catch (error) {
      reject(error);
    }
  });
}

async function configureResponseHandling(fastify) {
  if (fastify.hasPlugin("fastify-compress")) {
    logger.log(
      "API",
      "Compression plugin already registered, updating configuration"
    );
  }

  // Configure response timeouts if server is available
  if (fastify.server) {
    // Use safer timeout values
    if (typeof fastify.server.keepAliveTimeout === "number") {
      fastify.server.keepAliveTimeout = 120000; // 2 minutes
    }
    if (typeof fastify.server.headersTimeout === "number") {
      fastify.server.headersTimeout = 65000; // Just above default 60s
    }
  }

  // Add hook to handle large responses - this should work regardless of server setup
  fastify.addHook("onRequest", (request, reply, done) => {
    // Set default headers for all responses
    reply.header("Content-Type", "application/json; charset=utf-8");
    done();
  });

  // Add response monitoring middleware
  fastify.addHook("onSend", (request, reply, payload, done) => {
    // For debugging, log payload size
    if (payload) {
      const size =
        typeof payload === "json"
          ? payload.length
          : JSON.stringify(payload).length;
      logger.log(
        "API",
        `Response payload size: ${size} bytes for ${request.url}`
      );

      // Check for suspiciously small payloads
      if (
        size < 5 &&
        request.method !== "HEAD" &&
        request.method !== "OPTIONS"
      ) {
        logger.log(
          "API",
          `WARNING: Very small response detected for ${request.url}: ${payload}`
        );
      }
    }

    // Make sure content type is set
    if (!reply.getHeader("content-type")) {
      reply.header("Content-Type", "application/json; charset=utf-8");
    }

    done(null, payload);
  });

  // Add a simple response helper method to the reply object
  fastify.decorateReply("sendSafe", function (data) {
    // If the data is already a string, use it directly
    if (typeof data === "string") {
      return this.type("text/plain; charset=utf-8").send(data);
    }

    try {
      // Try to stringify the data safely
      const safeJSON = JSON.stringify(data);
      return this.type("application/json; charset=utf-8").send(safeJSON);
    } catch (error) {
      logger.log("API", `Error stringifying response: ${error.message}`);
      // Send a fallback response
      return this.code(500).send(
        JSON.stringify({
          error: "Error generating response",
          message: "Failed to serialize response data",
        })
      );
    }
  });

  logger.log("API", "Response handling configuration completed");
}

/**
 * Load all character presets from the presets directory
 * @returns {Promise<Array>} Array of character preset objects
 */
export async function loadAllPresets() {
  try {
    const presetsDir = path.join(process.cwd(), "presets");

    // Make sure the directory exists
    await fs.ensureDir(presetsDir);

    const files = await fs.readdir(presetsDir);

    // Only process JSON files
    const jsonFiles = files.filter((file) => file.endsWith(".json"));

    // If no presets found, return empty array
    if (jsonFiles.length === 0) {
      logger.log("Web", "No character presets found in presets directory");
      return [];
    }

    // Load each preset file
    const presets = await Promise.all(
      jsonFiles.map(async (file) => {
        try {
          const filePath = path.join(presetsDir, file);
          const data = await fs.readFile(filePath, "utf8");
          const preset = JSON.parse(data);

          // Add the filename (without extension) as an ID
          preset.id = path.basename(file, ".json");

          // Handle basic preset fields
          preset.name = preset.name || "Unnamed Character";
          preset.author = preset.author || "Unknown Author";
          preset.summary = preset.summary || "No description provided.";

          // Handle nested personality structure
          if (
            typeof preset.personality === "object" &&
            preset.personality !== null
          ) {
            // Already using new format
            preset.personality.internalFmt =
              preset.personality.internalFmt || "";
            preset.personality.publicFmt = preset.personality.publicFmt || "";
          } else if (typeof preset.personality === "string") {
            // Convert old format to new
            const personalityText = preset.personality;
            preset.personality = {
              internalFmt: personalityText,
              publicFmt: personalityText,
            };
          } else {
            // Initialize with empty values
            preset.personality = {
              internalFmt: "",
              publicFmt: "",
            };
          }

          // Handle nested character description structure
          if (
            typeof preset.char_description === "object" &&
            preset.char_description !== null
          ) {
            // Already using new format
            preset.char_description.internalFmt =
              preset.char_description.internalFmt || "";
            preset.char_description.publicFmt =
              preset.char_description.publicFmt || "";
          } else if (typeof preset.char_description === "string") {
            // Convert old format to new
            const descriptionText = preset.char_description;
            preset.char_description = {
              internalFmt: descriptionText,
              publicFmt: descriptionText,
            };
          } else {
            // Initialize with empty values
            preset.char_description = {
              internalFmt: "",
              publicFmt: "",
            };
          }

          // Default image if not present
          if (!preset.image) {
            preset.image = "/api/placeholder/200/200";
          }

          return preset;
        } catch (err) {
          logger.error("Web", `Error loading preset ${file}: ${err.message}`);
          return null;
        }
      })
    );

    // Filter out any null results from failed loads
    return presets.filter((preset) => preset !== null);
  } catch (error) {
    logger.error("Web", `Error loading presets: ${error.message}`);
    // Return empty array instead of throwing, to show empty gallery
    return [];
  }
}

/**
 * Load a specific character preset by name
 * @param {string} characterId - ID of the character (filename without .json)
 * @returns {Promise<Object|null>} Character preset object or null if not found
 */
export async function loadPreset(characterId) {
  try {
    const filePath = path.join(process.cwd(), "presets", `${characterId}.json`);

    // Check if file exists
    const exists = await fs.pathExists(filePath);
    if (!exists) {
      logger.warn(
        "Web",
        `Character preset file not found: ${characterId}.json`
      );
      return null;
    }

    const data = await fs.readFile(filePath, "utf8");
    const preset = JSON.parse(data);

    // Add the characterId as an ID
    preset.id = characterId;

    // Handle basic preset fields
    preset.name = preset.name || "Unnamed Character";
    preset.author = preset.author || "Unknown Author";
    preset.summary = preset.summary || "No description provided.";

    // Handle nested personality structure
    if (typeof preset.personality === "object" && preset.personality !== null) {
      // Already using new format
      preset.personality.internalFmt = preset.personality.internalFmt || "";
      preset.personality.publicFmt = preset.personality.publicFmt || "";
    } else if (typeof preset.personality === "string") {
      // Convert old format to new
      const personalityText = preset.personality;
      preset.personality = {
        internalFmt: personalityText,
        publicFmt: personalityText,
      };
    } else {
      // Initialize with empty values
      preset.personality = {
        internalFmt: "",
        publicFmt: "",
      };
    }

    // Handle nested character description structure
    if (
      typeof preset.char_description === "object" &&
      preset.char_description !== null
    ) {
      // Already using new format
      preset.char_description.internalFmt =
        preset.char_description.internalFmt || "";
      preset.char_description.publicFmt =
        preset.char_description.publicFmt || "";
    } else if (typeof preset.char_description === "string") {
      // Convert old format to new
      const descriptionText = preset.char_description;
      preset.char_description = {
        internalFmt: descriptionText,
        publicFmt: descriptionText,
      };
    } else {
      // Initialize with empty values
      preset.char_description = {
        internalFmt: "",
        publicFmt: "",
      };
    }

    // Default image if not present
    if (!preset.image) {
      preset.image = "/api/placeholder/200/200";
    }

    return preset;
  } catch (error) {
    if (error.code === "ENOENT") {
      // File not found
      return null;
    }
    logger.error(
      "Web",
      `Error loading preset ${characterId}: ${error.message}`
    );
    return null;
  }
}

export default routes;
</file>

</files>
